[{"title":"K210学习（一）","url":"/2022/03/30/K210%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前言去年电赛就知道K210了，本来最优解决方案就是用K210，但是时间太短了没时间学（还是自己菜），最近刚好毕设要用到，买了一个开发板，正好学习下看看K210怎么跑神经网络的。\n\nK210芯片双核RISC-V处理器架构，算力1TOPS，功耗0.3W，而且国产芯片自带KPU神经网络加速器，一片不到50。（STM32H743也就这水平，效果怎么那么差，当时OPENMV还不支持神经网络，支持神经网络的必须要大SRAM）  \n  \n软件软件用MaixPy，编程跟OPENMV一样使用MicroPython\n  \n硬件开发板使用最小系统板  \n最爱的点灯环节代码  \nfrom fpioa_manager import fm #导入FPIOA库，这个库可以使任意外设映射在任意引脚上\nfrom Maix import GPIO # GPIO外设库\n\nio_led_red = 13    #LED红灯引脚\nfm.register(io_led_red, fm.fpioa.GPIO0)     #映射13引脚为GPIO0\n\nled_r=GPIO(GPIO.GPIO0, GPIO.OUT)    # 设置为输出模式\nwhile True :\n    led_r.value(0)  # 值为0\n    time.delay(1000)\n    led_r.value(1)  # 值为0\n    time.delay(1000)\n\n上传开发板\n","categories":["硬件","K210"]},{"title":"M-watch踩坑记录","url":"/2022/04/06/M-watch%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","content":"M-watch项目记录\n无线电源部分  \n  BQ51013b  \n  替换参考设计的时候要思考，不能用简化器件替代\n  \n              \n          \n      \n              \n      参考设计    \n      \n  \n    \n\n  仅用一个PMOS管代替肯定不行，因为此电路电源双向导通的，OUT端电压先产生，会直接影响AD端电压，使无线充电关闭。\n\n\n"},{"title":"神经影像（一）：Nipype库学习","url":"/2023/07/21/Nipype%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ANipype%E5%BA%93%E5%AD%A6%E4%B9%A0/","content":"Nipype简介Nipype是一个开源神经影像处理软件包，使用python编写。整合了传统神经影像处理软件包的接口（SPM,FSL,FreeSurfer,AFNI以及其他），可以使研究人员通过不同的软件处理图像，将其整合在一起。\n比如你想使用SPM做头动矫正，FreeSurfer做配准，ANTS用来标准化，然后FSL做平滑。使用传统流程会非常麻烦，需要你对各种软件的掌握。使用Nipype可以轻松完成。\n什么是NipypeNipype由多个组件构成，主要的组件有Interfaces,the WorkflowEngine 和Execution Plugins:\n\n            \n        \n    \n            \n    Nipype构成    \n    \n\n \n\n\nInterface: 相关软件的接口，可以是一个函数\n\nNode&#x2F;MapNode: 把一个接口打包成节点，在Workflow中使用。\n\nWorkflow: 一个表示工作流程的图，一个Workflow下面有很多节点。\n\nPlugin: 用来展示Workflow是如何工作的\n\n\nDockerDocker是一个开源项目，用来在容器中自动部署应用。（Docker的使用和学习令写，在这只简单介绍）这个容器可以打包运行Nipype所需的软件和完整的文件系统：代码，系统工具，软件库，比如 Python, FSL, AFNI, SPM, FreeSurfer, ANTs。这保证了可移植性，在不同环境中都可以运行。\nNipype官方教程所使用的  miykael&#x2F;nipype_tutorial镜像，建立了一个Linux环境和一系列所需软件包。同样的我们可以创建自己的docker镜像处理自己的数据。（之后再学用 Neurodocker创建）\nDocker for windows我是用的是Windows 10去docker官网下载 Docker for windows\n下载完成后使用终端测试是否安装正确：\ndocker --version\n\n            \n\n            \n\n\n\ndocker run hello-world\n\n            \n        \n    \n            \n        \n    \n\n\n\n这里提醒一下，Docker默认下载到C盘无法修改，Docker拉取的镜像也是在C盘，所以需要C盘空间很大，我试了修改镜像的位置，行不通，所以只能扩充C盘的大小了。\n拉取镜像确认Docker安装没有问题后，就可以开始拉取镜像了。\ndocker pull miykael/nipype_tutorial:latest\n\n由于是从国外的镜像网站拉取镜像，速度很慢。解决方法是使用国内镜像加速。\n找到C:\\Program Files\\Docker\\Docker\\resources文件夹下的windows-daemon-options.json文件\n&quot;registry-mirrors&quot;: [&quot;https://m3e4jmm0.mirror.aliyuncs.com&quot;],\n\n把镜像地址改为阿里云镜像。\n运行镜像简单运行miykael&#x2F;nipype_tutorial，使用命令：\ndocker run -it --rm -p 8888:8888 miykael/nipype_tutorial jupyter notebook\n\n如果想要使用本地的dataset，使用命令：\ndocker run -it --rm -v /path/to/nipype_tutorial/:/home/neuro/nipype_tutorial -v /path/to/data/:/data -v /path/to/output/:/output -p 8888:8888 miykael/nipype_tutorial jupyter notebook\n\n\n-it 表示打开一个可以交互的容器\n\n–rm 在关闭Docker后容器自动移除\n\n-p 表示使用哪个端口\n\n-v 表示把本地的文件加载到容器中去 &#x2F;path&#x2F;to&#x2F;nipype_tutorial&#x2F; 表示本地nipype_tutorial路径，：表示加载到容器中的路径。\n\nmiykael&#x2F;nipype_tutorial 表示运行哪个镜像\n\njupyter notebook 在容器中打开jupyter\n\n\n关闭容器在终端使用ctrl-c可以关闭容器\n列出所有imagedocker images\n\n删除镜像docker rmi -f 7d9495d03763\n\n后面的数字为镜像ID\n提取和加载镜像如果想使用U盘保存镜像，使用命令：\n# Export docker image miykael/nipype_tutorial\ndocker save -o nipype_tutorial.tar miykael/nipype_tutorial\n\n# Import docker image on another PC\ndocker load --input nipype_tutorial.tar\n\n数据保存格式这个教程的数据保存结构是根据 Brain Imaging Data Structure (BIDS).\n这个格式结构清晰，并且易于共享。\n            \n        \n    \n            \n        \n    \n\n \n\n\n参考nipype官方教程 Nipype tutorial\n","categories":["python"],"tags":["神经影像"]},{"title":"Nipype（三）:Quickstart","url":"/2023/07/24/Nipype%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AQuickstart/","content":"Nipype Quickstart首先需要Import所需要的函数和包\nimport os \nfrom os.path import abspath\n\nfrom nipype import Workflow, Node, MapNode, Function\nfrom nipype.interfaces.fsl import BET, IsotropicSmooth, ApplyMask #fsl的接口函数\n\nfrom nilearn.plotting import plot_anat #画图\n%matplotlib inline #在Jupyter Notebook中画图时直接嵌入Notebook单元格中\nimport matplotlib.pyplot as plt\n\nInterfaces接口是Nipype的核心。这些接口是python接口可以通过这些接口访问外部软件包，这些软件包大多不是用python写的。（比如FSL,SPM和FreeSurfer）\n使用FSL中的bet()函数\n# will use a T1w from ds000114 dataset\n\n# input_file是BET()函数的输入参数，为数据集的路径\ninput_file =  abspath(&quot;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&quot;)\n# BET()实例化\nbet = BET()\n\nbet.inputs.in_file = input_file\n# 输出为输出路径\nbet.inputs.out_file = &quot;/output/T1w_nipype_bet.nii.gz&quot;\nres = bet.run()\n\n画出输出图像\nplot_anat(&#39;/output/T1w_nipype_bet.nii.gz&#39;, \n      display_mode=&#39;ortho&#39;, dim=-1, draw_cross=False, annotate=False);\n\n\n使用help指令可以看接口函数的使用方法\nBET.help()\n\nWraps the executable command ``bet``.\n\nFSL BET wrapper for skull stripping\n\nFor complete details, see the `BET Documentation.\n&lt;https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/BET/UserGuide&gt;`_\n\nExamples\n--------\n&gt;&gt;&gt; from nipype.interfaces import fsl\n&gt;&gt;&gt; btr = fsl.BET()\n&gt;&gt;&gt; btr.inputs.in_file = &#39;structural.nii&#39;\n&gt;&gt;&gt; btr.inputs.frac = 0.7\n&gt;&gt;&gt; btr.inputs.out_file = &#39;brain_anat.nii&#39;\n&gt;&gt;&gt; btr.cmdline\n&#39;bet structural.nii brain_anat.nii -f 0.70&#39;\n&gt;&gt;&gt; res = btr.run() # doctest: +SKIP\n\nInputs::\n\n        [Mandatory]\n        in_file: (a pathlike object or string representing an existing file)\n                input file to skull strip\n                argument: ``%s``, position: 0\n\n        [Optional]\n        out_file: (a pathlike object or string representing a file)\n                name of output skull stripped image\n                argument: ``%s``, position: 1\n        outline: (a boolean)\n                create surface outline image\n                argument: ``-o``\n        mask: (a boolean)\n                create binary mask image\n                argument: ``-m``\n        skull: (a boolean)\n                create skull image\n                argument: ``-s``\n        no_output: (a boolean)\n                Don&#39;t generate segmented output\n                argument: ``-n``\n        frac: (a float)\n                fractional intensity threshold\n                argument: ``-f %.2f``\n        vertical_gradient: (a float)\n                vertical gradient in fractional intensity threshold (-1, 1)\n                argument: ``-g %.2f``\n        radius: (an integer)\n                head radius\n                argument: ``-r %d``\n        center: (a list of at most 3 items which are an integer)\n                center of gravity in voxels\n                argument: ``-c %s``\n        threshold: (a boolean)\n                apply thresholding to segmented brain image and mask\n                argument: ``-t``\n        mesh: (a boolean)\n                generate a vtk mesh brain surface\n                argument: ``-e``\n        robust: (a boolean)\n                robust brain centre estimation (iterates BET several times)\n                argument: ``-R``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        padding: (a boolean)\n                improve BET if FOV is very small in Z (by temporarily padding end\n                slices)\n                argument: ``-Z``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        remove_eyes: (a boolean)\n                eye &amp; optic nerve cleanup (can be useful in SIENA)\n                argument: ``-S``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        surfaces: (a boolean)\n                run bet2 and then betsurf to get additional skull and scalp surfaces\n                (includes registrations)\n                argument: ``-A``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        t2_guided: (a pathlike object or string representing a file)\n                as with creating surfaces, when also feeding in non-brain-extracted\n                T2 (includes registrations)\n                argument: ``-A2 %s``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        functional: (a boolean)\n                apply to 4D fMRI data\n                argument: ``-F``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        reduce_bias: (a boolean)\n                bias field and neck cleanup\n                argument: ``-B``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        output_type: (&#39;NIFTI&#39; or &#39;NIFTI_PAIR&#39; or &#39;NIFTI_GZ&#39; or\n                &#39;NIFTI_PAIR_GZ&#39;)\n                FSL output type\n        args: (a string)\n                Additional parameters to the command\n                argument: ``%s``\n        environ: (a dictionary with keys which are a bytes or None or a value\n                of class &#39;str&#39; and with values which are a bytes or None or a\n                value of class &#39;str&#39;, nipype default value: &#123;&#125;)\n                Environment variables\n\nOutputs::\n\n        out_file: (a pathlike object or string representing a file)\n                path/name of skullstripped file (if generated)\n        mask_file: (a pathlike object or string representing a file)\n                path/name of binary brain mask (if generated)\n        outline_file: (a pathlike object or string representing a file)\n                path/name of outline file (if generated)\n        meshfile: (a pathlike object or string representing a file)\n                path/name of vtk mesh file (if generated)\n        inskull_mask_file: (a pathlike object or string representing a file)\n                path/name of inskull mask (if generated)\n        inskull_mesh_file: (a pathlike object or string representing a file)\n                path/name of inskull mesh outline (if generated)\n        outskull_mask_file: (a pathlike object or string representing a file)\n                path/name of outskull mask (if generated)\n        outskull_mesh_file: (a pathlike object or string representing a file)\n                path/name of outskull mesh outline (if generated)\n        outskin_mask_file: (a pathlike object or string representing a file)\n                path/name of outskin mask (if generated)\n        outskin_mesh_file: (a pathlike object or string representing a file)\n                path/name of outskin mesh outline (if generated)\n        skull_mask_file: (a pathlike object or string representing a file)\n                path/name of skull mask (if generated)\n        skull_file: (a pathlike object or string representing a file)\n                path/name of skull file (if generated)\n\nReferences:\n-----------\nBibTeX(&#39;@article&#123;JenkinsonBeckmannBehrensWoolrichSmith2012,author=&#123;M. Jenkinson, C.F. Beckmann, T.E. Behrens, M.W. Woolrich, and S.M. Smith&#125;,title=&#123;FSL&#125;,journal=&#123;NeuroImage&#125;,volume=&#123;62&#125;,pages=&#123;782-790&#125;,year=&#123;2012&#125;,&#125;&#39;, key=&#39;JenkinsonBeckmannBehrensWoolrichSmith2012&#39;)\n\n​使用FSL中的光滑函数，高斯核为4mm\nsmoothing = IsotropicSmooth()\nsmoothing.inputs.in_file = &quot;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&quot;\nsmoothing.inputs.fwhm = 4\nsmoothing.inputs.out_file = &quot;/output/T1w_nipype_smooth.nii.gz&quot;\nsmoothing.run()\n# plotting the output\nplot_anat(&#39;/output/T1w_nipype_smooth.nii.gz&#39;, \n      display_mode=&#39;ortho&#39;, dim=-1, draw_cross=False, annotate=False);\n\n\nNodes and Workflows接口是Nipype的核心，在使用不同包的接口或者同一个包的不同接口时，需要把接口放在一个Node中，并且多个Node构成一个workflow。\n在Nipype中，一个节点是执行某个函数的物体，这个函数可以是Nipype中的任意接口函数或者是user自己创建的函数，又或者是外部的一个脚本中的。每个节点由名称，接口和最少一个输入和输出构成。\n一旦使用了多个节点，就可以使用workflow连接每一个节点，并且生成一个有向连接图。\n首先创建去头骨节点\n# Create Node\nbet_node = Node(BET(), name=&#39;bet&#39;)\n# Specify node inputs\nbet_node.inputs.in_file = input_file\nbet_node.inputs.mask = True\n\n# bet node can be also defined this way:\n#bet_node = Node(BET(in_file=input_file, mask=True), name=&#39;bet_node&#39;)\n\nmask为True表示生成一个去头骨的掩膜图像。\n接下来创建一个光滑节点，使用IsotropicSmooth函数\nsmooth_node = Node(IsotropicSmooth(in_file=input_file, fwhm=4), name=&quot;smooth&quot;)\n\n接下来使用掩膜函数把光滑后的图像掩膜。\nmask_node = Node(ApplyMask(), name=&quot;mask&quot;)\n\n使用help指令后可以看到，ApplyMask（）函数有两个必须传入的参数。\n\nmask_file :掩膜图像位置\n\nin_file ：被掩膜的图像\n\n\n所有节点都创建完毕，接下来创建一个workflow把他们连接起来。首先连接bet_node的输出和mask_node的输入\n# Initiation of a workflow\nwf = Workflow(name=&quot;smoothflow&quot;, base_dir=&quot;/output/working_dir&quot;)\n\nwf.connect(bet_node, &quot;mask_file&quot;, mask_node, &quot;mask_file&quot;)\n\n接着连接smooth_node的out_file和mask_node的in_file把这个workflow可视化出来\nwf.connect(smooth_node,&quot;out_file&quot;,mask_node, &quot;in_file&quot;)\n\n\nwf.write_graph(&quot;workflow_graph.dot&quot;)\nImage(filename=&quot;/output/working_dir/smoothflow/workflow_graph.png&quot;)\n\n\n或者画出细节图\nwf.write_graph(graph2use=&#39;flat&#39;)\n\nImage(filename=&quot;/output/working_dir/smoothflow/graph_detailed.png&quot;)\n\n\n接下来开始运行workflow\nres = wf.run()\n\n列出结果\nlist(res.nodes)[0].result.outputs\n\n\n查看生成的文件夹\n! tree -L 3 /output/working_dir/smoothflow/\n\n也可以将生成图片画出\nimport numpy as np\nimport nibabel as nb\n#import matplotlib.pyplot as plt\n\n# Let&#39;s create a short helper function to plot 3D NIfTI images\ndef plot_slice(fname):\n\n    # 加载图像\n    img = nb.load(fname)    \n    data = img.get_data()\n\n    # 因为是3D图像，所以选择Z轴中间切开\n    cut = int(data.shape[-1]/2) + 10   \n\n    # Plot the data\n    plt.imshow(np.rot90(data[..., cut]), cmap=&quot;gray&quot;)\n    plt.gca().set_axis_off()  # 关闭坐标轴\n\nf = plt.figure(figsize=(12, 4))\nfor i, img in enumerate([&quot;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&quot;,\n                        &quot;/output/working_dir/smoothflow/smooth/sub-01_ses-test_T1w_smooth.nii.gz&quot;,\n                        &quot;/output/working_dir/smoothflow/bet/sub-01_ses-test_T1w_brain_mask.nii.gz&quot;,\n                        &quot;/output/working_dir/smoothflow/mask/sub-01_ses-test_T1w_smooth_masked.nii.gz&quot;]):\n    f.add_subplot(1, 4, i + 1)\n    plot_slice(img)\n\n\nIterables在做数据处理的时候，经常一个预处理跑多个受试或者做一些组差异比较。避免重复写脚本，Nipype有一个处理插件，叫做iterables\n假如我们有一个workflow上面有两个node，node（A）是去头颅函数，node(B)是光滑函数，现在我们很好奇不同大小的高斯核对结果的影响。因此，我们设置FWHM的值为4mm,8mm和16mm。\n\nsmooth_node_it = Node(IsotropicSmooth(in_file=input_file), name=&quot;smooth&quot;)\nsmooth_node_it.iterables = (&quot;fwhm&quot;, [4, 8, 16])\n\n重新定义bet和mask node\nbet_node_it = Node(BET(in_file=input_file, mask=True), name=&#39;bet_node&#39;)\nmask_node_it = Node(ApplyMask(), name=&quot;mask&quot;)\n\n新建一个新的workflow\nwf_it = Workflow(name=&quot;smoothflow_it&quot;, base_dir=&quot;/output/working_dir&quot;)\nwf_it.connect(bet_node_it, &quot;mask_file&quot;, mask_node_it, &quot;mask_file&quot;)\nwf_it.connect(smooth_node_it, &quot;out_file&quot;, mask_node_it, &quot;in_file&quot;)\n\n运行workflow\nres_it = wf_it.run()\n\n看生成的文件    ! tree -L 3 &#x2F;output&#x2F;working_dir&#x2F;smoothflow_it&#x2F;\n/output/working_dir/smoothflow_it/\n├── bet_node\n│   ├── _0x059f982d380f7943757debfb10a5502d.json\n│   ├── command.txt\n│   ├── _inputs.pklz\n│   ├── _node.pklz\n│   ├── _report\n│   │   └── report.rst\n│   ├── result_bet_node.pklz\n│   └── sub-01_ses-test_T1w_brain_mask.nii.gz\n├── d3.js\n├── _fwhm_16\n│   ├── mask\n│   │   ├── _0xd72ea2e7b364b1159092a12f3d3ca28c.json\n│   │   ├── command.txt\n│   │   ├── _inputs.pklz\n│   │   ├── _node.pklz\n│   │   ├── _report\n│   │   ├── result_mask.pklz\n│   │   └── sub-01_ses-test_T1w_smooth_masked.nii.gz\n│   └── smooth\n│       ├── _0xc478d2c0a35763bb8cc0ba0be7c7c4a3.json\n│       ├── command.txt\n│       ├── _inputs.pklz\n│       ├── _node.pklz\n│       ├── _report\n│       ├── result_smooth.pklz\n│       └── sub-01_ses-test_T1w_smooth.nii.gz\n├── _fwhm_4\n│   ├── mask\n│   │   ├── _0x020ff51c3dd2cc1c441bbc71b6bb82fd.json\n│   │   ├── command.txt\n│   │   ├── _inputs.pklz\n│   │   ├── _node.pklz\n│   │   ├── _report\n│   │   ├── result_mask.pklz\n│   │   └── sub-01_ses-test_T1w_smooth_masked.nii.gz\n│   └── smooth\n│       ├── _0x7284dba78093a51ae87024eac1bec00f.json\n│       ├── command.txt\n│       ├── _inputs.pklz\n│       ├── _node.pklz\n│       ├── _report\n│       ├── result_smooth.pklz\n│       └── sub-01_ses-test_T1w_smooth.nii.gz\n├── _fwhm_8\n│   ├── mask\n│   │   ├── _0x3ac21b3bbb4f9177e3221ac52b59a349.json\n│   │   ├── command.txt\n│   │   ├── _inputs.pklz\n│   │   ├── _node.pklz\n│   │   ├── _report\n│   │   ├── result_mask.pklz\n│   │   └── sub-01_ses-test_T1w_smooth_masked.nii.gz\n│   └── smooth\n│       ├── _0x8a60534f7916842abe5b185fdf7996d9.json\n│       ├── command.txt\n│       ├── _inputs.pklz\n│       ├── _node.pklz\n│       ├── _report\n│       ├── result_smooth.pklz\n│       └── sub-01_ses-test_T1w_smooth.nii.gz\n├── graph1.json\n├── graph.json\n└── index.html\n\n17 directories, 47 files\n\nMapnode如果想使输入为多个输入参数的节点的输出都为下一个节点的输入，那么就需要使用MapNode。MapNode与普通的Node很像，它的输入可以是一个列表，最终也生成一个输出列表。\n比如你有许多文件，他们都会经过相同的node处理和不同的Node，这时MapNode可以发挥作用。\n比如上图，A节点处理后得到一个列表的输出，而这些输出都会经过B节点处理，最后把B得到的结果送入C节点。\n简单例子：\ndef square_func(x):\nreturn x ** 2\n\n# 这里使用nipype的Function接口，把用户自己创建的函数作为一个接口\nsquare = Function(input_names=[&quot;x&quot;], output_names=[&quot;f_x&quot;], function=square_func)\n\n如果把输入的值设置为一个列表\nsquare_node = Node(square, name=&quot;square&quot;)\nsquare_node.inputs.x = [2, 4]\nres = square_node.run()\nres.outputs\n\n输出会报错，因为square_func不能接收一个列表。\n这时我们使用MapNode即可解决！\nsquare_mapnode = MapNode(square, name=&quot;square&quot;, iterfield=[&quot;x&quot;])\nsquare_mapnode.inputs.x = [2, 4]\nres = square_mapnode.run()\nres.outputs\n\n\n参考nipype官方教程 Nipype Quickstart\n","categories":["python"],"tags":["神经影像"]},{"title":"Nipype（二）：showcase","url":"/2023/07/24/Nipype%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ashowcase/","content":"Nipype Showcase使用简单的fMRI预处理流程来展示Workflow：\n\nslice time correction\nmotion correction\nsmoothing\n\n准备预处理workflow首先导入Nipype包中的Node和Workflow\nfrom nipype import Node, Workflow\n\n接着导入预处理需要的interfaces\nfrom nipype.interfaces.fsl import SliceTimer, MCFLIRT, Smooth\n\n接着把这三个接口接入Node并且定义输入\n# 初始化slicetime节点\nslicetimer = Node(SliceTimer(index_dir=False,\n                            interleaved=True,\n                            time_repetition=2.5),\n                  name=&quot;slicetimer&quot;)\n\n# 初始化运动矫正节点\nmcflirt = Node(MCFLIRT(mean_vol=True,\n                      save_plots=True),\n              name=&quot;mcflirt&quot;)\n# 初始化光滑节点\nsmooth = Node(Smooth(fwhm=4), name=&quot;smooth&quot;)\n\n接下来就可以创建一个workflow，把这三个节点连接起来\n# 创建预处理workflow\npreproc01 = Workflow(name=&#39;preproc01&#39;, base_dir=&#39;.&#39;)\n\n# 连接节点到workflow中\npreproc01.connect([(slicetimer, mcflirt, [(&#39;slice_time_corrected_file&#39;, &#39;in_file&#39;)]),\n               (mcflirt, smooth, [(&#39;out_file&#39;, &#39;in_file&#39;)])])\n\n可以把workflow可视化\n# 生成可视化图片\npreproc01.write_graph(graph2use=&#39;orig&#39;)\n\n# 导入Ipython的图像包\nfrom IPython.display import Image\nImage(filename=&quot;preproc01/graph_detailed.png&quot;)\n\n            \n        \n    \n            \n    结果\n    \n\n \n在一个功能图像上运行workflow创建过一个workflow后，开始在功能像上运行。首先要确定数据文件的路径。\nslicetimer.inputs.in_file = &#39;/data/ds000114/sub-01/ses-test/func/sub-01_ses-test_task-fingerfootlips_bold.nii.gz&#39;\n\ndata文件夹下有所需要的数据。\n使用Nipype的并行处理功能，观察处理时间\n%time preproc01.run(&#39;MultiProc&#39;, plugin_args=&#123;&#39;n_procs&#39;: 5&#125;)\n\n            \n        \n    \n            \n    \n    \n\n\n            \n        \n    \n            \n    结果\n    \n\n\n上图 输出了整个Workflow的工作流程，最后可以看到整个处理花费大概2min。\n结果检查一下输出文件夹有什么。\n!tree preproc01 -I &#39;*js|*json|*pklz|_report|*.dot|*html&#39;\n\n            \n        \n    \n            \n    \n    \n\n\n\n修改参数重新运行smooth.inputs.fwhm = 2\n%time preproc01.run(&#39;MultiProc&#39;, plugin_args=&#123;&#39;n_procs&#39;: 5&#125;)\n\n  \n可看到时间仅用14秒，因为整个workflow不会重新运行一遍，只把更改参数的Node运行，在这里就是把smooth重新运行。\n并行处理preproc1预处理workflow使用了大概两分钟，如果我要处理5张功能像图片，他会花费10分钟。\n首先我们复制5个workflow\n# First, let&#39;s copy/clone &#39;preproc01&#39;\npreproc02 = preproc01.clone(&#39;preproc02&#39;)\npreproc03 = preproc01.clone(&#39;preproc03&#39;)\npreproc04 = preproc01.clone(&#39;preproc04&#39;)\npreproc05 = preproc01.clone(&#39;preproc05&#39;)\n\n我们想要并行处理，需要把他们整合在一个workflow中。\nmetaflow = Workflow(name=&#39;metaflow&#39;, base_dir=&#39;.&#39;)\n# Now we can add the five preproc workflows to the bigger metaflow\nmetaflow.add_nodes([preproc01, preproc02, preproc03,\n                preproc04, preproc05])\n\n可视化看一下整个workflow\n# As before, let&#39;s write the graph of the workflow\nmetaflow.write_graph(graph2use=&#39;flat&#39;)\n\nImage(filename=&quot;metaflow/graph_detailed.png&quot;)\n\n\n使用并行处理\n%time metaflow.run(&#39;MultiProc&#39;, plugin_args=&#123;&#39;n_procs&#39;: 5&#125;)\n\nlog信息此处省略\n可以看到总共用时2min，这就是使用Nipype的原因。\nmetaflow的结果!tree metaflow -I &#39;*js|*json|*pklz|_report|*.dot|*html&#39;\n\n\n参考nipype官方教程 Nipype Showcase\n","categories":["python"],"tags":["神经影像"]},{"title":"Hello World","url":"/2025/02/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Nipype（四）：Interfaces","url":"/2023/08/03/Nipype%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AInterfaces/","content":"Interfaces在之前已经学习过Interfaces的基本概念和操作，这里简单介绍一下。Interfaces就是其他软件包的python函数接口，想要使用其他软件的（例如FSL,SPM或者FreeSurfer）函数，就需要此函数的python接口和安装相应的软件包。\nBET函数原始使用方法先看一下我们需要去头骨的原始图像。\nfrom nilearn.plotting import plot_anat\n%matplotlib inline\nplot_anat(&#39;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&#39;, title=&#39;original&#39;,\n      display_mode=&#39;ortho&#39;, dim=-1, draw_cross=False, annotate=False);\n\n\n使用BET函数命令行形式（即在FSL中原始使用方法）\nbet &lt;input&gt; &lt;output&gt;\n\n在ipython中则需要在前面加%%bash\n%%bash\n\nFILENAME=/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w\n\nbet $&#123;FILENAME&#125;.nii.gz /output/sub-01_ses-test_T1w_bet.nii.gz\n\n使用查看帮助信息\n!bet -h\n\nUsage:    bet &lt;input&gt; &lt;output&gt; [options]\n\nMain bet2 options:\n-o          generate brain surface outline overlaid onto original image\n-m          generate binary brain mask\n-s          generate approximate skull image\n-n          don&#39;t generate segmented brain image output\n-f &lt;f&gt;      fractional intensity threshold (0-&gt;1); default=0.5; smaller values give larger brain outline estimates\n-g &lt;g&gt;      vertical gradient in fractional intensity threshold (-1-&gt;1); default=0; positive values give larger brain outline at bottom, smaller at top\n-r &lt;r&gt;      head radius (mm not voxels); initial surface sphere is set to half of this\n-c &lt;x y z&gt;  centre-of-gravity (voxels not mm) of initial mesh surface.\n-t          apply thresholding to segmented brain image and mask\n-e          generates brain surface as mesh in .vtk format\n\nVariations on default bet2 functionality (mutually exclusive options):\n(default)   just run bet2\n-R          robust brain centre estimation (iterates BET several times)\n-S          eye &amp; optic nerve cleanup (can be useful in SIENA)\n-B          bias field &amp; neck cleanup (can be useful in SIENA)\n-Z          improve BET if FOV is very small in Z (by temporarily padding end slices)\n-F          apply to 4D FMRI data (uses -f 0.3 and dilates brain mask slightly)\n-A          run bet2 and then betsurf to get additional skull and scalp surfaces (includes registrations)\n-A2 &lt;T2&gt;    as with -A, when also feeding in non-brain-extracted T2 (includes registrations)\n\nMiscellaneous options:\n-v          verbose (switch on diagnostic messages)\n-h          display this help, then exits\n-d          debug (don&#39;t delete temporary intermediate images)\n\n使用命令行生成二进制掩膜文件。\n%%bash\n\nFILENAME=/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w\n\nbet $&#123;FILENAME&#125;.nii.gz /output/sub-01_ses-test_T1w_bet.nii.gz -m\n\n由此我们可知道python接口的函数实际上也是在命令行中输入需要的操作，不过使用的是python脚本形式。\nBET函数接口使用在之前有，这里简要介绍。\n# import BET函数\nfrom nipype.interfaces.fsl import BET\nskullstrip = BET() # 对象实例化\nskullstrip.inputs.in_file = &quot;/data/ds000114/sub-01/ses-test/anat/ sub-01_ses-test_T1w.nii.gz&quot; # 输入文件路径\nskullstrip.inputs.out_file = &quot;/output/T1w_nipype_bet.nii.gz&quot; # 输出文件路径\nres = skullstrip.run() # 运行\n\n\n我们来看一下输出的命令行\nprint(skullstrip.cmdline)\n\nbet /data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz /output/T1w_nipype_bet.nii.gz\n\n与我们正常使用时的一样。\nInterface errors使用run方法运行接口时，对于FSL、Freesurfer和其他程序，会使系统输入上述命令行命令。对于MATLAB的程序如SPM，它会生成一个.m文件，然后在matlab环境下运行这个.m文件。\n如果我们不给函数接口一个必要的输入参数它就会报错\nskullstrip2 = BET()\ntry:\n    skullstrip2.run()\nexcept(ValueError) as err:\n    print(&quot;ValueError:&quot;, err)\nelse:\n    raise\n\nValueError: BET requires a value for input &#39;in_file&#39;. For a list of required inputs, see BET.help()\n\nBET函数没有输入文件的路径\n又或者输入类型搞错，比如BET（）函数想要生成掩膜文件，你却把淹没文件的名字输入上去了 XD。\ntry:\nskullstrip.inputs.mask = &quot;mask_file.nii&quot;\nexcept(Exception) as err:\n    if &quot;TraitError&quot; in str(err.__class__):\n        print(&quot;TraitError:&quot;, err)\n    else:\n        raise\nelse:\n    raise\nTraitError: The &#39;mask&#39; trait of a BETInputSpec instance must be a boolean, but a value of &#39;mask_file.nii&#39; &lt;class &#39;str&#39;&gt; was specified.\n\n在报错的时候根据报错信息修改程序\n参考nipype_tutorial Interface\n","categories":["python"],"tags":["神经影像"]},{"title":"告别","url":"/2022/05/06/%E5%91%8A%E5%88%AB/","content":"毕业大学四年过去了，回顾一下这四年还挺美好的，虽然没社交没参加活动啥的，感觉那都是虚的，真正要提高的还是自己的做工程的能力和精神。最害怕的是转专业后也沦为做题机器了，幸好没有，做了几个还算一般的项目吧。最后一年我也不知道为啥摆烂了，因为疫情？肯定不是，都他妈的借口，归根到底还是自己这个人就这比样，稍微放松一下就回归自我了。电赛复盘一下，确实是自己能力不足。还是自己太菜了，还得过段时间再继续吧。M-watch项目暂停了，以及EAGLE、3D结构方面、模电、电子电路反正一堆要学的都得暂停了，真他妈的烦。\n\n之后打算还是考研吧，本来想着先工作两年攒一下经验，现在看来当时有点天真以为有项目经验就好找工作，哈哈哈，在学历面前确实全都是屁不值一提。总而言之吧，决定考就认真考了，今天正好也给毕设肝完了，没理由碰代码了，不知道半年不碰会变菜不会哈哈哈哈。\n咱也不需要啥动力，顶不住的时候想想18年就好了。\n就这样吧，希望下次归来时，我可以追梦。\n","categories":["杂谈"]},{"title":"核磁共振原理（一）","url":"/2023/05/05/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/","content":"核磁共振仪的硬件组成  核磁共振仪主要由主磁体、梯度系统、射频系统、计算机系统和其他辅助设备。  \n \n主磁体  主磁体分为永磁型和电磁型，永磁性产生的磁场强度通常比电磁型小，电磁型可以产生很大的磁场强度。  \n\n\n主要参数\n磁场强度：磁场强度的单位为T（特斯拉），G（高斯），定义1G为，距离通过5A电流的线圈5cm处的磁场强度。1T&#x3D;10000G。一般把0.5T以下的MRI仪称为低场机，0.51.0T为中场机，1.02.0T为高场机，大于2.0T的称为超高场机（3.0T）。高磁场强度的优点：1.提高质子的磁化率，增加图像的信噪比；2.缩短MRI成像的时间；3.增加血氧饱和度依赖效应（BOLD），使脑功能成像的信号变化更为明显。\n\n\n\n\n主磁场均匀度：磁场均匀性是指在一定的容积范围内磁场强度的均一性，也即单位面积内通过的磁力线数目的一致性。\n\n\n\n\n主磁场的稳定性：实际上是指主磁场强度及其均匀性的变化，也成为磁场漂移。\n\n\n\n梯度系统  梯度系统是MRI仪最重要的硬件之一，由梯度线圈、梯度放大器、数模转换器、梯度控制器、梯度冷却装置构成，梯度线圈安装于主磁体内。梯度系统的主要作用：1、进行MRI信号的空间定位编码。2、产生梯度回波信号。\n \n磁共振坐标系  坐标系主要由x、y、z构成，Z轴是人体长轴方向正方向为头部，X轴正方向为人体左侧，Y轴正方向是人体解剖位置前侧。\n\n            \n        \n    \n            \n    磁共振系统的坐标系    \n    \n\n  \n\n梯度磁场的产生  以Z轴为例，梯度线圈是特殊绕制的线圈，在头部和脚部。线圈通电后，电流流过头部线圈产生与主磁场方向相同的磁场，两个磁场强度叠加，头部磁场强度增高。脚步磁场方向相反，磁场减弱。从而形成沿着Z轴分布，头侧高足侧低的梯度磁场，梯度线圈中心位置的磁场强度保持不变。\n\n            \n        \n    \n            \n    梯度磁场    \n    \n\n  \n\n射频系统   射频系统由射频发生器、射频放大器和射频线圈构成。射频线圈有发射线圈和接收线圈。发射线圈发出射频脉冲（无线电波）激发人体内的质子发生共振（后面补充），接收线圈接收人体发出的MR信号。\n \n计算机系统\n  计算机系统控制着MRI仪的射频脉冲激发、信号采集、数据运算和图像显示等功能。\n\n\n            \n        \n    \n            \n    核磁共振控制系统结构    \n    \n\n  \n\n\nSCP(scan control processor) 扫描控制系统：产生序列脉冲的全部硬件开关信号，控制全部硬件（射频，梯度，采样，重构）开始和结束时间点。\nTRF（trigger and rotational function board）：定位引起的坐标旋转变换，对应梯度的控制，以及对SRF的触发控制。\nSRF（sequence related function board）:负责序列中梯度系统涡流校正补偿对梯度的触发控制。\nIRF（interface relate function board）射频控制器：负责主时钟的同步，控制发射射频控制器。\nDRF（digital receiver filter）数字滤波器：对IRF发送来的采集数据，进行频率解调，去除掉载波频率，同时进行一定的降噪处理。\nAPS（acquisition processing subsystem）:根据主机序列所对应的扫描参数，负责对采集的数据按K空间顺序、层面关系及平均次数排序组合，并把排列好的K空间发送给重建处理器。\nReflex AP 重建处理器：专门负责对原始数据进行傅里叶变换。\n\n\n这一部分简单介绍核磁共振仪器的硬件组成，之后笔记记录学习核磁共振物理学原理。\n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（三）","url":"/2023/05/09/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/","content":"磁共振加权成像加权是“突出重点”的意思，组织的多方面特性均可能对其磁共振信号的强弱有影响，我们可以通过成像脉冲序列的选择及成像参数的调整，使MR图像主要反映组织某方面特性，而尽量抑制组织的其他特性对MR信号强度的影响。\nTI加权成像（T1-weighted imaging,T1WI）是指图像中组织信号强度的高低主要反映的是组织的纵向弛豫差别。\nT2加权成像（T2-weighted imaging,T2WI）重点突出的是不同组织之间的横向弛豫差别。\n质子密度加权成像（PDWI）则主要反映单位体积的不同组织之间的质子含量差别。\n质子密度加权成像质子密度加权成像主要反映单位体积不同组织间质子含量的差别。以甲乙两种组织为例，甲组织质子含量高于乙质子，90°射频脉冲激发后甲组织产生的旋转宏观横向磁化矢量就大于乙组织，这时马上检测MR信号，甲组织产生的MR信号将高于乙组织。\n            \n        \n    \n            \n    质子密度加权成像    \n    \n\n  \n\nT2加权成像与T2*加权成像T2WI主要反映不同组织间横向弛豫的差别，必须用聚焦脉冲采集自旋回波方可得到组织真正的T2弛豫信息。\n同样以甲乙组织为例，假如质子密度一样，甲乙两种组织产生的宏观纵向磁化矢量大小相同，一个射频脉冲如90°脉冲激发后，两种组织产生的旋转宏观横向磁化矢量大小也相同，这时不马上检测MR信号；90°脉冲关闭后，甲组织横向弛豫比乙组织慢，到一定时刻，甲组织衰减掉的宏观横向磁化矢量少于乙组织，其残留的宏观横向磁化矢量将大于乙组织，这时再检测MR信号，甲组织的MR信号强度将高于乙组织，这样就实现了T2WI。\n            \n        \n    \n            \n    T2WI加权成像原理    \n    \n\n  \n\n前面所述的 T2WI的回波信号必须采用聚焦脉冲来获得，如果不采用聚焦脉冲而仅采用读出梯度场的切换获取梯度回波信号，则磁共振信号反映的不是真正的 T2 弛豫信息而是T2*弛豫信息，因此得到的不是T2WI而是T2*WI。\nT1加权成像T1WI主要反映组织纵向弛豫的差别我们还是以甲、乙两种组织为例，假设这两种组织质子密度相同,但甲组织的纵向弛豫比乙组织快(即甲组织的 T1值短于乙组织)。进入主磁场后由于质子密度一样,甲乙两种组织产生的纵向磁化矢量大小相同，一个射频脉冲如 90°脉冲后产生的宏观横向磁化矢量的大小也相同,我们先不去理会这种宏观横向磁化矢量,也不马上检测 MR 信号。射频脉冲关闭后,甲乙两种组织将发生纵向驰豫，由于甲组织的纵向弛豫比乙组织快,过一定时间甲组织纵向磁化矢量比乙组织大。这时再产生一个90°脉冲，第二个 90°脉冲后,甲、乙两组织的宏观纵向磁化矢量将发生偏转，产生宏观横向磁化矢量，因为这时甲组织的纵向磁化矢量大于乙组织,其产生的宏观横向磁化矢量将大于乙组织,这时马上检测 MR信号,甲组织产生的 MR 信号将高于乙组织。\n\n            \n        \n    \n            \n    T1WI加权成像原理    \n    \n\n  \n在T1WI上,组织的T1值越小,其MR信号强度越大.\n\n\n参考《磁共振成像技术指南》—— 杨正汉\n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（二）","url":"/2023/05/06/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"核磁共振物理学原理\n原子结构\n原子由原子核和围绕原子核的电子构成，原子核中有中子和质子，中子不带电，质子带正电。\n自旋和核磁\n原子核具有一定大小和质量，可以视作一个球体，所有磁性原子核都有一个特性，就是总以一定的频率绕着自己的轴进行高速旋转，原子核这一特性称为自旋（spin）。由于原子核表面带有正电荷，所以磁性原子核的自旋就形成电流环路，从而产生具有一定大小和方向的磁化矢量。\n            \n        \n    \n            \n    原子核的自旋    \n    \n\n  \n\n不是所有的原子核均能自旋产生核磁，原子核内中子和质子的数目决定了原子核是否为磁性原子核。磁性原子核需保证：中子数和质子数至少要有一个是奇数。\n \n人体中的磁性原子人体中常见的磁性原子核如下图\n\n            \n        \n    \n            \n    人体中常见的磁性原子核    \n    \n\n  \n\n一般用于人体磁共振成像的原子核为氢原子核。但是并不是所有的H质子都能产生MRI信号，常规MRI的信号主要来源于水分子中的氢质子，部分组织的信号也可来源于脂肪中的氢质子。\n\n人体组织的水分子可分为自由水和结合水。结合水是指蛋白质大分子周围水化层中的水分子。自由水是指未与蛋白质结合在一起，活动充分自由的水分子。蛋白质和结合水的T2值都很短，采集不到这些信号。因此对于不含脂肪的组织，其MRI信号的直接来源是自由水。\n\n进入主磁场后人体氢质子核磁状态发生变化\n人体中氢质子自旋将产生无数个小核磁，但是由于方向杂乱无章，因此在自然状态下无明显磁性。MRI仪器无法检测每个氢质子产生的小核磁，仅能探测宏观磁化矢量的变化。当人体进入主磁场后，质子自旋产生的小磁场与主磁场平行排列，平行同向者略多于平行反向者，相互抵消后组织中最后产生一个与主磁场方向一致的磁化矢量，称作宏观葱香磁化矢量。\n\n            \n        \n    \n            \n    进入人体后氢质子核磁状态改变    \n    \n\n  \n\n之所以会有一些核磁与主磁场同向平行还有一些核磁与主磁场反向平行，涉及量子力学，简单解释：两种核磁代表的质子能量差别，平行同向的质子处于低能级，因此受主磁场的束缚，其磁化矢量的方向与主磁场的方向一致；平行反向的质子处于高能级，能够对抗主磁场的作用，处于低能级的质子多于高能级，整体产生一个宏观纵向磁矢量。\n\n            \n        \n    \n            \n    处于不同能级的氢质子核磁状态不同    \n    \n\n  \n\n随着温度、主磁场强度的改变，低能级多于高能级的氢质子数也将改变。一般在MRI系统中，温度是相对稳定的，因此只考虑主磁场强度的影响，主磁场越强，低能级多于高能级的氢质子数越高。\n\n            \n        \n    \n            \n    温度和磁场强度对宏观磁化矢量的影响    \n    \n\n  \n\n进动进入主磁场后，无论处于高能级还是处于低能级的质子，其磁化矢量并非完全与主磁场方向平行，而总是与主磁场有一定的角度。除了自旋运动外，其小核磁还绕着主磁场轴进行旋转摆动，这种运动叫做进动（precession）。\n\n            \n        \n    \n            \n    进动    \n    \n\n  \n\n进动频率  \n进动频率又称Larmor频率，其计算公式为:\n\n\n\n其中为磁旋比，B为主磁场的场强，单位T。可以看出进动频率与磁场强度成正比。\n\n\n由于进动的存在，质子自旋产生的小磁场又可以分解成两个部分，即纵向磁化分矢量和横向磁化分矢量。纵向分磁化矢量由低能级和高能级质子共同决定，低能级质子数多于高能级，因此纵向分磁化矢量与主磁场方向相同。由于质子在进动，其横向磁化分矢量会以主磁场方向为轴，在XY平面内做旋转运动，因此其方向处于不断的动态变化中。而各个氢质子的横向磁化分量在圆周的不同位置中，横向磁化分量相互抵消，所以没有宏观横向磁化矢量。\n\n            \n        \n    \n            \n    纵向与横向磁化矢量    \n    \n\n  \n\n宏观横向磁化矢量的检测 \n检测原理是初中所学过的电磁感应现象，闭合线圈在磁场中做切割磁感线运动会产生感应电流。\n如上所说，质子进动产生了纵向宏观磁矢量而不产生横向磁矢量，而纵向宏观磁矢量不切割磁感线，无法产生感应电流。（之后解释）\n\n            \n        \n    \n            \n    宏观横向磁矢量切割磁感线产生感应电流    \n    \n\n  \n\n\n磁共振现象  \n物理学上，共振被定义为能量从一个震动着的物体传递到另一物体，而后者以前者相同的频率振动，共振的条件是频率相同。\n如果我们给处于主磁场人体组织一个射频脉冲，这个射频脉冲的频率与质子的进动频率相同，射频脉冲的能量将传递给处于低能级的质子，处于低能级的质子获得能量后将跃迁到高能级，这种现象为磁共振现象。\n\n            \n        \n    \n            \n    磁共振现象    \n    \n\n  \n\n\n从宏观上看，磁共振现象使宏观纵向磁化矢量发生偏转，偏转角度与射频脉冲的能量有关，能量越大偏转角度越大。射频脉冲能量由脉冲强度和持续时间有关。\n\n            \n        \n    \n            \n    施加偏转角度不同的脉冲    \n    \n\n  \n\n90°脉冲 \n90°脉冲即使纵向宏观磁矢量偏转90°产生横向宏观磁化矢量，这时横向宏观磁化矢量最大。\n90°脉冲作用：\n\n90°使低能级质子跃迁进入高能级，使得低能级质子数与高能级质子数相同，因此纵向磁化矢量抵消。\n\n使质子的横向磁化分矢量处于同一相位。\n\n\n\n\n90°脉冲激发后组织中所产生的横向宏观磁化矢量的大小与脉冲激发前的宏观纵向磁化矢量的大小有关，而宏观纵向磁化矢量的大小与组织中的质子含量成正比。组织质子密度越高，其宏观纵向磁化矢量越大，90°脉冲激发后产生的宏观横向磁化矢量越大，切割接收线圈产生的电信号越强，MR信号就越高。\n\n核磁弛豫90°射频脉冲激发后的瞬间，组织中没有宏观纵向磁化矢量，而产生了最大的宏观横向磁化矢量；当90°脉冲关闭，我们可以注意到组织中的宏观横向磁化矢量从最大逐渐缩小到完全衰减，而宏观纵向磁化矢量从零逐渐恢复直至最大。这个过程即为核磁弛豫。\n\n            \n        \n    \n            \n    \n    核磁弛豫    \n    \n\n  \n\n横向弛豫90°脉冲使原来相位不一致的质子群处于同相位进动，质子小磁场的横向磁化分矢量相互叠加，从而产生旋转的宏观横向磁化矢量。90°脉冲关闭后，宏观横向磁化矢量衰减的是由于同相位进动额质子群逐渐失去了相位的一致，其横向磁化分矢量的叠加作用逐渐减弱。\n导致质子群失相位的原因主要有两个：\n\n质子周围磁环境随机波动。\n\n主磁场的不均匀。\n\n\n这种衰减称为自由感应衰减（free induction decay,FID）,也称T2*弛豫。\n180°脉冲可以消除主磁场不均匀造成的影响（之后解释），产生真正的T2弛豫，T2弛豫的能量传递发生于质子群内部，即质子与质子之间，因此T2弛豫也称自旋-自旋弛豫。\n\n            \n        \n    \n            \n    FID横向弛豫    \n    \n\n  \n\n一般用T2值来描述组织横向弛豫的快慢。从横向磁化矢量达到最大值为起点，以T2弛豫造成的横向磁化矢量衰减到最大值的37%为终点，起点与终点之间的时间间隔即为该组织的T2值。不同组织的T2值也不同，因此可以用T2加权成像（T2-weighted imaging,T2WI）方能区分不同的解剖结构，并能区分正常组织与病变组织。\n\n            \n        \n    \n            \n    组织T2    \n    \n\n  \n\n纵向弛豫\n当射频脉冲关闭后，在主磁场的作用下组织中的宏观纵向磁化矢量将逐渐恢复到激发前的状态即平衡状态，这一过程称为纵向弛豫，即T1弛豫。\n以90°脉冲为例，当脉冲关闭后，纵向磁化矢量将从零开始逐渐恢复至平衡状态。一般用T1值来描述组织的纵向弛豫的快慢。以90°脉冲关闭后，宏观纵向磁化矢量为零，以此为起点至宏观纵向磁化矢量恢复至最大值的63%为终点，这之间的时间间隔为T1值。\n纵向弛豫正好是与横向弛豫相反的过程，处于高能级状态的质子释放出能量回到低能级状态的过程。T1弛豫也可用来区分不同组织。T1弛豫能量释放快慢和质子周围的分子热运动频率有关，如果质子周围的分子热运动频率与质子的进动频率相等，那么质子能量释放的越快，纵向弛豫过程越短，T1越短，如果与周围分子的热运动频率相差较大，那么T1越长。\n\n            \n        \n    \n            \n    组织T1值    \n    \n\n \n\n磁共振信号磁共振线圈只能采集到旋转的宏观横向磁化矢量，而宏观横向磁化矢量切割接收线圈而产生的电信号实际上就是原始的磁共振信号。只要在接受时宏观横向磁化矢量越大，则采集到的电信号越大。\n自由感应衰减信号组织接受90°射频脉冲的激发，组织中将产生宏观横向磁化矢量，射频脉冲关闭后组织中的宏观横向磁化矢量由于受T2弛豫和主磁场不均匀的影响，而指数形式较快衰减，即自由感应衰减。\n            \n        \n    \n            \n    自由感应衰减信号    \n    \n\n \n\n自旋回波信号把主磁场不均匀造成的影响剔除，采集到的信息才能真正反映组织的T2弛豫。所采用的办法是180°聚焦脉冲。\n \n从Z轴方向看XY平面，假设质子逆时针进动，且进动方向保持不变。90°脉冲激发后质子的横向磁化分矢量相位一致。随着时间的推移，由于主磁场不均匀，质子的横向磁化矢量逐渐失相，到了180°脉冲施加前的即刻，质子1进动最快相位走在最前，质子4进动最慢，其相位落在最后；施加180°聚焦脉冲后，所有质子的相位反转了180°，即进动最慢的质子4的相位到了最前面，进动最快的质子1相位落到后面。\n\n\n            \n        \n    \n            \n    180°聚焦脉冲机制    \n    \n\n \n\n质子1依然进动最快，质子4进动最慢，所以随着质子群的推移，质子群相位逐渐重聚，将形成一个逐渐增大的宏观横向磁化矢量。经过与Ti相同的时间即2倍Ti时刻，进动最快的质子1赶上进动最慢的质子4。将形成最大的横向宏观磁化矢量。从此刻开始由于磁场强度分布不均匀，又将开始自由感应衰减。产生的这种回波信号称为自旋回波（SE）。\n\n            \n        \n    \n            \n    180°聚焦脉冲机制    \n    \n\n \n\n\n梯度回波信号梯度回波的产生过程是:如果人为的再添加一个磁场梯度，使磁场的不均匀程度更大，那么就会进一步加速T2*衰减，经过一段时间，将磁场梯度翻转。之前磁场强度较低的地方反过来具有较高的磁场强度，之前旋转得慢的原子核就旋转得更快了。相应地，之前磁场强度较高的地方反过来具有较低的磁场强度，之前旋转得快的原子核就旋转得更慢了。经过一定时间，之前的失相位就会被抵消，不同位置处的原子核相位重新同步，它们的磁化向量的方向分布更集中，这些向量之和的幅值就逐渐增大了。此时测得的信号就是一个梯度回波信号\n值得注意的是，只有施加磁场梯度产生的失相位才在添加反向磁场梯度后被抵消，由于其他原因产生的磁场不均匀 (例如BO的不均匀)是不会被抵消的，因此梯度回波的幅值是由T2*决定。\n\n            \n        \n         \n            \n    \n    梯度回波信号    \n    \n\n \n\n参考《磁共振成像技术指南》—— 杨正汉\n懿氏百科全书\n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（五）：K空间","url":"/2023/06/01/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AK%E7%A9%BA%E9%97%B4/","content":"K空间和傅里叶变换在之前的学习中一直参考的是《磁共振成像技术指南》这本书，但是看书还是无法理解K空间和相位编码部分的知识。在网上找了一些资料看了一下，决定看看这部分数学推导，这样应该可以帮助理解。\nK空间数学原理在主磁场的+z方向上的梯度磁场激发下，假设某一个平面h(x,y)的进动频率为f0，那么理论证明，该切面产生的FID信号可以表示为\n\n上述公式推导过程非常复杂，我并没有看太懂 贴个连接 MRI原理-信号 有解释\n现在要通过S(t)把h(x,y)表示出来，h(x,y)表示二维的灰度值图像，那么该图像的频域表达式可以写为\n\n我们如果能求出H（u,v），那么就能通过傅里叶变换求出h(x,y)。\n于是，为了求解H(x,y)，人们引出了x和y方向上的梯度场，以此来标明连续空间中，不同位置的点在位置特定的场强（B0 + zGz和该点的Gx和Gy的矢量和）下对FID信号做出的贡献。\n则在原先f0的场强变为（xGx,yGy,B0+zGz）的一个矢量，f0就变成与x和y相关的函数\n\n上式对比二维傅里叶变换可得\n\n其中 , \n所以得到的S（t）经过解调制后，就能得到H（u,v），然后再进行傅里叶变换就可以得到原始图像信号。由有限个H（u,v）填满的矩阵，就叫做K-space。而为了填满K-space，不断的改变梯度场时间t， 和梯度场大小的操作， 就叫做频率编码和相位编码。\n\n            \n        \n    \n            \n    GX与GY在K空间的效应    \n    \n\n \n\n频率编码通过上图可以发现，当Gy为零时，Gx所持续的是填Tx共同决定了K空间的Kx轴，相反，Gy和Ty共同决定了Ky轴\n习惯上我们先沿着X轴方向采集信号，其中采集信号的方式就是采用脉冲时间序列。\n            \n        \n    \n            \n    在X方向上采样    \n    \n\n \n“slice refocusing gradient\" 这里的作用是当RF脉冲序列的频宽过大，与之发生共振的组织也会更多，共振频带过大，这导致切片出来的信号会出现小幅度的相位差，从而使得采集图像模糊。因此这里会加上一个slice refocusing gradient，使得RF频带中的组织都在一个比较小范围差的频率下发生共振。\n\n\n\n我的理解是由于进动频率由磁场强度决定，所以原来的激发范围很大，加上相反的磁场强度后，位于前面的质子频率增大，位于后面的质子频率减小，最后得到了一个相对小的激发频率带宽。\n            \n        \n    \n            \n    大概理解    \n    \n\n \n\n这里Gx不变，在Tx采样表示，在X轴上朝右移动。\n每次采样中，同一个x位置下的组织产生的是相同的共振频率。这也就是说，Kspace中，垂直于x轴线的每一条采样轨迹(trajectory), 都具有相同频率分布。换句话说，在kspace这一二维坐标系下，同一个横轴坐标表示具有同一个频率。这种采样方法形成的轨迹被叫做笛卡尔采样轨迹(Cartisan Trajectory)。而这种在x轴方向上固定梯度磁场大小，只改变磁场时间的采样方式，就叫做频率编码。\n为了能够既采样负x轴方向，又采集x的正轴方向，人们选择先从x轴的负方向出发一直到最左端，然后再掉头往x的正方向去。因此需要先加上一个负梯度，然后才是正梯度。\n\n            \n        \n    \n            \n    梯度先负再正    \n    \n    K空间内填充顺序\n    \n\n\n\n负梯度施加一个周期后，施加正梯度两个周期正好把X轴的一行采集完毕。这种梯度场产生的回波信号叫做梯度回波信号（Gradient Echo, GE）\n相位编码相对的在y轴上实行相位编码。而实际中X轴做频率编码还是相位编码并不是固定的，这两个轴采样方法可以反过来。\n\n            \n        \n    \n            \n    相位编码    \n    \n\n \n如果固定x轴的梯度Gx和磁场时间tx，即使得信号只沿着K-space的y轴发生平移，然后不停的改变Gy的大小，这造成了y方向上的每一个组织点都有不同的磁场大小，由此会导致不同的拉莫尔频率，而不同的拉莫尔频率又会导致组织点们out of phase，与之前学习的相位编码相同。在这里不同的Gy代表了不同Ty时刻Y轴的等间隔采样。这种采样方式称为相位编码。\n\n            \n        \n    \n            \n    填充K空间和傅里叶反变换后成像    \n    \n\n \n\n\n参考《磁共振成像技术指南》—— 杨正汉\n知乎：MRI—从产生信号到生成图像（二)   作者：嘭噗啪嚓吧\nMRI原理-信号   \n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（四）","url":"/2023/05/24/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"磁共振的空间定位地球上的纬度的定位依靠地磁梯度，实际上磁共振信号的三维空间定位也是利用三套梯度线圈产生的梯度磁场来实现的。MR信号的空间定位包括层面层厚的选择、频率编码、相位编码。\n层面和层厚的选择在1.5T场强下，质子进动频率约为64MHZ。在Z轴施加一个梯度场，在Z轴中心质子进动频率依然为64MHZ，靠近头部磁场逐渐减小进动频率变慢，靠近脚部磁场逐渐增大进动频率变大。假设梯度磁场造成进动频率差为1MHZ/cm，则使用63.5~64.5MHZ的射频脉冲，被激发层面的中心位置就在Z轴中心，厚度为1cm。\n            \n        \n    \n            \n    层面和层厚选择    \n    \n\n  \n\n在检查部位与层面选择梯度线圈的相对位置保持不变的情况下，层面和层厚受梯度场强度和射频脉冲影响的规律如下:\n\n梯度场不变,射频脉冲的频率增加,则层面的位置向梯度场高的一侧移动。\n梯度场不变，射频脉冲的带宽加宽，层厚增厚。\n射频脉冲的带宽不变,梯度场的场强增加,层厚变薄。\n\n频率编码经过选层得到的信号是一个二维层面所有的信息，需要进行频率编码和相位编码来区分方向。以头颅的横断面为例，在前后方向施加前高后低的梯度场，这样前部的质子进动频率高，后面的质子进动频率低。采集到的MR信号中就包含有不同频率空间的信息，经过傅里叶变换后可以区分出不同频率，分配到前后方向各自的位置上。\n            \n        \n    \n            \n    频率编码    \n    \n\n  \n\n\n相位编码频率编码只实现了区分前后位置，并没有左右位置的信息，因此需要相位编码来区分左右。在左右方向施加一个左高右低的相位编码梯度场，这样左右质子的进动频率就不同。进动频率不同会导致一段时间后质子的相位改变，这时关闭梯度场，这样相位的差别就会被保留下来。这时采集MR信号带有不同的相位信息，通过傅里叶变换可以区分不同相位的信号，实现了左右方向的空间定位。\n            \n        \n    \n    \n            \n    相位编码    \n    \n\n  \n\n由于傅里叶变换的特性，只能区分180°相位的信号。（此处不理解，在网上看到有说这里说法是错误的）因此如果矩阵是256×256的图像需要进行256次相位编码。\n            \n        \n    \n            \n    相位编码实际施加    \n    \n\n  \n相位编码的知识还是有点难理解，下一篇从数学角度进行解释\n\n参考《磁共振成像技术指南》—— 杨正汉\n","categories":["影像基础"],"tags":["MRI"]},{"title":"远程保存hexo博客仓库","url":"/2024/03/13/%E8%BF%9C%E7%A8%8B%E4%BF%9D%E5%AD%98hexo%E5%8D%9A%E5%AE%A2%E4%BB%93%E5%BA%93/","content":"问题来源博主之前用的是笔记本，最早的博客都存在笔记本上，读研之后电脑设备增多，工位一个，宿舍一个。如果用之前的方法，每个电脑上都保存一个博客数据，更新起来很不方便。于是我想到这个问题正好可以用Github解决（Github使用不熟练），所以在网上找了一个方法，本篇博客为记录并且复刻方法。\n参考: hexo个人博客：换了电脑怎么办\n解决方案首先需要知道，hexo生成的静态文件会放在public&#x2F;文件夹中，部署就是把public文件夹中的内容上传到git仓库中。\n\n方案一：在github仓库上新建一个仓库，然后把blog文件夹上传进行备份。\n\n方案二: 在博客仓库创建一个新的分支，使用分支来管理。\n\n\n步骤本文采用方案二\n1.拷贝远程仓库进入D盘，右键点击Git bash here\ngit clone git@github.com:maxiro-samurai/maxiro-samurai.github.io.git\n把项目文件夹拷贝到本地\n2.删除文件夹内容进入maxiro-samurai.github.io.git项目文件夹中，删除其中的内容，把blog文件夹（即备份的blog）下全部复制到其中\n3. .gitignore文件打开.gitignore文件，这个文件的作用是指定哪些文件上传的时候可以忽略，因为blog&#x2F;的文件并不全部都需要\n.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/\n意思就是上传的时候忽略以上内容\n4.创建一个hexo（任意名字）的分支并切换到这个分支git checkout -b hexo \n\n把所有文件添加到暂存区\ngit add --all\n\n提交到本地版本库\ngit commit -m &quot;&quot;\n\n推送hexo分支的文件到github仓库\ngit push --set-upstream origin hexo\n\n5. 结束\n效果\n\n这个就是最后需要备份的文件夹\n6.更新博客\n生成草稿\nhexo new draft 远程保存hexo博客仓库\n\n\n发布博客\n  hexo publish 远程保存hexo博客仓库\n  hexo g \n  hexo d\n\n\n更新备份\n  git add.\n\n  git commit -m&quot;注释&quot;\n\n  git push origin hexo\n\n\n\n至此大功告成，在新电脑上只需要从远程仓库clone到本地，然后按照上述步骤进行更新博客即可\n","tags":["杂记"]},{"title":"重新开始的模电生活（一）","url":"/2022/03/25/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前言重学模电，不光理论，必须实践，实物搭建可能没有，用仿真软件Micro-cap，发现比Multisim强大，一起学了以后肯定用到。  \n教材资源参考《新概念模拟电路》下载地址：https://www.analog.com/cn/landing-pages/002/yang-e-book.html\nJFET 结型场效应管——晶体管内部载流子十分复杂，实际应用中只关注特定的几个参数，不展开\n\n晶体管分为NPN与PNP管\n            \n      \n  \n          \n  晶体管类型    \n  \n\n\n\n具体参数分析  \n以2N3415为例看数据手册 pdf连接：https://html.alldatasheet.com/html-pdf/50004/FAIRCHILD/2N3415/405/1/2N3415.html\n\n\n\n            \n        \n    \n            \n    2N3415 datasheet    \n    \n\n\n\nVCEO ：集电极到发射极最大电压\n\nVCBO ：集电极到基极的最大电压\n\nVEBO ：发射极到基极的最大反向电压\n\nIC ：集电极电流（正常工作下最大电流）\n\nPD : 功耗  \n\n耗散功率，也称集电极最大允许耗散功率PCM，是指晶体管参数变化不超过规定允许值时的最大集电极耗散功率。耗散功率与晶体管的最高允许结温和集电极最大电流有密切关系。硅管的结温允许值大约为150°C，锗管的结温允许值为85°C左右。要保证管子结温不超过允许值,就必须将产生的热散发出去。\n\nBJT的总耗散功率为Pc=IeVbe+IcVcb+Icrcs≈IcVcb），并且Pc关系到输出的最大交流功率Po：Po=(供给晶体管的直流功率Pd)–(晶体管耗散的功率Pc)=[η/(1–η)]Pc∝Pc，即输出交流功率与晶体管的耗散功率成正比（η=Po/Pd是转换效率）。晶体管功率的耗散(消耗)即发热，如果此热量不能及时散发掉,则将使集电结的结温Tj升高,这就限制了输出功率的提高；最高结温Tjm（一般定为175oC）时所对应的耗散功率即为最大耗散功率Pcm。为了提高Po，就要求提高Pc,但Pc的提高又受到结温的限制，为使结温不超过Tjm，就需要减小晶体管的热阻Rt；最大耗散功率Pcm∝1/Rt。最高结温Tjm时所对应的最大耗散功率为(Pcms≥Pcm)：稳态时，Pcm=(Tjm–Ta)/Rt；瞬态时，Pcms=(Tjm–Ta)/Rts。\n\n\n\nR : 热阻jc，芯片的热源结到封装外壳间的热阻，乘以发热量即获得结与壳的温差。\n\n一般热阻公式  = （散热良好）\n否侧  =（）\n如果为小功率器件，那么公式应为  =\n\n\nICBO : 集电极漏电流。\n\nIEBO ：发射极漏电流。\n\nhFE : 直流电流增益即β\n\n\n输入伏安特性\n晶体管的输入伏安特性，是指基极电流 iB与发射结电压UBE之间的关系——可能受到UCE的影响。\n\n\n\n\n仿真电路图\n\n\n            \n        \n    \n            \n    2N3415电路    \n    \n\n\n\n\n输入伏安特性曲线            \n      \n  \n          \n  输入伏安特性曲线    \n  \n\n\n\n输入伏安特性曲线与二极管类似\n输出伏安特性\n晶体管输出伏安特性，是指一个确定的基极电流iB下,集电极电流iC与 UCE之间的关系。\n\n\n电路图同上修改仿真软件的参数即可\n            \n      \n  \n          \n  参数具体修改    \n  \n\n\n\n输出伏安特性曲线\n  \n              \n          \n      \n              \n      输出伏安特性曲线    \n      \n  \n  \n\n\n放大区 ：满足 \n饱和区 ：一般分界电压为0.3V，压降很小而iC很大\n截止区 ：有漏电流，所以截止区也有电流，不过很小\n\n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（三）","url":"/2022/03/31/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%89%EF%BC%89/","content":"动态响应求解输入为动态，输出也为动态的求解步骤  \n\n  \n\n输入信号只保留变化量，输出也指标是变化量（不关心频率） \n电路中的电压不变点接地，电路中电流不变支路开路 （详细解释看书）\n电路中某个元件再某个范围内，可以用直线表示其伏安特性，且输入变化过程中，该元件始终在直线上，则该元件可以用其动态电阻代替\n\n\n按照上述规则可以画出新的等效电路  \n  \n双极性晶体管的动态模型——微变等效模型低频等效当输入变化量 非常小时，可以把输入特性曲线在Q1看成一小段直线。对于输入伏安特性中的任意静态工作点有：  \nrbe即为动态电阻，在放大状态情况下，Q1点处的动态电阻可以近似表示为：  \n其中rbb’为体电阻，一般为几到几百，UT常温下为26mV。 \n当峰峰值为,就会产生峰峰值为的电流波形，两者的比例关系，近似为rbe。\n  \n\n            \n        \n    \n            \n    晶体管低频等效    \n    \n\n    \n\n高频等效不做解释（看模电书）\n\n            \n        \n    \n            \n    晶体管高频等效    \n    \n\n  \n\n动态分析三个重要指标\n\n电压放大倍数也叫电压增益，用Au表示，也可以用G表示，无单位。当输入正弦波峰峰值为ui，输出正弦波峰峰值为uo，电压增益为：\n\n\n  \n\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;也可以用分贝表示:\n\n\n\n输入电阻ri：\n\n\n它属于动态电阻，多数情况下希望放大电路的输入电阻越大越好。\n\n\n输出电阻ro：\n\n\n指输出端带负载的能力。输出电阻越大带负载能力越弱。\n\n动态分析的步骤\n以晶体管微变等效模型为核心，针对原始电路画出动态等效电路  \n  1.对电路中的电压不变点，实施接地。  2.对电路中的大电容，实施短接。对电路中的小电容，实施开路。  3.将晶体管，用晶体管的微变等效模型进行替代。  4.稍作整理\n\n\n\n            \n        \n    \n            \n    简化电路图    \n    \n\n  \n\n\n依次求解Au、ri根据动态等效电路，可以很轻松得到如下结论：\n\n\n输入电阻为:  \n\n求解Ro  ：\n  按照下图  \n              \n          \n      \n              \n      放大电路框图    \n      \n  \n    \n\n\n先扔掉负载电阻。任何放大电路的输出电阻，都与负载电阻无关。  \n让输入激励源=0，对电压输入短接即可，此时受控源一定变为0。  \n在输出端加一个虚拟电压源Uv，在电路中计算由此引起的iv  \n\n                                                    求解输出电阻              \n  \n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（二）","url":"/2022/03/29/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"晶体管的工作状态\n截止状态：晶体管基极没有产生明显的电流，即IBQ非常小，导致ICQ也很小，晶体管没有导通。\n\n\n\n\n放大状态：指IBQ合适，且满足\n\n\n\n\n饱和状态：UCEQ小于UCES晶体管就处于饱和状态\n\n倒置状态：C和E管脚接反，此时晶体管 下降严重\n\n\n\n状态判断\n            \n        \n    \n            \n    判断法则    \n    \n\n\n\n\n静态估算步骤\n  1.根据UBEQ=0.7V，利用戴维南等效，KCL，KVL求解出IBQ  2.假设晶体管处于放大状态，列出集电极回路方程解出UCEQ  3.如果UCEQ&gt;=0.3V,则假设成立，反之不成立，晶体管处于饱和状态，UCEQ=0.3V\n\n\n  \n\n图解法求解静态工作点\n            \n        \n    \n            \n    电路图    \n    \n\n  \n\n输入伏安特性的图解法根据电路列出方程  \n\n该直线与输入伏安特性曲线的交点为Q（UBEQ,IBQ）\n\n            \n        \n    \n            \n    输入伏安特性图解    \n    \n\n  \n\n改变RB的值会改变直线跟曲线的交点\n\n输出伏安特性的图解法可列出方程该支线与输出伏安特性曲线的交点为Q（UCEQ,ICQ）\n\n            \n        \n    \n            \n    输出伏安特性图解    \n    \n\n  \n\n\n\n可发现改变RB的大小会改变输入曲线的交点，进而影响输出曲线上的点的位置，同理改变RC和EC都能达到同样效果\n  \n两部件串联分析法\n分别画出两个部件的伏安特性曲线\n以部件B的伏安特性曲线为基础，在图中找到横轴等于Ui的位置\n以此为中心点，部件A的伏安特性曲线实施横向镜像，绘制再原图中，此时，两根曲线会有一个交点，交点横轴即为输出电压，纵轴就是输出电流。\n\n\n            \n        \n    \n            \n    输出伏安特性图解    \n    \n\n  \n\n三极管同理  \n \n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（五）","url":"/2025/02/20/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%BA%94%EF%BC%89/","content":"大信号下情况的失真分析基本上分为超范围失真和非线性失真\n饱和失真和截至失真当晶体管进入截止区产生的输出波形失真，称为截止失真；进入饱和区产生的失真为饱和失真。\n使用仿真电路图如下：\n输入信号为1mV 5Khz\n经过之前的静态计算，可知VF1= 5V，在此静态下，放大电路可正常工作。\n输出端电压波形如下\n\n当把Rc增加为1.5K时，静态工作点VF1 = 2.5V左右\n输入信号10mv，即降低静态工作点，增大输入信号，输出将发生饱和失真。\n\n这是因为静态工作点VF1很小，在基极电流Ib变化过程中，UCEQ&lt;0.3V，进入饱和区导致输出截止。\n如果减小Rc到200Ω，并且增加输入信号幅值为100mv，输出将发生截止失真。\n\n因为Uc点的电压最高不能超过电源电压，晶体管截止就出现了截止失真。\n如下图所示 \n失真电压裕度失真电压裕度：在一个晶体管放大电路中，输入为正弦波电压信号，输出所能达到的最大的不失真正弦信号的幅度，用表示。\n因此\n如果当前静态工作点为Q（UCEQ,ICQ）则饱和失真电压裕度为：截止失真电压裕度为：\n\n\n\n静态负载线和动态负载线静态负载线，描述了EC和电阻RC不变的情况下，静态工作点改变收到的约束。而动态负载线，描述了电路开始工作之后——uce和iC在变化中收到的约束\n静态负载线，即分析静态下电路输出回路。  \n动态负载线，即分析动态下电路输出的回路。\n  \n\n对饱和失真电压裕度：\n\n对截止失真电压裕度：\n\n\n实际电路的失真——非线性失真   \n实际情况需要考虑输入伏安特性的非线性，在还未达到超范围失真时，ib就已经失真了。\n\n放大电路如下，输入信号有效值为1mV时，可以看到无明显失真。\n\n输入信号有效值为20mV时，可以看到明显的馒头状失真。\n\n改良4电阻放大电路两电阻放大电路由于静态工作点由IB和β决定，所以会受β影响。这就会导致温漂，静态工作点在不同温度下不一样。所以引出4电阻放大电路，电路图如下所示\n\n基极电压由RB1和RB2分压所得，相比一个电阻确定更加稳定，在发射极引入一个电阻引入了负反馈。静态工作点与β关系很小，静态工作点相对稳定。公式具体看书上。\n单管放大电路的静态工作点选择静态工作点由(ICQ,UCEQ)决定\n\nUCEQ一般情况下应选择动态负载线的中心位置，以保证较大的失真电压裕度。\n\nICQ在低功耗设计中，尽量让ICQ小。这样会导致输入电阻增大，电阻噪声增大。使用大电流，会给输入电流变化带来足够的空间，有利于抗干扰。\n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（六）","url":"/2025/02/21/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E5%85%AD%EF%BC%89/","content":"多级放大电路之前分析过了，共射极、共基极、共集电极放大电路各有优缺点。多级放大电路就是将三种组态的放大电路通过合适的方式级联起来，以增大放大倍数、增加输入电阻、减少输出电阻、增大功率、扩展频带。\n直接耦合两级放大电路直接用导线、电阻连接。\n优点：\n\n直流电压或者低频信号放大\n\n缺点：\n\n前级静态工作点会影响后级静态导致计算麻烦，并且后级静态工作点很难稳定。\n\n阻容耦合使用隔直电容将两级放大电路连接起来，利用后级输入电阻和此电容组成阻容耦合。\n优点：\n\n静态互不影响，各级静态工作点比较好选择且容易稳定。\n\n缺点：\n\n无法放大直流信号，对低频信号有较强的衰减作用。\n\n方框图求解多级放大电路任何一个电压放大器都包含输入电阻ri，空载放大倍数Au，以及输出电阻ro，在动态分析中把每一级放大电路都画成方框图，然后再级联起来就很方便获得最终结果。\n\n\n其中常数K1,2,3是电阻分压比\n其中需要注意，在上述方框图，共射极电路和共基极电路完全适合，但对共集电极电路不适用，因为共集电极电路（射极跟随器）的输入电阻与后级的输入阻抗有关。具体操作就是，第一级的输入阻抗包含第二级的输入阻抗，而共集电极电路的输出阻抗看做0。\n如下图\n可以等效为\n输出电压表达式： \n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（四）","url":"/2022/04/03/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"共基极、共集电极放大电路和PNP管电路晶体管放大核心“UBE变化，引起iB变化，映射出iC、iE变化”。所以，只有b，e两个极能够作为输入端。而输出信号一定在c或者e端。  \n  \n\n基极b输入，集电极c输出，叫共射极放大电路，全称为共发射极放大电路。  \n\n基极b输入，发射极e输出，这叫共集电极放大电路，也成射极跟随器。  \n\n发射极e输入，集电极c输出，这叫共基极放大电路。\n\n\n  \n晶体管有三个极，一个作为输入，一个作为输出，剩下什么极，就叫共什么极放大电路。\n  \n共基极放大电路  \n\n            \n        \n    \n            \n    共基极电路    \n    \n\n    \n\n\n静态分析 \n  1.戴维宁等效：   \n  \n  输入回路方程可解得：  \n    \n      \n  晶体管UCEQ&gt;0.3V,处于放大状态  \n  \n              \n          \n      \n              \n      静态分析结果    \n      \n  \n      \n\n  仿真结果稍有误差  \n     \n\n动态分析  \n  \n              \n          \n      \n              \n      动态等效电路    \n      \n  \n      \n\n\n列出节点电压方程：\n\n  Missing or unrecognized delimiter for \\left\\left{\\begin{array}{c}{u_e\\over R_E}={u_s-u_e\\over R_S}+(1+\\beta){0-u_e\\over r_{be}} \\\\beta{0-u_e\\over r_{be}}={0-u_o\\over R_L’} \\   \\end{array}}   \\right.\n  可以得到  \n  如果信号源内阻为0，可简化为\n  从以上可以看出，共基极放大电路与共射放大电路又相同的电压增益，只是极性为同相放大，共射为反相放大，输入电阻小。  \n\n输入电阻：  \n\n                                                    动态仿真结果                  \n  可以看出与理论计算差别不大   \n\n\n共集电极放大电路此电路又称射极跟随器，它与共射级、共基极电路唯一的区别在于，Rc可以为0。另外两个电路Rc的作用是把IB的变化转化为电压的变化，而此电路的输出端在发射极，所以RC不是必须。                                                            共集电极放大电路                    \n\n静态分析，与前面两个类似不分析  \n\n动态分析 ：  \n              \n          \n      \n              \n      动态等效电路    \n      \n  \n      \n\n\n电压增益：  \n\n    \n  多数情况下，Aui近似为1  \n\n输入电阻：  \n\n  很显然输入电阻远大于共射放大电路（rbe），更大于共基极放大电路的输入电阻（），这是设计跟随器的显著优点。  \n\n输出电阻：  \n\n  输出电阻很小\n    \n  设计跟随器，虽然不具备电压放大能力，但是第一具有电流放大能力，第二具有输入电阻大、输出电阻小的特点，使其在扩流、阻抗匹配中获得了广泛应用。  \n  应注意，共射、共基极电路输入电阻与负载无关，输出电阻与信号源内阻无关。但共集电极电路却不是如此。他的输入电阻与负载大小有关，而输出电阻与信号源内阻有关。\n\n\n\nPNP管放大电路动态分析与NPN完全一样  \n\n方法一：对PNP管的全部伏安特性，都实施反向定义  \n\n对所有电流方向，均与NPN管相反。\n所有点位差定义，也相反。\n\n\n方法二：遵循NPN的全部定义，所有求解的值是反的，所有的图，都从第一象限镜像到第三象限。\n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（七）","url":"/2025/03/03/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%83%EF%BC%89/","content":"场效应管分类和管脚定义场效应管分为结型场效应管（Junction FET）和金属氧化物场效应管（MOSFET），其中MOSFET又分为增强型与耗尽型两种，但在日常工作中市面上较多使用的是增强型MOS。\n\n注意，在JEFT中，源极和漏极是对称的可以互换位置，在MOSFET中衬底和源极在内部已经连通，很多MOS管D、S之间并联了一个二极管，因此D和S不能互换。\n结型场效应管转移特性曲线在TINA中仿真一个N型JFET，其中设置GS电压为控制对象，在栅极和源极分别串联一个电流表，如下图所示：\n\n因为场效应管GS之间的电阻非常大，几乎可以看做断开，所以流入的电流也很非常小。转移特性曲线仅关注VGS与VDS之间的关系。在直流分析中选择直流传输特性，V1输入电压范围为-5~5V。得到下图所示转移特性曲线。\n\n\n当VGS小于某一电压时，管子关断，此时这个电压叫做夹断电压UGSOFF。\n\n当VGS大于UGSOFF但小于0.7V时，管子处于导通状态，电流随VGS增大。\n\n还可以观察到当VGS大于某一值时，电流反而随着VGS增大而减少。这是由于电压过大，管子被击穿。从图中可以看出，VGS大于0，ID还有增长的趋势，但此时G、S之间就不再是高阻，即GS之间电流也增加。\n\n当VGS=0时，漏极电流称为零偏漏极电流，这是N-JFET能提供的最大电流。\n\n\n数学表达式：\n分界点电压：\n输出伏安特性曲线选择V2在020V变换，选择V1为控制对象，使V1在-20V之间变化，就可以画出在VGS不同电压下的输出伏安特性。\n\n\n可以看出这个曲线跟晶体管输出伏安特性曲线十分相似，在VGSOFF&lt;VGS&lt;=0时，VDS在小于某一电压时，IDS随着VDS增大而增大，这一段类似晶体管的饱和区。\n\nVDS在大于于某一电压时，IDS几乎不再增加，看起来像恒流源一样，称作恒流区类似晶体管的放大区。\n\n\nMOSFETMOSFET中包含耗尽型和增强型，耗尽型的伏安特性曲线与JFET非常相似，区别在于：它允许UGS大于0。\n增强型NMOS伏安特性曲线\n\n开启电压UGSTH：当UGS小于开启电压时，无论多大UDS电流iDS均为0，只有当大于开启电压时，晶体管才可能存在电流。\n\n转移特性曲线的数学表达式：\n\n可变电阻区与恒流区分界线：\n\n\n\n三电阻MOSFET电路的静态分析结合之前的电路分析方法与FET的特点对静态分析，电路如下图所示\n\n分析要点：\n\n与晶体管电路相似，使用戴维南定理分析G极回路，得到栅极电压。\n\n跟晶体管特性不同，我们要先假设MOS工作在恒流区，然后根据假设计算出UDSQ是否达到开启电压，通过转移特性曲线公式进行计算。\n\nUDSQ＞UDS_dv，满足假设，管子处于恒流区。\n\n\n四电阻MOSFET电路静态分析\n四电阻共源极放大电路与上面三电阻的区别就是S极在静态添加了一个电阻，而这个电阻的作用与之前在4电阻晶体管作用类似，可以增加电路的稳定性，原理为引入负反馈。\n\n戴维南定理分析\n\n利用转移特性公式与UGS = UGQ-iDR5，解出UGS和iD（2次方程有两个解需要舍弃一个不满足开启电压条件的解）\n\n最后根据静态判断MOS管是否在恒流区\n\n\nJFET电路的静态分析\n由于JFET的UGS小于0才能开启，上述电路图关键点在于仅使用一个正电源和R2便能使得JFET开启（自给偏压电路）。\n\n分析类似，UGQ一定是0V因为G极没有电流，JFET转移特性曲线方程与UGSQ = -IDQ*R2联立可以解出IDQ和UGSQ\n\n得到两个解要满足直线与平方曲线小于UGSOFF的交点\n\n\nFET微变等效模型对GS两端施加微变电压信号，无法产生电流变化（无伏安特性曲线），使用转移特性来研究。\n\n定义跨导为gm，单位为西门子 S:\nQ点上升，其切线斜率上升，跨导变大。对于JFET和MOSFET，无论增强型还是耗尽型，其微变等效模型都如下图所示\n\n\nJFET对转移特性曲线曲线求导可得：\n说明，某个Q点的跨导，与晶体管本身影响曲线斜率的参数UGSOFF、IDSS、IDQ有关。\n\nMOSFET对转移特性曲线曲线求导可得:\n\n\n\nJFET放大电路的动态分析上面已经解过JFET放大电路的静态，下面直接进行动态分析，动态分析需要得到静态参数。\n动态等效电路图画法与晶体管类似。\n\n求解Au时，把Uo和Ui都写成Ugs的函数可得： \n\n输入输出电阻求法与晶体管一致。  \n\n\nMOSFET共漏极放大电路的动态分析与晶体管共集放大电路相似，属于MOSFET中的“射极跟随器”。\n\n静态：\n\n戴维宁以及环路方程与MOSFET转移曲线方程联立可得IDQ，UGSQ\n\n动态等效图\n 放大倍数\n 输入电阻很简单就是RG1与RG2并联\n\n输出电阻\n 信号源短接，从输出口接入一个信号源，从输出口中看进去的电阻\n \n 需要注意电流方向与电压方向\n \n \n\n\n","categories":["硬件","模电"]},{"title":"晶体管提升","url":"/2025/03/17/%E6%99%B6%E4%BD%93%E7%AE%A1%E6%8F%90%E5%8D%87/","content":"晶体管提高篇目前单独使用晶体管做放大电路情况很少，一般都用运放。这节介绍晶体管典型应用。\n恒流源实现高增益放大\n电路放大倍数为，当我们要求时，电压放大倍数无法被改变。\n因为改以上参数任何一个，静态电路会受到影响，另外两个也会受到影响，最终结果就是AU几乎不变。理论分析如下：\n\n\n可以看到AU仅与静态URc有关。\n我们把RC替换成一个恒流源，原理图如下：\n\n控制Q2的基极电流不变，Q2就成了一个恒流源，图中用一个固定电阻连接基极。\n那为什么接一个恒流源就可以增大电压放大倍数呢？\n这两个管子是串联在一起的，运用之前的两部件串联分析方法（图解）可以画出伏安特性曲线：\n\n红色线代表Q1输出福安特性曲线，绿色线代表Q2，黑色实线代表Rc。\n当固定电阻RB1和RB2，红色和绿色线就固定了。RB2选择十分困难，两个输出伏安特性曲线都非常平坦，稍微不合适，就会有一个管子进入饱和区。\n决定输出放大倍数的输出福安特性曲线的斜率，因为变化相同ic的情况下，斜率越大的曲线Uc变化越大。\n从上图可以看出绿色管子的动态电阻大于黑色实线，所以电压放大倍数增大。\n\n恒流源负载总结\n\n在UCE很大的变化范围内，ic基本保持不变（晶体管放大区）。针对变化量，c、e之间呈现一个很大的动态电阻。\n在Q2静态工作点处，呈现一个较小的静态电阻。\n将这样一个静态电阻小，动态电阻大的电路，接入到其他电路中，称为恒流源负载。\n\n\n\n","categories":["硬件","模电"]},{"title":"差分放大","url":"/2025/03/17/%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7/","content":"差分放大我们日常使用的信号源一般是两根线传输，一个地线，一根是信号线，这种信号叫做单端信号。单端信号在远距离传输过程中，不可避免的要受到外界电场的干扰，而差分信号抗干扰性很强。\n定义1：差分信号中两个信号线之间的差值信号，用uD表示：\n定义2：差分信号中两个信号线共有的信号，称为共模信号，用uC表示：（）\n在远距离传输过程中，因为两根线两根线距离很近，两根线都收到了相同的外界干扰。此时，差模信号是待测的有用信号，而共模信号是干扰。如果有一个差动放大器，他有两个输入端和两个输出端，而真正有意义的输出是两个输出端的差值。\n差动放大器先在仿真软件中模拟出差模和共模信号，电路图如下所示：\n\n信号源通过两个压控电压源（放大倍数均为0.5）正极输出和负极输出模拟差分信号，共模信号接在两个压控电压源之间。则\n$$\\begin{align*}\\left{\\right.\\end{align*}$$\n当关闭共模信号输入时可以用示波器看到，输入与差分信号的关系：\n每一路信号都是输入信号的0.5倍，VF2是VF3的反相信号，正好是原信号\n当接入共模信号时，可以看到每一路差分信号都是在共模信号的基础上叠加的。\n假设我们可以造出一个放大器，它能够实现分别放大两路差分信号，最后再把两个输出信号相减得到放大的有用信号。\n差动放大电路如下图所示：\n我们用示波器看Vin+和Vout+的结果，看信号是否被放大\n\nVout+信号是Vin+放大后的结果，但是又有点奇怪，因为我们还没有对Vout+和Vout-相减，它的输出就已经没有共模信号了，这是为什么？这正与我们期望的一样，我们希望差动放大电路可以放大差模信号，抑制共模信号。下面是理论分析：\n因为电路是线性电路，符合叠加原理，我们只看共模信号输入。首先按照分析步骤，先进行静态分析确定IBQ1，假设两边电路对称，只分析Q1管子：\n解出，\n动态分析我们直接不画动态等效图了，开始脑内脑补，基极电阻就只有RB1和rbe，需要注意发射极是两个管子射极电流并入到一个RE中，所以：\n\n\n得到单端共模放大倍数：单\n即共模信号被抑制。\n差模信号，假设Vin+有一个微小的电压增量，引起基极电流ib1变化，而电路对称所以另一个管子也有一个变化量，在发射极两个管子引起的变化正好大小相等方向相反，在动态分析中可以把两个管子的发射极看做接地（电压不变点）。\n单\n两个输出信号反向，如果我们差分输出可得：\n双\n带负载静态分析中，两个输出端电位相等，所以接入Rload不会对原静态电路造成影响。\n动态分析中。共模信号同理不会对原结果造成影响，不包含Rload。\n对于差模信号，仅在输出端改变。原动态等效图：\n动态分析中要熟练运用电压不变点看做接地，这一技巧，当仅有Vin+输入时，在Vout+引起电压变化+u，Vout-电压不变看做接地，即在Rload左端有电压变化，同理Vin-输入时，在右端有电压变化-u。而在Rload中间点处正负变化抵消，时电压不变点。因此等效电路图：\n\n解得：\n单\n双\n与不带负载时的区别是，在分子上并联了一个0.5Rload。\n单端带载首先静态会影响，输出端多了一个Rload分流。\n\n\n单单\n\n输入电阻：\n\n差模输入电阻：    差模回路的总电阻\n\n共模输入电阻：    左右两侧输入看进去的电阻并联\n\n\n\n输出电阻：\n\n单端：  \n双端：  \n\n\n\n共模抑制比定义：差模增益除以共模增益。差模信号放大越大越好，共模信号越小越好。\n\n用dB表示：  \n输出若为差分形式，如果电路完全对称，CMRR为无穷大。\n输出为单端形式，则将前述分析结果带入：\n\n提高CMRR在前面的例子中CMRR为几十倍，我们在实际生活中往往噪声信号大小比有用信号高了不止几十倍，我们需要更大的CMRR。看CMRR的表达式，只有提高β或者RE的值才能提高CMRR，往往β的提高是有限的，而我们如果提高RE的值，那么静态工作点也将改变。有没有一种方法，不改变静态IEQ，在动态时候可以让RE增的十分大。（静态不变，动态电阻增大）\n答案是上一节：恒流源电路！\n\n这个电路是书本上另一个示例修改的（P150），经过计算和仿真，源电路静态：\n\n\n\n动态：\n单\n单\n\n使用恒流源替代RE，并把恒流源静态电流调至与原电路相同。\n\n仿真结果中两个电路静态相差不大，主要看动态结果。\n单\n单\n\n加入恒流源对电路的主要影响是对共模信号抑制能力的增加，因为只看差模信号动态分析，不管在加不加恒流源，RE1和RE2中间为电压不变点，所以不会对差模放大倍数产生影响。\n在共模信号动态分析时就产生影响，恒流源表现出极大的动态电阻，图中这个管子在仿真软件中接近于理想三极管，所以VF2电压严格等于共模信号，因为几乎没有电流流过恒流源，最终共模放大倍数得到极大衰减。\nMOSFET恒流源在差动放大电路中管子全部使用MOSFET，电路如下所示\n因为书中MOS管参数使用multisim仿真，TINA中没有这个参数的管子，这里仿真数值与计算不同，只看分析方法。\n\n静态：\n  电路对称所以IQ1与IQ2相同，并且流入恒流源中，所以静态几乎是由恒流源的电流决定的。\n  求解IQ3静态电流：  \n  \n  \n  联立求解静态参数\n\n动态：\n  恒流源在动态分析中看做开路（看上面分析），并且Q1和Q2管子栅极无电流流入。动态等效如下：\n  \n  \n  \n  \n5个MOSFET  我们继续改进，在上面的基础上是否还能继续增加差模放大增益，注意观察表达式，增大Rc1和Rc2就可以再增加增益。  类比恒流源，下图为改进后电路\n  \n  上面的两个PMOS管电路叫做恒流源电流镜，保证了两个管子的静态电流相等。\n  我们用电流表量这两个管子上的静态电流，他们是相等的。\n  \n  使用示波器观察放大波形，如果输出波形失真就调节R3，来限制电流，使输出波形正常。\n  \n  交流电压档可以看出，这个电路单端输出电压增益为4150倍\n\n\n","categories":["硬件","模电"]},{"title":"电流镜","url":"/2025/03/21/%E7%94%B5%E6%B5%81%E9%95%9C/","content":"电流镜电流镜一般指1:1电流镜，由输入电流支路、输出电流支路组成，输出电流等于输出电流。\nBJT电流镜核心是两个晶体管的基极和发射极连在一起，以迫使两者具有相同的uBE，使其ib相等，进而保证iC。\n输出电流支路，当负载一端可以接地时，称为地型，否则为浮型。当输出电流为流出电流镜时，称为吐型，当输出电流流入电流镜时，称为纳型。\n\n\n厄利电压理想与现实总是差距很大，我们上面的分析都是在理想晶体管的前提下进行的，理想晶体管严格遵从，输出伏安特性曲线是一条直线，我们知道实际晶体管的伏安特性曲线是倾斜的，随着Uce增加，Ic也会增大。\n仿真中画出以下电路图：\n我们把R1看做控制对象，改变电阻的大小观察输出端的电流大小，理想情况，晶体管工作在放大区情况下输出端电流不会发生改变\n\n这个是仿真软件里面的理想晶体管\n下图是一个实际的管子：\n可以看到尽管在放大区，电流依然在减小。\n厄利电压——early voltage，描述的就是晶体管输出福安特性曲线的倾斜程度，美国工程师James M.Early发现每根输出福安特性曲线向左的延长线都会在横轴上一个负电压相交。\n这个电压取绝对值记作VAF\n\n\n其中rCE代表晶体管输出伏安特性中某根曲线的倾斜程度，越小越倾斜。其中定义，Ic0是饱和区与放大区边界的电流。\n当我们知道iB，就可以确定一根伏安特性线，也就确定了iC0，最后确定rCE:\n\nMOSFET组成的电流镜MOSFET门极没有电流，如果两个管子相同则，并且增强型MOSFET的开启电压一般比BJT的UCES=0.3V大，所以门极电位要高一点。\n\nMOSFET也有厄利效应，即UDS变化会影像输出电流。输出电流表达式为：\n\n其中表征输出伏安特性的倾斜程度。\n比例电流镜比例电流镜是电流镜的一种变体，它依靠R1和R2之间的比例关系，决定输出电流iout与输入电流i1的比值。\n\n工作原理：\n恒流源IS1迫使T1经过5mA电流，所以电阻VF2电压必然等于5V，恒流源会主动改变T1管子的G极电压，迫使ID1 = 5mA，此时T1、T2管子的G极电压相同，如果两个管子的福安特性曲线相同且R2=R3，那么输出电流Iout = Iin，改变R2、R3的比例则输出电流比例也会改变。\n分析：\n\n使用仿真软件得到MOSFET的转移特性曲线，将数据导出excel中，对其实施多项式拟合，得到曲线方程表达式。即得到管子的K、UGSTH等参数。\n\nR1上的电压必然是5V，根据算出的转移特性曲线可以得到Ugs、Ug1。\n\n管子T2满足转移特性曲线和实现方程：可求得iD2\n\n\n图解法分析：\n\n深蓝色曲线是MOSFET的专业特性曲线，红色直线是斜率倒数为R1 = 1000Ω，这是T1管满足的直线方程，与横轴交点为UG，两个管子门极电压相同因此，固定此点不变，改变斜率倒数为R3 = 500Ω，图中为绿色直线，是T2满足的直线方程。\n可以看出，R3越来越小，P2点会越来越高，电流越来越大。这种比例是近似的，因为伏安特性曲线毕竟是一个曲线不是直线。\nWidlar 电流源主要用在运放输入级中，一般输入级需要设置很小的集电极电流或者发射极电流，前述设计的电流镜需要使用较大的电阻。集成电路中制作大电阻比较困难。\nWidlar 电流源，也叫微电流源。他在上述电路基础上给输出晶体管增加了一个小电阻形成的。\n\n分析：\n\n根据晶体管福安特性曲线可得：\n带入两个管子：\n最后我们往往需求是已知iout，要计算RE的值。\n解得：\n举例——多路并联Widlar电流源要求：设计一个BJT组成的多路并联Widlar微电流源，供电电压为10V，电路中最大的电阻不能超过3KΩ，实现3路输出，电流分别为50μA，100μA，200μA。\n\n确定Rc并求解输入级电流iIN。\n 我们就把输入级电流越小越容易实现小电流。通过输入级回路可列出方程： \n\n输出级发射极电阻由上面公式确定：\n \n   仿真结果： \n\n\n威尔逊电流镜——Wilson Current Mirror上面讲的最基础的电流镜有两个缺点：\n\n输出电流是输入电流的β/（β+2）倍，与β相关。对MOSFET组成的电流镜没有这个缺点。\n\n输出级无法保持恒流，输出电流与晶体管的C、E压降密切相关，压降越大，输出电流越大。输出级一般有一个电压源，当负载电阻变化时，晶体管CE压降也会改变，从而导致实际输出不是恒流。\n\n\n\n改进核心是增加了第三个晶体管Q3，通过Q3的作用可以保证Q1和Q2两个晶体管的UCEQ非常接近，Q1是1.4V，Q2是0.7V，它们不再随负载电阻大小变化而变化，输出电流就会相对稳定。\n假设三个管子都相同，iB三个管子都一样。通过分析可得：\n\n\n输出电流会略小于输入电流，且两者误差约为，前述基础版电流镜输出电流误差远大于威尔逊电流镜。\n仿真如下：第一个图是基础版电流镜，控制负载电阻大小改变观察输出电流变化\n第二个图是威尔逊电流镜\n可以看到，改变负载电阻大小，只要管子工作在放大区，输出电流改变很小。\n四晶体管威尔逊电流镜在三晶体管的基础上增加第四个晶体管形成了4晶体管威尔逊电流镜\n注意这个分析过程，从Q3开始往下分析，其中Q1、Q2、Q3的UCQ是确定的不会随负载变化，不需要考虑厄利效应。对于Q4因为他与负载相连集电极电压随负载改变，所以要考虑厄利效应，它的ic=βib不成立。\n\nMOSFET威尔逊电流镜使用MOSFET管代替BJT管也可以形成威尔逊电流镜。注意：MOSFET没有门极电流，输入电流源的最低电位要很高，一般大于2倍的MOSFET开启电压UGSTH。\n\n把输入电流源换做一个电阻，T3管子有转移特性曲线和直线方程成立：\n\n\n解得：\n电流源的顺从电压和输出阻抗电流源一端为OUT另一端为COM，与负载连接的端子一定是OUT端，COM端则一般接固定电压源或者GND。\n顺从电压：电流源在保持输出电流在能够接受的范围内时，COM端和OUT端之间的需要的最小电位差，用绝对值表示。\n顺从电压越小越好，在相同的外部供电电压下，顺从电压越小，留给负载电阻的电压变化范围就越大。\n示例计算：P195\n恒流源 (Constant Current Source)一个电路或者器件的某个端子，在一定范围内的外电势作用下，能够流出或者流进恒定的电流，称为恒流源。一般来说有三类：1. 简易晶体管恒流源 2. 压流转换电路 3.  专用的恒流源\n下图是由PNP管组成的简易晶体管电流源。\n!\n可列出表达式：\n\n输出电流的设置主要靠RSET。这个电流源的顺从电压大约是1.4V（小有疑问？？？？）\n一般实际应用中，二极管三极管、电阻R1生产厂家已经产好，RSET靠用户设定。影响输出电流的还有外部供电电压VCC，负载电阻RL，以及温度。\n这个电流源对外部条件改变很敏感：\n\nVCC固定，温度确定管子IB确定，影响输出电流的只剩UCE，即输出电流的稳定性主要取决于晶体管的厄利效应。\n\n当负载电阻稳定，温度固定，VCC的增大将直接引起二极管工作状态的变化：电流变大，UDZ变大，导致晶体管IE变大，输出电流也就增大。UDZ的稳定性直接决定输出电流的稳定性。\n\n温度稳定性不高\n\n\n","categories":["硬件","模电"]},{"title":"模拟开关","url":"/2025/03/25/%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/","content":"模拟开关模拟开关是一个电子开关，用外部数字逻辑信号控制两个端子之间的电阻：导通时电阻极小、断开时电阻极大。\n模拟开关类型包括单刀单掷、单刀双掷、双刀单掷、双刀双掷型。\n刀：指一个信号控制的一个开关实体掷：电极杆可以投掷的位置，单掷就是开关只有断开或闭合，双掷是开关有两个方向断开或闭合。\n\n单刀单掷：Single Pole Single Throw——SPST\n单刀双掷：Single Pole Double Throw——SPDT\nBJT模拟开关电路图如下，电源需要正负电源供电，这两个晶体管一个是NPN管另一个是PNP管，它们并联在一起。两个开关就看做一个GPIO口的控制信号，两个开关同时打开或者关断。\n\n模拟开关导通时，T1管和T1管均是饱和导通状态，输入信号通过两个晶体管并联（更小的导通电阻），连接到负载。\n模拟开关截止时，T1、T2处于截止状态。\nMOSFET模拟开关按照模拟开关的特性，我们使用一个MOSFET或者晶体管就可完成，它们本来就是一个“开关”。\n\n当开关导通时：\n\n当RL与RDS相近时，输出电压会有衰减。\n\n导通时的RDS与UGS有关，而UGS会随着输入信号改变而变化，输出电压也会随之变化。\n\n\n我们往往想让模拟开关输出电压稳定，也就是让它的RDS稳定。这用一对互补MOSFET（CMOS）即可。\n\n此时的导通电阻RDS：\n\n可以看到RDS比较固定，所以输出电压也会相对稳定。\n负载开关负载开关是一个可控制的开关，它能决定是否给某个指定负载供电。例如：手机中GPS功耗较大，实现低功耗要让GPS在需要时工作，不需要时关闭。\n单晶体管负载开关当被控制的VIN与LOGIC IN 高电平属于一个电压系列时，比如都是3.3V，使用一个PMOS就可以实现负载开关。\n双晶体管开关在更多情况下，被控制的电压VIN远大于微控制器的逻辑电压，比如VIN = 20V，逻辑电平为3V，如果还是用单晶体管开关，能实现导通无法实现截止。\n\nQ1管导通与否取决于R1上面的压降，R1上压降大于PMOS管的UGSTH绝对值时他就会导通，只要流过一定电流，Q2管子正好控制流过R1管子的电流，只需我们控制Q2的栅极即可。\n","categories":["硬件","模电"]},{"title":"晶体管产品","url":"/2025/03/27/%E6%99%B6%E4%BD%93%E7%AE%A1%E4%BA%A7%E5%93%81/","content":"晶体管产品常见公司生产晶体管：\n安森美 ON Semiconductor [http://www.onsemi.cn/PowerSolutions/home.do?lctn=header]\n飞兆半导体（仙童） FAIRCHILD [https://www.fairchildsemi.com/]\n意法半导体 STMicroelectronics [http://www.st.com/web/cn/home.html]\n达尔科技 DIODES [http://www.diodes.com/index.php]\nIR  [http://www.irf.com.cn/irfsite/tac/tac.asp]\n英飞凌 INFINEON [http://www.infineon.com/cms/cn/?ic=0003001]\n具体幸好和参考单价，可以访问e络盟官网：[http://hk.element14.com/]\n数据手册查询网站 ：[https://www.alldatasheet.com/]\n虽然一般我都是在淘宝买翻新、盗版（做产品千万不要图便宜买这些！！！！！），淘宝的优信电子还可以。\n达林顿晶体管（Darlinton Transistor）达林顿管是由两个晶体管在内部实现连接，对外是3个脚的晶体管组和形式。他也有两种NPN和PNP型。\n\n由图可看出第一个管子的发射极电流充当了第二个晶体管的基极电流，因此第二个晶体管的发射极电流将是第一个晶体管积极电流的倍。因此达林顿管具有极高的电流增益。同时按照这种连接可以形成极高的输入阻抗。\n主要应用：\n\n输入电阻较大的第一级放大电路\n驱动大电流负载执行低速开关动作（数字电路提供的输出电流一般有限，使用这个管子放大输出电流可以驱动大电流负载）\n\n匹配对晶体管 （Matched Pairs）匹配对晶体管集成在一个单片内的两个晶体管，具有相似的特性。一般可做到相差10%以下，甚至1%以下。\n\n偏置电阻晶体管减少设计中使用原件数量，降低占用面积，将外部的电阻和晶体管集成到一个管子中，如图，称为偏置电阻晶体管，也叫数字晶体管。\n\n负载开关负载开关在前面的笔记中有原理详解，这里介绍的是负载开关模块。\n\n两个晶体管一个作为主管，实现负载开关功能，另一个管子是辅助管，负责主管的通断控制。\n稳流晶体管也被称为横流调节器（Constant Current Regulator），或者LED驱动器。\n\nR1约为4.7KΩ，R2约为47KΩ，外部电阻RC可以选为100KΩ附近。这个器件的工作原理是：当Rs顶部连接至7管脚时，7管脚也连接至Q2的基极，所以Rs两端的电压也是Ube两端的电压。所以可得\n只要我们知道Ube，即可算出ILED。\n这里是一个负反馈电路，由MOS管的转移特性曲线可知，电流大小ILED与UGS有关，而电流大小通过RS和UBE与RC上的电流联系在一起，进一步影响UGS，最终使得输出电流稳定。\n还有一种产品，他只有两个管脚，A和K，串联在电路中，就能保证留过他的电流是器件指定电流。用户只用保证电源电压减去LED组消耗的电压满足器件电压规定即可。\n\n","categories":["硬件","模电"]},{"title":"晶体管产品","url":"/2025/03/27/%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E7%9A%84%E9%A2%91%E7%8E%87%E5%93%8D%E5%BA%94/","content":"晶体管放大电路的频率响应容抗和感抗在电路中学过电容的容抗和电感的感抗，回顾表达式：\n\n它们不消耗功率，在电路中同电阻一样，起到了阻碍电流的作用。低频段，电容容抗大，电感感抗小。\n在实际中，任何一个实体元件都存在寄生杂散（杂散电容或者杂散电感），它们在信号频率很高时呈现出来，是由于器件本身固有形状、尺寸、介质等产生的。\n任何一根导线，都存在电感，任何两个导体之间都存在电容。因此，寄生电感串联于宿主，寄生电容并联于宿主。\n对于晶体管来说，三个管脚之间存在寄生电容，晶体管PN结也存在寄生电容，一般情况下，外部寄生电容远小于内部寄生电容。\n\n在频率较低时，一般不会影响放大电路性能。但在频率较高时，对放大电路影响明显。\n放大电路的频率响应放大电路对不同频率的交流输入信号表现出不同的性能：1.幅频特性 2.相频特性\n频率特性图幅频特性与相频特性\n\n中频区：不考虑电容、电感存在时的，增益相对较为平坦的频率范围，增益用Am表示。(低频段、高频段都不是一个确定的范围，都只是相对而言)\n上限截止频率fH：从中频区开始向右，增益随着频率上升下降到中频区Am的0.707倍时，此时的频率用fH表示。\n下限截止频率fL：从中频区开始向左，增益随着频率上升下降到中频区Am的0.707倍时，此时的频率用fL表示。\n用dB表示时，截止频率在Am下降3dB处：\n阻容基本单元的频率响应低通基本单元\n输入输出关系如下：\n\n其中增益是一个复数，其中时增益的模，是幅角，表示输入输出相位差。\n设，为特征角频率，则有：\n\n仿真曲线如下：\n\n根据上述定义我们可以知道，当时，衰减0.707，所以就是上限截止频率。\n高通基本单元\n同理我们分析可得：\n就是下限截止频率\n\n两极判断法第一极：0Hz时，求此时电路增益用A0表示。第二极：频率为∞时，求解此时电路增益用A∞。\n判断规则：\n\n如果A0为有限值，A∞为0，则一定是一个低通滤波器\n\n如果A∞为有限值，A0为0，则一定是高通滤波器\n\n除此之外什么都不是，既不是低通也不是高通\n\n\n低通变形第一种：\n这种电路可以把两个电阻串联起来，就与低通基本单元一样，因为决定上限截止频率是表达式的分子和分母的结构，这两种电路的分母分子结构一样。截止频率不变。\n\n第二种：\n分析类似第一种，增益模值不同，但是上线截止频率相等。\n结论： 在一个电压源阻容串联回路中，如果从任何一个电容两端电压为输出，他一定是一个低通电路，上限截止频率为1/2πRC，R为串联电阻之和，C为电路中电容串联。\n第三种：\n可以利用戴维宁定理或者电路分析里面电流源等效电压源转换成上述电路。\n高通变形与低通分析类似，略。\n基本单元串联将多个低通模块串联，最终仍是低通效果。将多个高通模块串联，最终仍是高通效果。中频段增益。\n截止频率就复杂一点，简化处理：\n\n低通串联中  \n\n高通串联中  \n  \n  细致分析：  \n    \n\n\n\n串联级数\nK最小值\nK最大值\n\n\n\n2\n1\n1.099\n\n\n3\n1\n1.133\n\n\n4\n1\n1.148\n\n\n5\n1\n1.159\n\n\n\n低通串高通  fH&gt;fL，最后表现为一个带通环节。\n  \n\n\n晶体管放大电路非杂散频率响应看回最简单的NPN单管共射极放大电路\n\n图中这三个电容会影响放大电路频率响应，C1和C2作用是阻低频通高频，这是下限截止频率fL，CL通高频导致输出端高频信号减小，这是上限截止频率fH。\n这是非杂散电容对电路的影响，我们还没有考虑晶体管内部和管脚上的杂散电容，在晶体管高频等效模型中，存在3个结电容，会降低放大电路增益。再加上考虑到管脚上的寄生电容，信号频率升高增益会成倍数降低。这里暂时先不考虑。\n下限截止频率\n可以看出等效电路分成三个模块，三个模块级联关系如下图：\n\n其中\n\n因此，求解电路整体的下限截止频率，需要知道每个模块的下限截止频率，这样就可以利用上面的结论。\n单独分析每个模块\n\n模块1：\n  这个电路是基本高通单元的变形，可以写出表达式  \n\n模块2：  就是一个电流放大器，它不受频率影响，因此下限截止频率为0。  \n\n模块3：  使用电压源串联电阻代替电流源并联电阻（戴维宁等效），上面的高通电路变形。\n\n\n上限截止频率分析上限截止频率时，C1和C2看做短路，电路如图所示。\n\n类比低通电路变体，可得：\n","categories":["硬件","模电"]},{"title":"ESP32中Cmake学习","url":"/2025/04/07/ESP32%E4%B8%ADCmake%E5%AD%A6%E4%B9%A0/","content":"Cmake用途在学STM32的时候用的是Keil软件，keil已经把编译链接集成在软件里了，所以操作起来非常简单。ESP32构建项目是一个复杂的过程，需要编译-连接-烧录，每一步都是用一个工具实现。\n\nCMake : 配置待构建的项目，告诉编译器.c&#x2F;.cpp文件和.h文件的位置。\nNinja : 用于构建项目\nesptool.py ：烧录.bin文件到芯片上\n\n在比较复杂的项目中，文件目录很多，不同的源文件之间的依赖关系也很复杂。Cmake工具可以帮我们很好管理各文件之间的依赖关系。ESP中的Cmake与原Cmake语法大致一样，我这里没有系统学习过Cmake，仅在做项目的过程中进行记录。\nESP项目结构\n\n顶层项目 CMakeLists.txt 文件：顶层项目 CMakeLists.txt 文件会导入 &#x2F;tools&#x2F;cmake&#x2F;project.cmake 文件，由它负责实现构建系统的其余部分。该文件最后会设置项目的名称，并定义该项目。\n\nsdkconfig配置文件：顶层项目 CMakeLists.txt 文件会导入 &#x2F;tools&#x2F;cmake&#x2F;project.cmake 文件，由它负责实现构建系统的其余部分。该文件最后会设置项目的名称，并定义该项目。\n\ncomponents目录：包含了项目的部分自定义组件，并不是每个项目都需要这种自定义组件，但它有助于构建可复用的代码或者导入第三方（不属于 ESP-IDF）的组件。（移植别人的项目时很重要）\n\n“main” 目录：它包含项目本身的源代码。”main” 是默认名称，CMake 变量 COMPONENT_DIRS 默认包含此组件，但你可以修改此变量。\n\n“build” 目录：存放构建输出的地方，如果没有此目录，idf.py 会自动创建。CMake 会配置项目，并在此目录下生成临时的构建文件。随后，在主构建进程的运行期间，该目录还会保存临时目标文件、库文件以及最终输出的二进制文件。此目录通常不会添加到项目的源码管理系统中，也不会随项目源码一同发布。\n\n\n这里只列出了M-heat项目中目前需要的文件，还有一些文件没有用到，等到以后用到再学。\n项目 CMakeLists 文件每个项目都有一个顶层 CMakeLists.txt 文件，包含整个项目的构建设置。\ncmake_minimum_required(VERSION 3.16)\ninclude($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake)\nproject(myProject)\n\n\ncmake_minimum_required(VERSION 3.16)必须放在文件的第一行，它会告诉 CMake 构建该项目所需要的最小版本号。\n\ninclude($ENV{IDF_PATH}&#x2F;tools&#x2F;cmake&#x2F;project.cmake) 会导入 CMake 的其余功能来完成配置项目、检索组件等任务。\n\nproject(myProject) 会创建项目本身，并指定项目名称。该名称会作为最终输出的二进制文件的名字，即 myProject.elf 和 myProject.bin。每个 CMakeLists 文件只能定义一个项目。\n\n\n可选项目变量\nCOMPONENT_DIRS：组件的搜索目录，默认为 IDF_PATH&#x2F;components、 PROJECT_DIR&#x2F;components、和 EXTRA_COMPONENT_DIRS。\n\nEXTRA_COMPONENT_DIRS：用于搜索组件的其它可选目录列表。路径可以是相对于项目目录的相对路径，也可以是绝对路径。\n\nCOMPONENTS：用于指定要构建到项目中的组件名称列表，默认为 COMPONENT_DIRS 目录下检索到的所有组件。使用此变量可以“精简”项目，从而缩短构建时间。请注意，如果一个组件通过 COMPONENT_REQUIRES 指定了它依赖的另一个组件，则会自动将其添加到 COMPONENTS 中，所以 COMPONENTS 列表可能会非常短。\n\n\n使用 cmake 中的 set 命令 来设置这些变量，如 set(VARIABLE “VALUE”)。请注意，set() 命令需放在 include(…) 之前，cmake_minimum(…) 之后。\n组件 CMakeLists 文件每个项目都包含一个或多个组件，这些组件可以是 ESP-IDF 的一部分，可以是项目自身组件目录的一部分，也可以从自定义组件目录添加。\n组件是 COMPONENT_DIRS 列表中包含 CMakeLists.txt 文件的任何目录。\n最小组件 CMakeLists 文件最小组件 CMakeLists.txt 文件通过使用 idf_component_register 将组件添加到构建系统中。\nidf_component_register(SRCS &quot;foo.c&quot; &quot;bar.c&quot;\nINCLUDE_DIRS &quot;include&quot; REQUIRES mbedtls)\n\n\nSRCS 是源文件列表（*.c、*.cpp、*.cc、*.S），里面所有的源文件都将会编译进组件库中。 \n\nINCLUDE_DIRS 是目录列表，里面的路径会被添加到所有需要该组件的组件（包括 main 组件）全局 include 搜索路径中。\n\nREQUIRES 实际上并不是必需的，但通常需要它来声明该组件需要使用哪些其它组件\n\n\n上述命令会构建生成与组件同名的库，并最终被链接到应用程序中。\n上述目录通常设置为相对于 CMakeLists.txt 文件的相对路径，当然也可以设置为绝对路径。\n组建依赖\nREQUIRES 需要包含所有在当前组件的 公共 头文件里 #include 的头文件所在的组件。\n\nPRIV_REQUIRES 需要包含被当前组件的源文件 #include 的头文件所在的组件（除非已经被设置在了 REQUIRES 中）。以及是当前组件正常工作必须要链接的组件。\n\n如果当前组件除了 通用组件依赖项 中设置的通用组件（比如 RTOS、libc 等）外，并不依赖其它组件，那么对于上述两个 REQUIRES 变量，可以选择其中一个或是两个都不设置。\n\n\n添加组件下所有源文件\n使用file(GLOB) 通配符\n # 组件目录下的所有 .c 文件\n file(GLOB component_sources &quot;*.c&quot;)\n\n # 注册组件（包含源文件和头文件路径）\n idf_component_register(\n     SRCS $&#123;component_sources&#125;\n     INCLUDE_DIRS &quot;include&quot;\n )\n\n\n使用GLOB_RECURSE通配符\n\nGLOB：仅匹配当前目录。\n\nGLOB_RECURSE：递归匹配子目录。\ncmake_minimum_required(VERSION 3.5)\nproject(your_project)\n\n# 包含 src 目录及其子目录下的所有 .c 文件\nfile(GLOB_RECURSE SOURCES \n    &quot;src/*.c&quot;\n    &quot;src/utils/*.c&quot;\n)\n\n# 添加可执行目标\nadd_executable(your_project $&#123;SOURCES&#125;)\n\n# 链接必要库（如 ESP32 的驱动库）\ntarget_link_libraries(your_project PRIVATE esp32)\n\n\n\n\n\n至此已经可以成功编译所需项目组件。\n","categories":["软件","ESP"]},{"title":"防反接电路","url":"/2025/05/26/%E9%98%B2%E5%8F%8D%E6%8E%A5%E7%94%B5%E8%B7%AF/","content":"电源防反接电路最近打算做一个电源项目，在之前做项目时做过简单的防反接电路，今天来总结一下。\n二极管防反接电路利用二极管单向导通的特性，把二极管串联到电源输入上，因为正向导通反向截止，所以可以实现防反接。\nMOS管防反接电路MOS管的导通内阻较小，很多是mΩ级，这样对电路的压降，功耗造成的损失特别小，所以使用MOS管对电路进行保护是比较推荐的方式。\nNMOS防反接如下图所示，前面的开关代表电源正接与反接。当电源正接时，上电瞬间，MOS管寄生二极管导通（方向S-&gt;D），S极电压约为0.6V，Ugs = v1-0.6 = 19.4V，增强型NMOS导通，电流通过沟道导通，不再经过寄生二极管。\n\n如果电源反接，NMOS的导通电压为0，NMOS截止，寄生二极管反接，电路断开，形成保护。\nPMOS防反接如下图所示，当电源正接时，上电瞬间，MOS管寄生二极管导通（方向D-&gt;S），S极电压约为4.4V，Ugs  =0-4.4 = -4.4V，PMOS导通，短路寄生二极管形成回路。\n电源反接，同理PMOS截止，不再形成回路。\n一般MOS管D极和S极的接入：通常使用N沟道的MOS管时，一般电流是由D极进入而S极流出，PMOS是S进D出，在这里的应用正好相反，通过寄生二极管的导通来满足MOS管导通的电压条件。值得注意，当MOS用作防反接开关时，会有漏电流，这个电流一般很小，在mA或者uA级，可以忽略不计。\n实际应用G极一般要串联一个电阻，为了防止MOS管被击穿，也可以加上稳压二极管。并且在G极可以并联一个电容，从而实现电路的软启动功能，即上电瞬间电压缓慢增加，对后级电路不会有较大的电流冲击，如果没有软启动，后级电路在上电瞬间可能由于较大电流而损坏。\n","categories":["硬件","模电"]},{"title":"运算放大器","url":"/2025/06/03/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/","content":"理想运算放大器理想运放如图所示，有两个差分的输入端U+和U-，一个单端输出端Uo，具有下列关系：\n\n理想运放有以下特点：\n\nAuo足够大，一般用∞表示。下限截止频率为0，上限截止频率为∞。\n两个输入端均具有无穷大的输入阻抗，即流进或者流出U+和U-电流始终为0。\n输出阻抗为0。\n始终遵循上面的等式。\n\n理想运放的负反馈电路我们一般不会用增益无穷大的运放去直接放大一个信号，科学家研究发现，仅需几个电阻就可实现放大电路增益可控——通过添加一个负反馈网络。\n\n\n\n当趋近∞时：\n反馈在电学系统中，将输出信号通过某种方式，回送到输入环节，和原输入信号合并形成净输入信号，或者单独作为输入信号，进而影响输入输出性能的举措，称为反馈。\n正反馈和负反馈当输出信号发生某个方向的变化，此称为变化根源。变化根源回送到输入端后，会再次引起输出信号变化，此称为二次变化。如果二次变化与变化根源具有相同的方向，则属于正反馈。如果二次变化与变化根源具有相反的方向，则属于负反馈。\n环路极性法判断正负反馈\n找到反馈环路\n\n在反馈环路中任意确定一个节点A\n\n在节点A处假设存在一个正的变化量，用+表示\n\n沿着反馈环路，让这个变化量依次行进，每过一个关键节点，对变化量方向进行判断并标注，用+表示正变化量，用-表示负变化量，用0表示没有变化量。\n\n等这个行进过程再次回到A点时，如果变化量仍是+，则表明反馈的作用是赞成初始的变化，起到了推波助澜的作用，属于正反馈。如果变化量为-，则表明反馈的作用是反对初始的变化，起到了唱反调的作用，属于负反馈。如果变化量为0，则表明反馈环路被打断，不存在反馈。\n\n\n下图为常见器件的传递\n注意：共射极电路的输入是基极，输出是集电极，两者反相，共集电极电流的输入是基极，输出是发射极，两者是同相的，共基极电路的输入是发射极，输出是集电极，两者是同相的。\n书中有许多例子，可以看看，这里不做解释了。\n负反馈放大电路的方框图分析法\n\n : 开环放大倍数\n\n : 反馈系数，一般来说由纯电阻分压组成，不随频率变化，在这里是通式。\n\n : 衰减系数，指输入信号多少倍，进入放大器的输入端。\n\n : 输入信号\n\n : 减法器\n\n\n由方框图可得：\n\n解得闭环增益为：\n\n\n在电路中求解和:\n利用叠加原理，计算时仅考虑输入，计算仅考虑输出的影响。\n它的含义是，在不考虑输出回送的情况下，单纯的输入信号，有多少加载到了运放的输入端上——运放的正输入减去负输入。它的含义是，在不考虑输入的情况下，单纯的输出信号，有多少加载到了运放的反相输入上——运放的负输入减去正输入。\n例题2：\n\n判断电压与电流反馈\n拔掉/短接RL\n输入UI随之变为0\n为电流/电压反馈\n\n负反馈对放大电路性能的影响\n对增益稳定性的影响：\n \n 即闭环增益的相对变化量，是开环增益相对变化量的倍。\n\n大幅度提高上限截止频率\n 假设开环放大器类似一阶低通滤波器，表达式为：\n $$\\dot{A}{u0} = A{u0m} \\frac{1}{1 + j \\frac{f}{f_H}}$$\n 为开环增益 为上限截止频率\n 将表达式带入闭环增益中可得：\n \n 这个新表达式可以看出闭环中频增益约等于\n 上限截止频率为原来的倍\n\n大幅度降低下限截止频率\n\n对输入电阻的影响：如果核心放大器有两个输入端和一个输出端，且输入信号为单端输入。那么，对负反馈电路来说，当输入信号和反馈信号加载到相同的一个输入端，则称这种反馈为并联负反馈。当输入信号和反馈信号分别加载到两个不同的输入端，则称这种反馈为串联负反馈。\n 串联负反馈能大幅提高输入电阻。\n\n\n看下面示例电路\n\n下面的电路与上面的电路输出几乎没有差别，都是把输入信号放大了10倍。\n但是他们的频率特性相差十分大，下面的这个电路上限截止频率比上面的电路低很多，原因就是这两个电路的和不同，它们比值近似相同。\n而下面这个电路一般用在比较两个运放的失真性能，当处于深度负反馈时，运放的失真被减少的很小，而下面的电路能够将失真放大，从而比较不同放大器的性能。\n","categories":["硬件","模电"]},{"title":"运放电路分析方法","url":"/2025/06/05/%E8%BF%90%E6%94%BE%E7%94%B5%E8%B7%AF%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/","content":"运放电路分析方法虚短虚断法示例1：T型反馈比例器\n利用虚短虚断法（如字面意思，无电流流入，输入两端电压相等）可解得：\n假设把R1=R2=R3=100KΩ，RSET = 1KΩ，带入上式可解得uo = -102ui\n在tina中仿真得到\n\n这个电路优点在于通过改变Rset就可以得到大的增益，而使用基本的反向比例放大电路，当增益越大时所需电阻就越大，大电阻会引入噪声和成本。\n示例2：加法器\n\n同相加法器\n  使用叠加原理求U+的电压，可以发现电路就简化成最一开始学的同相比例放大电路。\n  \n\n反相加法器\n  \n\n\n示例3 ：减法器\n使用虚短虚断分析电路可解得：\n缺点\n\n输入电阻较小\n增益调节需要两个电阻同时变化\n对电阻的一致性要求很高。在实际应用中，要保证上下两路相等，对电阻精度要求很高。\n\n基于此，许多运放厂家生产了集成差动放大器，解决了第三个问题。\n当基准源不为0时\n利用叠加原理\n\n仅有u1输入时：  \n\n仅有u2输入时：  \n  \n\n当仅有VREF输入时，与仅有u2输入类似：  \n  \n\n\n最后得：\n这个电路在实际应用中十分重要！！！！\n下面对书中AD8275实现的电平移位电路进行仿真\n\n左图下面电路使用戴维宁等效，等效电路等于右图。而右图这个电路就是上面讲的三输入减法器。\n\n可以看到输入信号-10V-10V变为0-4V范围变化，即实现了衰减且移位。\n例4：三运放仪表放大器由减法器缺点1改善而来的器件，它具有两个高输入电阻的差动输入端，输出为两个输入端电位差的指定增益倍数。它的输入输出关系，与减法器相同，均为：    \n\n此电路增益表达式为：\n\n它的输入端是高阻，即输入电阻接近无穷大\n\n它的增益通常是一个电阻调节\n\n彻底解决了减法器的三个缺点\n\n\n整体表达式：\n例5：双运放仪表放大器\n推导十分复杂，有两种方法 1.叠加原理 2.直接推导（利用KVL,KCL）\n这里只给出输入输出表达式：\n\n例6：压流转换器（恒流源）\n左图RL在电源端接法：\n右图RL可以接地：\n\n缺点：\n\n电压与电流时反向的，当设定电压增加时，电流减少，不符合常识操作\n\n受电源纹波影响较大\n\n\n例7：Howland电流源\n这个经典电路解决上面电流源的缺点。\n当不接入负载电阻的时候可以看出电路的正反馈系数，与负反馈系数完全相同：\n\n当接入负载电阻时，，显然比负反馈系数小，所以电路最终工作在负反馈状态，可用虚短虚断分析。\n最终可得：\n缺点：\n\n对元件匹配精度要求极高（类比减法器的电阻网络）\n使用集成差动运放无法接成，因为一般这个管脚不引出\n无法输出大电流，运放输出电流有限\n\n例8： 利用集成差动放大器实现的压流变换器\n这个电路是howland电流源改进，可以使用集成差动放大器接成。这个电路也有个一个弊端，R1需要匹配，这也很不好。\n推导原理首先判断负反馈成立，然后使用虚短虚断求解：\n\n再次进行改进\n\n输出表达式：这个电路仅需要一个R1，这个电路也有缺点引入的这个运放会导致高频性能下降。\n大电流扩流\n\n引入的这个管子对运放电路分析没有影响，把电源里的电流引入扩大负载电流。\n例9：使用集成仪表放大器实现压流转换器当需要输入电阻很大时，我们可以利用仪表放大器特点（高输入阻抗），采用集成仪表放大器实现压流转换。\n\nAD620输出表达式为：\n\n在利用AD705射极跟随器虚短虚断可得：\n\n注意：此电路不能使用扩流思想\n例12 光电放大器电路图：\n图中的运放为单电源供电，左边的光电二极管作用是把外部的光强转化成电流信号。BF862是一个JFET，UGS(OFF) = -0.8V，IDSS = 10mA，求出电压与流过光电二极管电流的关系。\n分析步骤：\n\n判断静态与电源供电，由于现在是单电源供电，供电电压5V，所以运放正常工作电压范围是0~5V，我们选择一个合适的静态点就是2.5V，处于中心位置。所以，运放同相输入端，5V电源经过两个电阻分压电位为2.5V，并联的这个电容是滤波作用。\n\n反馈极性判断， 输出电压VOUT经过反馈电阻到源极跟随器的门极，由前面的知识可知，G、S两端电压极性相同，S极接反相输入端，所以这个反馈是负反馈（F&lt;1,AF&gt;1），满足虚短虚断条件。\n\n利用虚短虚断可知，S极电压约为2.5V，所以IS = 2.5mA。由JFET伏安转移特性公式可以算出UGS，即可得G电电位为2V。\n\n光电二极管伏安特性曲线\n \n 我们在这个电路中使用二极管反向伏安特性，当没有光照的时候会有暗电流，数量级pA~nA。\n 由于JEFT的GS极之间阻抗很大，几乎没有电流流入，所以光电二极管产生的电流全部来自RF可得:\n \n\n\n仿真结果\n\n当光电二极管电流为1uA正弦波，根据计算公式可得VOUT = 2±0.1V\n\n大运放法一些看似十分复杂的电路，如果能将其分解为一个多级高增益放大电路和反馈网络的集合，可以将其中的多级高增益放大电路，用一个大运放代替。\n例1 串联复合型放大电路\n我们只看输入端与输出端可以把上面这个电路等效为下图\n\n这是一个经典同相比例器，增益为100倍。\n我们再看这个大运放内部，AD8603的输出端接到第二个运放的同相输入端，这个运放的接法也是100倍同相放大。所以大运放内部第二个运放的作用是将AD8603的开环增益增加100倍。\n为什么要这样做？这样做是为了拓宽AD8603的频带，因为AD8603的输入特性很好，但是缺点是带宽比较窄，开环增益增加100倍，相当于幅频特性向上平移40db（dB单位）。\n\n测量运放开环增益我们知道一个运放的开环增益很大，输入只要有一个很小的直流量（失调电压），输出必定被憋死。那我们如何测得这个开环增益呢？一般来说我们去搜这个运放的芯片手册，手册上有写这个开环增益。我们想在仿真软件中测得，使用下面的方法。\n\n这个电路测量思想也很巧妙，我们已经知道运放的这个特性，想在测开环增益时不放大输入端的直流量，使用一个大电感连接输出端与反向输入，即通过负反馈作用让运放的输入电压即失调电压等于输出电压，输出的直流电位被限制。而在测交流电压时我们需要让运放开环增益施加在这个交流量上。图中电容和电感的作用刚好满足我们的需求，即大电感阻交流通直流，大电容通交流阻直流。\n通过示波器可以看出\nVF4端有10uV的失调电压，VF2端也有10uV的失调电压（直流偏移量），并且输出没有憋死。输入电压为1uV正弦波，输出约为25mV正弦波。\n幅频特性\n\n下面的线即是OPA277的开环增益图，可以看到在1MHZ时增益为0。上面的曲线则是左边增加一个运放扩展频带后的增益曲线，可以看到带宽被拓展。\n注意：此拓展带宽的方法实际中极不稳定！！！！！！！！！！\n例2 多级含负反馈BJT放大电路\n这个电路十分复杂，如果我们使用前面晶体管章节的知识来解电路的静态、动态，能给人算死+累死，所以换种方法分析就能简化。\n我们先把反馈环路去掉不看，这个电路为三级放大电路，第一、三级电路为共射级放大电路，第二级是共集电极放大电路。信号加载第一个管子的B、E极之间，所以我们就把A点和B点（反馈环路正好也接回这个点）看做运放的+、-端。\n电容在信号频率较大时看做短接，使用环路极性法能够分析A点引起的正变化，经过多级放大电路输出也为正变化，同理B点的正变化引起输出负变化，所以前面A、B为+、-端假设没错。\n接着我们加入反馈环路，可把电路简化为：\n增益可以求得：\n\n我们想一下虚短虚断是否成立？\n虚短：我们一般分析闭环增益考虑不是静态值，而是动态的信号。当动态时，A点电压变化量与B点变化量大小差不多。\n虚断：流入A端电流很小，我们只用看是否远大于就行，因为输出端电压远大于，RF与C1属于同一数量级，是远大于的。\n仿真结果\n\n输出放大100倍\n\n例3 多级含负反馈差动放大电路电路如图所示\n这里需要复习一下差动放大器的一些知识，我们一点点分析这个电路，因为这个电路基本上就是运放内部的电路，学会这个电路能够加深对运放的理解。\n首先判断正负输入端：\n我们从差动放大输入端看进去，同相输入端最后引起输出电压升高，反向输入端引起电压降低，还要注意一点输入端两个信号是反向的。\n正负输入端知道了我们来看是否负反馈，输出端经过一个电阻接到反向输入端，这个电路很容易看出来是一个标准同相比例放大电路。\n使用大运放法已经分析完毕。\n接着我们来分析内部电路\n第一级差动放大电路，上下两端都用了一个恒流源代替RC和RE，原因我们之前讲过（差动放大器章节），恒流源负载具有静态电阻低，动态电阻大的特点。动态电阻大能够显著提高增益并且维持静态工作点不变（与接一个同阻值的电阻相比）。\n第二级是由第一级差分放大电路的单端输出接到一个PNP管组成共射放大电路，后一级再接一个射极跟随器，但这种形式我们貌似没有见过。\n先看下面这个电路的区别\n左侧是恒流源负载代替右侧普通单管放大电路。我们知道之前学的两部件串联图解法，我们把这两个输出特性曲线图都画出来。\n在TINA中使用直流分析，控制VF5的电压，看T11和T10的IC电流就能画出曲线图。\n\n下面这个图是左边恒流源的输出特性曲线\n可以看到两个曲线的交点在5V处，因为这个电路的静态工作点是我们刻意调的，上面这个红色曲线斜率就代表RC\n下面这张图是源电阻接入的曲线\n可以看出恒流源电路的动态电阻远大于普通电阻。电路增益被极大提高。\n回到第二级电路，忽略两个二极管，我们发现这个接法就很熟悉了，下面的NPN管做为恒流源提高增益，上面PNP管是红色曲线，微小改变它的基极电压，这个红色曲线会上下移动，由于绿色曲线斜率很大，导致在很小的电流变化范围内，电压变化巨大。\n第三级是互补推挽电路，作为射极跟随器做输出端（输出电阻小，增益为1），NPN管产生正波形，PNP管产生负波形。\n如果我们不加这两个二极管，会产生下面的现象。\n输出产生交越失真现象，这是因为三极管BE极有0.7V的导通压降，所以在最后一级在&lt;-0.7,+0.7&gt;之间有一个死区，在这个区域内后级三极管不导通。\n我们加入两个二极管，使其在静态时让后级的两个三极管处于饱和导通状态，二极管的0.7V压降大约满足三极管的BE极压降。\n\n这个输出的交越失真就会被抵消，但是也不能保证完全抵消，因为不能保证二极管压降严格等于三极管BE压降。\n至此离分析完这个电路还差最后一点，就是在第二级的电容C2，为什么要加这个C2？此时还解释不了，只能说是为了提高电路稳定性添加，不然会产生自激振荡。后面再慢慢学。\n例4 基于光电耦合器的隔离放大电路光电耦合器简称光耦，由一个发光二极管和感光晶体管集成在一个一个密闭隔光腔内。晶体管集电极电流受控于二极管发光强度，这是核心原理。\n光耦一般用于数字信号的隔离传输，即两个系统之间的供电是没有电气联系的，相互浮空，能够耐受足够高的电位差，且信号能够在两个系统之间传递。这样做的好处是，保护后级、抵抗共模干扰、提高可靠性。\n由于发光二极管具有单向导电性和严重的非线性，直接使用光耦传输模拟信号是困难的。使用运放负反馈可以巧妙克服，如下图所示\n\n先用虚断虚短法解：\n判断反馈极性，对A1来说，输出信号通过两个发光二极管一个感光三极管接入同相输入，假设输出电压增加，发光二极管电流增加，三极管集电极电流增加，这个三极管接法类似共射放大电路，所以集电极电压减小，是一个负反馈。A2更不用说了，一眼同相比例放大。\n虚短成立，U3=U2=U1，先断开C1。由于OC1、OC2高度对称，加上它们都是共射极接法，所以，只要两个电源压差相同，那么两个管子的Uce完全相同。\n\n输出\n使用大运放法解：\n（暂时有点没懂）可将运放A1和0C2、0C1、T1和R2组成的整个电路视为一个大运放，由于增加的这些电路起到了反相作用，可将A1的正输入端视为负输入端，而负输入端为正输入端，这就是一个跟随器。\n电容C1作用是在高频工作下加快反馈通路的建立，因为光耦存在延时，高速下容易工作异常。\n环路方程法最一般最普通方法，不管什么电路用这个方法一定能解出。\n例1 单管含反馈放大电路\n环路方程法：画出电路的完整反馈环路，列出环路的全部节点方程然后求解。\n\n等效电路图\n列出b点和c点的节点方程求解（推导复杂略）\n例2 电流反馈型运算放大器\n还有一类运放是电流转电压型运放，正输入端是一个高阻输入、低阻输出的跟随器，跟随器输出阻抗为，上流过的电流i是核心输入，经过一个受控电流源，受控电流源内部经过一个很大的阻抗Z最终经过一个跟随器到输出端。\n找到环路列出方程，，，，\n整理可得：\n可以发现与CFA型运放类似，但是实际中不能随意替换。\n\nCFA有更好的频率特性，能实现高增益宽带放大，有较大压摆率。\n\nCFA不遵循“增益带宽积为常数”\n\nCFA电路对外部电阻要求比VFA严格\n\nCFA两个输入端结构完全不同，利用运放对称性做出的电路就不能用。\n\n频率特性上，在滤波器设计中，要更换运放为CFA，必须缜密考虑。\n\n\n","categories":["硬件","模电"]},{"title":"电流检测","url":"/2025/07/08/%E7%94%B5%E6%B5%81%E6%A3%80%E6%B5%8B/","content":"电流检测电路正好最近做的项目M-power中用到了，系统学习一下。\n分流电阻法检测电流的方法有很多种，这里我们暂时只总结分流电阻法。把一个阻值很小的电阻串联到负载中，通过检测这个电阻上的压降就可以算出流过负载的电流，因为这个电阻小（mΩ级），所以对负载引起的影响几乎没有。\n这种检测方法分为高端检测与低端检测：\n\n高端检测：实际应用中大多采用的方法，因为负载接地更能够提高系统的稳定性。这个电路有致命缺点，一般的运放供电电压达不到高压，所以当高端检测时共模电压会直接击穿运放。\n\n低端检测：负载的地不稳定，可能导致整个系统不稳定，所以这种接法不能使用。\n\n\n下面的分析全是采用高端检测法，实际项目和工程中我们一般用的都是集成电流检测放大器。\n仪表放大器实现电流检测仪表放大器的输入电压范围最大不能超过其供电电源范围。\n\n我们前面知道，仪表放大器的增益通过外部电阻RG可调，并且输入电阻很大，能够较为精确检测电流，而缺点就是无法测量高压系统。\n\n集成差动放大器实现高共模电压电流检测集成差动放大器有1：n型的，（我们通过正接或者反接可以改变增益，放大或者衰减）使用1：n型差动放大器实施衰减，可以大幅度提高检测电流时的抗共模电压能力。\n\n原因分析：在仪表放大器内部结构，它的同相输入端与反向输入端都是接的一个运放（3运放型、2运放型）。而集成差动放大器中通过电阻分压后输入到运放的输入端，此时电压经过衰减已经满足运放电源电压范围。\n在RSENSE很小的情况下，匹配电阻可以不加，而当RSENSE较大时要加上。\n这个匹配电阻是为了匹配电阻网络（差动放大器特性），我们从Vin+管脚看输入，利用戴维宁等效可得：\n\n所以当我们在Vin-管脚加上这个匹配电阻时，电阻网络匹配保证检测精确。\n此时可得：\n\n有点奇怪，我们需要把电压信号先衰减再放大，最后得到的值进行检测。这中间会引入很多噪声，所以它中间加了一个电阻，引出一个脚接外部电容做低通滤波。这是AD628的核心思想。\n另一个器件AD629可以实现对共模电压衰减不对差模信号衰减。\n\n仔细体会这个电路巧妙原理！\n正向输入端分析可得，电压衰减20倍，由虚短虚断可知，反向输入端电压电压电压等于13.5V。即共模信号被衰减20倍。\n使用叠加原理进行分析：\n当RSENSE远小于380KΩ，匹配电阻忽略不计。\n当只有U+输入时：\n\n当只有U-输入时很容易得：\n\n所以输出信号：\n仿真分析\n\n负载电流为10A时\n\n实在妙哉！！这个Rx电阻妙不可言。\n用普通运放实现高共模电压的电流检测\n这个电路用到了两个运放，检测电路的供电是0V和5V，检测电阻则是检测-48V下的电流。\n首先第一个运放供电电压是利用稳压二极管方案解决。选择稳压管时有两个参数需要注意，一个是击穿电压（稳压电压），另一个是击穿电流（限制功率）。为保证运放正常工作，需要提供一定电流。\n接下来分析反馈环路，判断是否为负反馈，我们可以看到第一个运放的输出端接MOS管门极，再由源极输出接回反向输入端，很容易判断是负反馈。（MOS管是源极跟随器）\n利用虚短虚断可得：\n\n即R2两端压降与RSENSE两端压降相同。\n 再看第二个运放的负反馈，很容易得出：\n \nC1的作用是运放电源滤波。C2作用是提高电路稳定性，因为场效应管门极有开启时间，这个电容的作用是让这电压快速达到开启电压。C3作用是滤波。\n仿真结果\n\n","categories":["硬件","模电"]},{"title":"积分电路","url":"/2025/07/07/%E7%A7%AF%E5%88%86%E7%94%B5%E8%B7%AF/","content":"积分器\n由虚短虚断分析可得：\n\n结合电容公式可得：\n\n实际应用理论上的积分器，在实际应用中很容易出现饱和。因为现实中任何运放都有输入失调电压、输入偏执电流。\n下面解释：\n\n\nVOS：是运放固有的输入失调电压，指一个运放输入端为0时，输出的静态电压，数量级为mV~uV。\nIB：两个端子存在的偏执电流，数量级为uA~pA。\n\nVOS会在反向输入端的电阻施加一个电流，电容上的电流分成两路，一路是电阻流出的电流，还有流入运放的IB。（方向不一定，也有可能流出）\n这两个持续的电流会使电容充电，很快使电容两端的电压达到电源电压以后不再充电。此时，虚短不在成立，经过电阻的电流全部为运放偏置电流。\n仿真结果\n解决方案：\n\n在电容旁边并联一个较大的电阻，这个电阻用来消耗电容的电压，使电容两端电压不再持续增加。\n\n电阻为100KΩ，C = 68nF，运放输入失调电压为1mV，输入偏执电流80nA，供电电压为±15V，进入稳态后，输出电压约为：\n\n积分器输出十分小，肉眼几乎看不出来，并且电阻越小输出失调也就越小。\n仿真首先测量在不加输入电压时，积分电路的直流失调量，电路图如图所示。\n\n我们这时接入1mV的正弦波，可以得到输出：\n\n可以看到输出电压有直流分量，这个直流量就是失调电压和偏执电流带来的影响。在直流状态下，这个电路可以看做一个反相比例器，直流分量被放大10倍，输出电压在17mV上下波动，并且输出输出间有相位差。\n\n\n在理想情况下，输入正弦波，输出电压有下面表达式：\n即：\n\n积分器输出波形为余弦波，相位超前90°\n\n积分器输出幅度为输入波形幅度的倍，与时间常数和输入信号频率有关。\n\n此公式为数学理论分析，C是常数。电路中取什么值，取决于瞬时分析。\n\n\n频率特性\n频率表达式：\n\n同时取对数表达时，AF = -f，即一条斜直线。我们从幅频特性曲线上也能看到，在频率较高部分幅频特性曲线近似等于直线。\n实际应用中我们在电容两端并联一个大电阻，导致幅频特性曲线有一些变化。理论上积分电路的幅频特性曲线在整个频段内都是一条斜线，这个电阻作用在低频段体现出来。\n我把电阻R2跳大至10MEG，把电容C调小至1nF，看幅频特性曲线：\n可以看出，这个曲线与之前学的低通滤波器比较类似，在低频段有一个固定的增益倍数，这个倍数就是反向比例器的放大倍数即，而过了低频段之后就是积分器的幅频特性曲线。\n","categories":["硬件","模电"]},{"title":"运放噪声","url":"/2025/07/14/%E8%BF%90%E6%94%BE%E5%99%AA%E5%A3%B0/","content":"运放的噪声参数噪声参数对于一个运放来说十分重要，尤其在小信号检测方面。\n噪声叠加噪声1： uN1(t)，有效值为UN1噪声2： uN2(t)，有效值为UN2\n总波形为：\n有效值：\n定义噪声有效值的平方为电能力，用E_p表示。\n\n噪声电能力密度噪声在低频到高频都有频率分量。\n单位频率噪声电能力：\n\n噪声电压能力密度：\n\n利用电能力可加性，在一个频段内（fa,fb）内，总的噪声电能力为噪声电能力在这个频段内的积分：\n\n在这个频段内噪声电压有效值为：\n\n白噪声：在某一频率范围内，具有不变的噪声电能力密度。\n\n当噪声源在某一频率范围内，其电能力密度随频率越来越小，具有1/f特性时（称为1/f噪声），其电能力表达式为：\n\n(有点绕)\n运放的等效输入噪声电压有效值数据手册中会给出噪声电压密度曲线\n黑色实线为噪声电压密度，它实际由上面说的白噪声和1\\f噪声叠加而成\n\n其中前面求得：\n白噪声\n1/f噪声\n因此只要知道频率fa,fb点就能求出噪声电压有效值。\n确定频率起点fa一般我们以0.1Hz为下限\n确定频率终点fb运放组成的放大电路都有上限截止频率fHf。\n\nUGBW为单位增益带宽积。\n而fb范围比上限截止频率要大，因为运放构成的放大电路一般为一阶低通滤波器，而不是理想的滤波器，一般选择\n\n一阶滤波器 p = 1.57\n设计举例这部分看书！！\n","categories":["硬件","模电"]},{"title":"运放参数","url":"/2025/07/11/%E8%BF%90%E6%94%BE%E5%8F%82%E6%95%B0/","content":"运放参数实际运放的等效模型，第一个黄色运放是一个理想运放除了Auo不是无穷大，其余都是理想的。第二个运放是理想的，作为电压跟随器。\n\n输入失调电压 VOS当运放两个输入端接地，由于图中VOS存在，经过Auo放大，输出电压必然不是0。在运放的负输入端施加一个可调节的uos电压使\n输入失调电压是任何一个运放都存在的，它来自于运放内部电路的电路结构以及非对称性，是难以从根本消除的。一般通用运放在mV，而精密运放可以达到10uV以下。\n输入失调电压，特别是输入失调电压温漂，对直流放大器硬性巨大。\n输入失调电压对电路的影响\n这是一个标准同相比例放大，增益101倍，当输入是一个5mV，1KHZ正弦波，输出应为505mV 正弦波，直流偏移量为0。\n实际波形\n我们可以看到一个200mV的直流偏移量，这就是输入失调电压对输出造成的影响，LM324输入失调电压2mV，经过放大后与理论计算差不多相等。这个输出偏移量叫做输出失调电压。\n\n如果我们接成反向比例放大\n\n\n信号放大倍，输入失调电压被放大\n可以看出同相反相比例放大对输入失调电压的放大倍数比例相同。\n数据手册\nLM324的输入失调电压典型值为3mV，最大值为7mV，即同一批LM324它的失调电压也不相同。\n\n这个典型值就是高斯分布中的方差。\n输入偏置电流 IB实际运放在除了失调电压外还有偏执电流，即运放不是真正的虚断，是有电流流入的。\n\n对于BJT组成输入级的运放，这个电流就是差动输入级晶体管基极电流IBQ，为差动输入级晶体管提供静态工作点，所以BJT组成的运放，输入偏执电流很大。场效应管组成输入级的运放，这个电流极低。\n输入偏执电流是正输入端与负输入端电流的平均值\n\n实际中一个运放的输入偏置电流不是固定不变的，它受多种因素的影响：温度、共模电压，数据手册中只给出了特定条件下的值。\n输入失调电流 IOS输入失调电流，是两个输入端静态电流的差值\n\n一般来说输入偏置电流与输入失调电流近似相等，或者维持在一个数量级。\n、、对输出失调电压的影响\n使用叠加原理分析：\n只考虑VOS时前面分析过：\n\n只考虑正输入端偏置电流IB+时：\n只考虑负输入端偏置电流IB-\n三项合并：\n\n根据前面的定义：\n\n决定输出失调电压大小有三个因素：独立的输入失调电压、以及相互有关联的偏置电流和失调电流、外部电阻。\n理论上来说，不改变RG和RF情况下，通过选择R_{MATCH}可以使代数和为0。但是，只要改变温度，这三个参数都会改变，所以理想很美好现实很骨感。\n降低输出失调电压的核心在于：\n\n选择输入失调电压VOS小的芯片\n\n选择输入偏置电流IB小的芯片\n\n选择小的外部电阻\n\n\n如果不能满足设计要求时，再加上匹配电阻。\n输入电压范围定义：保证运算放大器正常工作的最大输入电压范围，也称共模输入电压范围。\n一般运放的输入电压范围比电源电压范围窄1V到几V之间。好一点的运放输入电压范围和电源电压范围相同，甚至超出0.1V。这种运放我们叫做“输入轨至轨”，rail to rail(RRI)。\n输出电压范围定义： 在给定电源电压和负载情况下，输出能够达到的最大电压范围。\n一般运放的输出电压范围要比电源电压窄1V到几V。较好的运放可以与电源电压范围非常接近，比如几十MV的差异，叫做“输出轨至轨”。\n共模抑制比 CMRR定义：运放的差模电压增益与共模电压增益的比值用dB表示。\n一般运放有60dB以上，高级可达140dB。\n理想运放输入输出关系为：\n实际输入输出关系：\n\n同相比例器我们先看对同相比例器的影响\n\n\n\n\n当共模抑制比不是无穷大时，这个式子多了Ac项，Auf提高了，但影响不大，还是近似等于1/F。\n类似分析反向比例器，对其影响很小。\n减法器电路\n\n当CMRR为无穷大时（理想运放），此时电路输出为0，而CMRR不为无穷大，输出也不等于0。CMRR对减法器影响巨大。\n对减法器的影响有两个：\n\n运放本身的CMRR\n\n电阻的一致性\n\n\n开环电压增益 Auo定义：运放本身具备的输出电压与两个输入端差压的比值，用dB表示。它与频率有关，数据手册中一般会给出一个典型值（频率0HZ处），与一个幅频特性图，就拿我最近做的M-power项目中的RS8552（国产）放大器举例。\n\n一般情况下，说某个运放的开环电压增益达到100dB，是指其低频最高增益。多数情况下，很少有人关心这个参数，而去关心它的下降规律，即后续讲述的单位增益带宽，或者增益带宽积。在特殊应用中，比如高精密测量、低失真度测量中需要注意此参数。在某个频率处实际的开环电压增益，将决定放大器的实际放大倍数与设计放大倍数的误差，也将决定放大器对自身失真的抑制，还将影响输出电阻等。\n压摆率 ：Slew rate, SR定义：闭环放大器输出电压变化的最快速率。用V/us表示。\n这个值代表运放正常工作时，输出端所能提供的最大变化速率。当输出信号欲实现比这个速率还快的变化时，运放输出失真。\n对一个正弦波，变化率最大的点在过零点处（求导最大值），且与输出信号频率、幅度有关。\n\n要想输出正弦波，就需要\n\n单位增益带宽积定义： 运放开环增益-频率图中，开环增益下降到1时的频率。\n当输入信号频率高于此值时，运放的开环增益会小于1，这是衡量运放带宽的重要参数，一般不在数据手册表格中出现，需要自己根据图观察。\n增益带宽积：GBW定义：运放开环增益-频率图中，指定频率处，开环增益与该制定频率的乘积。\n如果运放开环增益-频率图是一个线性单调递减直线，比如频率提高10倍，开环增益变为原先的0.1倍，那么他们乘积为常数。\n-3dB带宽定义：运放使用闭环时，某个指定闭环增益下，增益变为低频增益的0.707倍时的频率。分为小信号（200mV）大信号（2V）两种。\n满功率带宽定义：将运放接成指定增益闭环电路，连接指定负载，输入端加载正弦波，输出为指标规定的最大输出幅度，在此状态下，不断增加输入信号频率，直到输出出现因压摆率限制产生的失真为止，此频率为满功率带宽。\n比-3dB更苛刻的一个限制频率。它指出在此频率之内，不但输出幅度不会降低，而且能满幅度带载输出。\n绿色线代表在满功率输出幅度下，信号斜率小于压摆率的情况，输出不会失真。\n红色线是频率较高，它的过零点斜率大于压摆率，最终造成输出失真。\n至稳时间定义：运放接成指定增益，从输入阶跃信号开始，到输出完全进入指定误差范围所需要的时间。\n至稳时间由运放的延迟、压摆率带来的爬坡时间、稳定时间决定，SR越大的至稳时间越小。\n\n电源电压抑制比定义：双电源供电电路中，保持负电源电压不变，输入不变，而让正电源产生变化幅度为△VS，频率为f的波动。那么在输出端会产生变化幅度为△Vout，频率为f的波动。\n\n电源抑制比，是运放对电源上纹波或者噪声的抵抗能力。随着电源电压变化频率的提升，运放对这个变化的抵抗能力会下降。一般情况下，电源变化频率在接近带宽时，运放失去对电源变化的抵抗。\n\n热阻定义：导热体阻值热量散失程度的指标，以1W发热源在导热路径两端形成的温度差表示，单位°C/W。有以下常用的两种：\nθJA: 芯片热源结与芯片周围环境的热阻。\nθJC: 芯片热源结与芯片管壳的热阻。\n热阻θJA越大，说明散热越困难，其温差也就越大。这个参数主要与散热\\功耗相关，芯片手册中也会说明，在正常工作状态下芯片能达到的最高温度。\n\n","categories":["硬件","模电"]},{"title":"运放电路的频率特性","url":"/2025/07/17/%E8%BF%90%E6%94%BE%E7%94%B5%E8%B7%AF%E7%9A%84%E9%A2%91%E7%8E%87%E7%89%B9%E6%80%A7/","content":"运放开环增益简化表达运放的开环增益是随频率变化而变化的，我们之前在数据手册中看过。\n运放开环增益可以表达为：\n\n模代表幅频特性：\n\n幅角代表相移：\n\n简化开环增益我们之前学过方框图法解负反馈电路，反馈系数F，衰减系数为M，闭环与开环增益的关系式\n \n当开环增益很大时，分母的1可以省略，即闭环增益与低频处的开环增益无关。\n简化：\n\n最终简化我们在厂商给的数据手册中最经常使用的是GBW、UGBW，根据GBW定义可得\n\n如何求 -ydB带宽？一个放大电路，M、F已知求-ydB带宽。\n根据定义：\n单位dB\n可得\nAufm为中频带增益。\n将简化的开环增益表达式带入闭环增益中，可得模和相角\n\n所以可得：\n\n即-3dB带宽。\n注意：这两个表达式在超过fHf后最好不要再使用。因为实际运放曲线在接近UGBW时已经不再是一条直线，不能用简化模型表达。\n上面的式子联立可得：\n\n上面这个公式在已知反馈系数情况下，能够求得任意衰减dB下的带宽。\n举例：\n反向比例器\n1.求解系数：从电路可以看出 ，\n2.阅读芯片手册得到增益带宽积GBW\nGBW = 10MHZ\n3.根据公式计算\n即可以算出-1dB带宽，这个值表示在输入信号频率小于462.6kHz时，可以保证闭环增益在-8.9125 - -10倍。\n负反馈放大电路产生自激振荡的条件运放组成的负反馈放大电路，当开环增益Auo和反馈网络本身的相移为0°时，整个环路永远是负反馈。但是当环路整个的附加相移φA+φF = -180°，原本的负反馈会变成正反馈。\n除了相位条件外还需具备幅度条件，整个环路增益必须大于1，才能使得很小的信号越来越大。即：\n理论与实际上面的分析是电路产生震荡的理论依据，我们经常发现理论与实际不符，理论上不会出现震荡的放大电路，实际做出来之后，它出现了自激振荡。\n原因：实际电路中存在杂散电容。\n\n同一层的两个相邻节点间。比如某根信号线，和周边的覆铜 GND 之间，以及和周边的焊点之间。\n\n不同层上下之间。比如元件层的线，和焊接层的大面积 GND 之间。\n\n器件的两个管脚之间。\n\n\n如何避免?\n选择合适的增益，选择合适的增益电阻\n\n对于任意一个选定的运放，在它能够实现的最小增益基础上，适当提高闭环增益，可以有效提高系统稳定性。\n增益电阻尽量选择小的，降低反向输入端CIN-的作用。\n\n设计PCB时，尽量减小杂散电容，特别是CIN-。\n\n铺铜这个操作，本质目的是增大地线面积，进而减小地线电阻和电感。但是铺铜也会带来两个问题：第一，它与同层信号线之间形成了很长很长的近距离间隙，即大电容。第二，与其他层信号线形成了层间电容，这些杂散电容，都会引起系统不稳定。\n所以我们在实际设计运放电路的时候，在运放负输入引脚、输出脚及其下方都不要铺铜，还有就是同层的铺铜离这些引脚、连线的间距大点。\n\n尽量不要驱动大电容负载，必须驱动大电容负载的，使用裕度大的运放。或者串联隔离电阻。\n\n频率失真非线性失真：“输入-输出”关系是曲线，当输入为单一频率正弦波时，输出一定不是正弦波，而是除基波外包含谐波。\n线性失真：当输入为多个正弦波叠加形成复合波，放大电路对每个正弦波都不产生非线性失真，但是对每个正弦波的增益或延时不同，造成输出波形变形。（幅度和相位）\n频率特性分析方法频域分析法，最主要采用理论分析。\n例：一阶低通滤波器\n\n理论分析计算可得：\n\n幅频特性与相频特性：\n\n\n其中\n仿真得到幅频与相频特性曲线：\n\n滤波器滤波是指对不同频率输入信号，实施不同的增益和相移，以形成输出。滤波器是执行这种动作的硬件设备或者软件程序。\n无源滤波与有源滤波无源滤波：无需外部供电即可工作，包括电阻、电容、电感和变压器。\n优点：\n\n可工作在大电压、电流情况下。\n在超高频率时，无源器件有天生优势。\n简单滤波情况下可选择\n成本便宜\n\n有源滤波：必须有额外电能供应才能工作的器件\n优点：\n\n可以引入负反馈、可以引入放大环节，因此可以实现极为复杂的滤波器，且能轻松应对小信号。\n可以轻松实现多级滤波器的级联，而无源滤波器各级之间的互相影响是极为复杂的多级级联非常困难。\n对超低频率，有源滤波器有天生优势。\n电路计算更简单。\n带载能力强于无源滤波\n\n有源滤波器实现方法有3类：\n\n运放组成的有源滤波器\n\n状态变量型集成有源滤波器\n\n开关电容滤波器\n\n\n功能分类：\n\n低通滤波器\n带通滤波器\n带阻滤波器\n全通滤波器\n\n模拟滤波器传递函数和阶数系统传递函数就是系统输出函数uo(t)与ui(t)的比值的拉氏变换。\n上面那个例子也能写成传递函数形式\n\n滤波器更通用表达式：\nn为滤波器的阶数\n上限截止频率fH: 与之前晶体管频率特性时学的定义一样。\n下限截止频率fL：同上。\n特征频率f0: 特征频率是使传递函数变得最简单的点。\n定义特征频率的相移规则为：阶数每增加1阶，对于低通，特征频率点处的相移顺时针转动45°（滞后45°），对于高通，则逆时针转动45°（超前45°）。\n中心频率fc: 窄带通滤波器中，增益最大值处，或者相移为0度或者 360 度的整数倍时的频点，称为中心频率。陷波器中，增益最小值处，或者相移为 0度或者 360 度的整数倍时的频点，称为中心频率。\n一阶滤波器一阶低通滤波器\n直接写出传函：\n\n\n增益的模：\n当频率极低时，增益接近Am，随着频率逐渐增大到f = f0，增益变为0.707Am。随后随着频率增大，增益会以-20dB/10倍频的速率下降。这个斜率是通过计算得到的，这里不细推，需要知道n阶滤波器，衰减斜率按照-20ndB速率下降。\n相移：\n\n一阶高通滤波器\n同理可以得到：\n\n\n反向输入的一阶低通\n可直接写出增益表达式：\n\n\n其中\n反向输入的一阶高通\n幅频与相频表达式：\n\n\n一阶全通滤波器\n这个电路求解有多种思路，可以使用叠加原理、虚短虚断，可得：\n\n幅频：\n\n相角： \n分子分母\n相移为负值，所以是滞后型全通滤波器，上面左图。 右图为滞后型，同样可以求得：\n\n分子分母\n例：设计一个滤波器，要求输入信号幅度100mV，频率1000hz的正弦波，输出为同频正弦波并且相位超前45°，幅度为1V。\n分析：需要超前相位，前级可以选择超前相位的全通滤波器，幅度放大10倍后级接一个10倍放大器即可。主要先设计这个全通滤波器。\n首先我们已知相移要求45°可得：\n分子分母得\n选择RC参数：\n\n实际选择电阻选择不能太大也不能太小，选择R = 1KΩ是一个保险值。\n\n选择一个接近的电容值 C = 0.33μF重新计算电阻值我们选择R = 1180Ω\n\n对全通滤波器中另外两个电阻值必须相等，且两者并联最好等于R。所以Rg = Rf = 2.37kΩ\n\n后级放大电路，选择同相10倍放大，电阻比例1:9，选择R = 1kΩ 和 9.09kΩ\n\n\n运放选择40MHz带宽的OPA1611，至此设计完毕，对电路进行仿真。\n\n输入与输出电压\n\n\n\n可以算出相位超前：\n与理论计算相吻合。\n选电容为何不是选电感\n电感与电阻也能组成低通滤波器，下面分析为何不用。\n\n考虑到运放噪声与输出电流，电阻不能太大也不能太小，普遍一个安全标准 1KΩ。\n那么决定特征频率的值就是电感量了，由于制造工艺，多数电感在1nH100mH之间。据此，f0 = 159GHz1.59MHz一般运放的工作频率0~100MHz \n所以电感构成的滤波器，只能工作在截止频率比较大的场合。\n电容由于制造工艺，可以1pF1000μF，所以特征频率 0.159Hz159MHz，恰好符合运放工作频率。\n压控滤波器这种滤波器的截止频率可以由外部直流电压控制，利用乘法器或者压控增益放大器可以实现此功能。\n\n利用虚短虚断可以求出：\n\n可以看出这个表达式是一阶低通滤波器，上限截止频率为\n我们看这个电路与一阶低通滤波器的区别，就是在后级增加了一个乘法器，乘法器输出端电压接反馈环路中。使用外部的DAC设置UC就可以改变低通滤波器的特征频率，在一些场合下非常有用。\n后级也不一定是一个乘法器，我们可以用一个电阻网络或者比例器模拟乘法器。\n下面举例：\n\n我们把后级电阻网络使用戴维宁等效或者看做一个压控电压源\n\n其中\n带入公式可得\n仿真结果可看到结果吻合\n还可以把后级换成一个比例放大电路，这里不再分析，需要注意最终的特征频率与放大倍数和使用的运放带宽都有关系，运放随着频率增加放大倍数会出现衰减，因此后级运放的带宽要尽量高于特征频率。\n","categories":["硬件","模电"]}]