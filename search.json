[{"title":"K210学习（一）","url":"/2022/03/30/K210%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前言去年电赛就知道K210了，本来最优解决方案就是用K210，但是时间太短了没时间学（还是自己菜），最近刚好毕设要用到，买了一个开发板，正好学习下看看K210怎么跑神经网络的。\n\nK210芯片双核RISC-V处理器架构，算力1TOPS，功耗0.3W，而且国产芯片自带KPU神经网络加速器，一片不到50。（STM32H743也就这水平，效果怎么那么差，当时OPENMV还不支持神经网络，支持神经网络的必须要大SRAM）  \n  \n软件软件用MaixPy，编程跟OPENMV一样使用MicroPython\n  \n硬件开发板使用最小系统板  \n最爱的点灯环节代码  \nfrom fpioa_manager import fm #导入FPIOA库，这个库可以使任意外设映射在任意引脚上\nfrom Maix import GPIO # GPIO外设库\n\nio_led_red = 13    #LED红灯引脚\nfm.register(io_led_red, fm.fpioa.GPIO0)     #映射13引脚为GPIO0\n\nled_r=GPIO(GPIO.GPIO0, GPIO.OUT)    # 设置为输出模式\nwhile True :\n    led_r.value(0)  # 值为0\n    time.delay(1000)\n    led_r.value(1)  # 值为0\n    time.delay(1000)\n\n上传开发板\n","categories":["硬件","K210"]},{"title":"M-watch踩坑记录","url":"/2022/04/06/M-watch%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","content":"M-watch项目记录\n无线电源部分  \n  BQ51013b  \n  替换参考设计的时候要思考，不能用简化器件替代\n  \n              \n          \n      \n              \n      参考设计    \n      \n  \n    \n\n  仅用一个PMOS管代替肯定不行，因为此电路电源双向导通的，OUT端电压先产生，会直接影响AD端电压，使无线充电关闭。\n\n\n"},{"title":"神经影像（一）：Nipype库学习","url":"/2023/07/21/Nipype%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ANipype%E5%BA%93%E5%AD%A6%E4%B9%A0/","content":"Nipype简介Nipype是一个开源神经影像处理软件包，使用python编写。整合了传统神经影像处理软件包的接口（SPM,FSL,FreeSurfer,AFNI以及其他），可以使研究人员通过不同的软件处理图像，将其整合在一起。\n比如你想使用SPM做头动矫正，FreeSurfer做配准，ANTS用来标准化，然后FSL做平滑。使用传统流程会非常麻烦，需要你对各种软件的掌握。使用Nipype可以轻松完成。\n什么是NipypeNipype由多个组件构成，主要的组件有Interfaces,the WorkflowEngine 和Execution Plugins:\n\n            \n        \n    \n            \n    Nipype构成    \n    \n\n \n\n\nInterface: 相关软件的接口，可以是一个函数\n\nNode&#x2F;MapNode: 把一个接口打包成节点，在Workflow中使用。\n\nWorkflow: 一个表示工作流程的图，一个Workflow下面有很多节点。\n\nPlugin: 用来展示Workflow是如何工作的\n\n\nDockerDocker是一个开源项目，用来在容器中自动部署应用。（Docker的使用和学习令写，在这只简单介绍）这个容器可以打包运行Nipype所需的软件和完整的文件系统：代码，系统工具，软件库，比如 Python, FSL, AFNI, SPM, FreeSurfer, ANTs。这保证了可移植性，在不同环境中都可以运行。\nNipype官方教程所使用的  miykael&#x2F;nipype_tutorial镜像，建立了一个Linux环境和一系列所需软件包。同样的我们可以创建自己的docker镜像处理自己的数据。（之后再学用 Neurodocker创建）\nDocker for windows我是用的是Windows 10去docker官网下载 Docker for windows\n下载完成后使用终端测试是否安装正确：\ndocker --version\n\n            \n\n            \n\n\n\ndocker run hello-world\n\n            \n        \n    \n            \n        \n    \n\n\n\n这里提醒一下，Docker默认下载到C盘无法修改，Docker拉取的镜像也是在C盘，所以需要C盘空间很大，我试了修改镜像的位置，行不通，所以只能扩充C盘的大小了。\n拉取镜像确认Docker安装没有问题后，就可以开始拉取镜像了。\ndocker pull miykael/nipype_tutorial:latest\n\n由于是从国外的镜像网站拉取镜像，速度很慢。解决方法是使用国内镜像加速。\n找到C:\\Program Files\\Docker\\Docker\\resources文件夹下的windows-daemon-options.json文件\n&quot;registry-mirrors&quot;: [&quot;https://m3e4jmm0.mirror.aliyuncs.com&quot;],\n\n把镜像地址改为阿里云镜像。\n运行镜像简单运行miykael&#x2F;nipype_tutorial，使用命令：\ndocker run -it --rm -p 8888:8888 miykael/nipype_tutorial jupyter notebook\n\n如果想要使用本地的dataset，使用命令：\ndocker run -it --rm -v /path/to/nipype_tutorial/:/home/neuro/nipype_tutorial -v /path/to/data/:/data -v /path/to/output/:/output -p 8888:8888 miykael/nipype_tutorial jupyter notebook\n\n\n-it 表示打开一个可以交互的容器\n\n–rm 在关闭Docker后容器自动移除\n\n-p 表示使用哪个端口\n\n-v 表示把本地的文件加载到容器中去 &#x2F;path&#x2F;to&#x2F;nipype_tutorial&#x2F; 表示本地nipype_tutorial路径，：表示加载到容器中的路径。\n\nmiykael&#x2F;nipype_tutorial 表示运行哪个镜像\n\njupyter notebook 在容器中打开jupyter\n\n\n关闭容器在终端使用ctrl-c可以关闭容器\n列出所有imagedocker images\n\n删除镜像docker rmi -f 7d9495d03763\n\n后面的数字为镜像ID\n提取和加载镜像如果想使用U盘保存镜像，使用命令：\n# Export docker image miykael/nipype_tutorial\ndocker save -o nipype_tutorial.tar miykael/nipype_tutorial\n\n# Import docker image on another PC\ndocker load --input nipype_tutorial.tar\n\n数据保存格式这个教程的数据保存结构是根据 Brain Imaging Data Structure (BIDS).\n这个格式结构清晰，并且易于共享。\n            \n        \n    \n            \n        \n    \n\n \n\n\n参考nipype官方教程 Nipype tutorial\n","categories":["python"],"tags":["神经影像"]},{"title":"Nipype（三）:Quickstart","url":"/2023/07/24/Nipype%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AQuickstart/","content":"Nipype Quickstart首先需要Import所需要的函数和包\nimport os \nfrom os.path import abspath\n\nfrom nipype import Workflow, Node, MapNode, Function\nfrom nipype.interfaces.fsl import BET, IsotropicSmooth, ApplyMask #fsl的接口函数\n\nfrom nilearn.plotting import plot_anat #画图\n%matplotlib inline #在Jupyter Notebook中画图时直接嵌入Notebook单元格中\nimport matplotlib.pyplot as plt\n\nInterfaces接口是Nipype的核心。这些接口是python接口可以通过这些接口访问外部软件包，这些软件包大多不是用python写的。（比如FSL,SPM和FreeSurfer）\n使用FSL中的bet()函数\n# will use a T1w from ds000114 dataset\n\n# input_file是BET()函数的输入参数，为数据集的路径\ninput_file =  abspath(&quot;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&quot;)\n# BET()实例化\nbet = BET()\n\nbet.inputs.in_file = input_file\n# 输出为输出路径\nbet.inputs.out_file = &quot;/output/T1w_nipype_bet.nii.gz&quot;\nres = bet.run()\n\n画出输出图像\nplot_anat(&#39;/output/T1w_nipype_bet.nii.gz&#39;, \n      display_mode=&#39;ortho&#39;, dim=-1, draw_cross=False, annotate=False);\n\n\n使用help指令可以看接口函数的使用方法\nBET.help()\n\nWraps the executable command ``bet``.\n\nFSL BET wrapper for skull stripping\n\nFor complete details, see the `BET Documentation.\n&lt;https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/BET/UserGuide&gt;`_\n\nExamples\n--------\n&gt;&gt;&gt; from nipype.interfaces import fsl\n&gt;&gt;&gt; btr = fsl.BET()\n&gt;&gt;&gt; btr.inputs.in_file = &#39;structural.nii&#39;\n&gt;&gt;&gt; btr.inputs.frac = 0.7\n&gt;&gt;&gt; btr.inputs.out_file = &#39;brain_anat.nii&#39;\n&gt;&gt;&gt; btr.cmdline\n&#39;bet structural.nii brain_anat.nii -f 0.70&#39;\n&gt;&gt;&gt; res = btr.run() # doctest: +SKIP\n\nInputs::\n\n        [Mandatory]\n        in_file: (a pathlike object or string representing an existing file)\n                input file to skull strip\n                argument: ``%s``, position: 0\n\n        [Optional]\n        out_file: (a pathlike object or string representing a file)\n                name of output skull stripped image\n                argument: ``%s``, position: 1\n        outline: (a boolean)\n                create surface outline image\n                argument: ``-o``\n        mask: (a boolean)\n                create binary mask image\n                argument: ``-m``\n        skull: (a boolean)\n                create skull image\n                argument: ``-s``\n        no_output: (a boolean)\n                Don&#39;t generate segmented output\n                argument: ``-n``\n        frac: (a float)\n                fractional intensity threshold\n                argument: ``-f %.2f``\n        vertical_gradient: (a float)\n                vertical gradient in fractional intensity threshold (-1, 1)\n                argument: ``-g %.2f``\n        radius: (an integer)\n                head radius\n                argument: ``-r %d``\n        center: (a list of at most 3 items which are an integer)\n                center of gravity in voxels\n                argument: ``-c %s``\n        threshold: (a boolean)\n                apply thresholding to segmented brain image and mask\n                argument: ``-t``\n        mesh: (a boolean)\n                generate a vtk mesh brain surface\n                argument: ``-e``\n        robust: (a boolean)\n                robust brain centre estimation (iterates BET several times)\n                argument: ``-R``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        padding: (a boolean)\n                improve BET if FOV is very small in Z (by temporarily padding end\n                slices)\n                argument: ``-Z``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        remove_eyes: (a boolean)\n                eye &amp; optic nerve cleanup (can be useful in SIENA)\n                argument: ``-S``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        surfaces: (a boolean)\n                run bet2 and then betsurf to get additional skull and scalp surfaces\n                (includes registrations)\n                argument: ``-A``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        t2_guided: (a pathlike object or string representing a file)\n                as with creating surfaces, when also feeding in non-brain-extracted\n                T2 (includes registrations)\n                argument: ``-A2 %s``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        functional: (a boolean)\n                apply to 4D fMRI data\n                argument: ``-F``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        reduce_bias: (a boolean)\n                bias field and neck cleanup\n                argument: ``-B``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        output_type: (&#39;NIFTI&#39; or &#39;NIFTI_PAIR&#39; or &#39;NIFTI_GZ&#39; or\n                &#39;NIFTI_PAIR_GZ&#39;)\n                FSL output type\n        args: (a string)\n                Additional parameters to the command\n                argument: ``%s``\n        environ: (a dictionary with keys which are a bytes or None or a value\n                of class &#39;str&#39; and with values which are a bytes or None or a\n                value of class &#39;str&#39;, nipype default value: &#123;&#125;)\n                Environment variables\n\nOutputs::\n\n        out_file: (a pathlike object or string representing a file)\n                path/name of skullstripped file (if generated)\n        mask_file: (a pathlike object or string representing a file)\n                path/name of binary brain mask (if generated)\n        outline_file: (a pathlike object or string representing a file)\n                path/name of outline file (if generated)\n        meshfile: (a pathlike object or string representing a file)\n                path/name of vtk mesh file (if generated)\n        inskull_mask_file: (a pathlike object or string representing a file)\n                path/name of inskull mask (if generated)\n        inskull_mesh_file: (a pathlike object or string representing a file)\n                path/name of inskull mesh outline (if generated)\n        outskull_mask_file: (a pathlike object or string representing a file)\n                path/name of outskull mask (if generated)\n        outskull_mesh_file: (a pathlike object or string representing a file)\n                path/name of outskull mesh outline (if generated)\n        outskin_mask_file: (a pathlike object or string representing a file)\n                path/name of outskin mask (if generated)\n        outskin_mesh_file: (a pathlike object or string representing a file)\n                path/name of outskin mesh outline (if generated)\n        skull_mask_file: (a pathlike object or string representing a file)\n                path/name of skull mask (if generated)\n        skull_file: (a pathlike object or string representing a file)\n                path/name of skull file (if generated)\n\nReferences:\n-----------\nBibTeX(&#39;@article&#123;JenkinsonBeckmannBehrensWoolrichSmith2012,author=&#123;M. Jenkinson, C.F. Beckmann, T.E. Behrens, M.W. Woolrich, and S.M. Smith&#125;,title=&#123;FSL&#125;,journal=&#123;NeuroImage&#125;,volume=&#123;62&#125;,pages=&#123;782-790&#125;,year=&#123;2012&#125;,&#125;&#39;, key=&#39;JenkinsonBeckmannBehrensWoolrichSmith2012&#39;)\n\n​使用FSL中的光滑函数，高斯核为4mm\nsmoothing = IsotropicSmooth()\nsmoothing.inputs.in_file = &quot;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&quot;\nsmoothing.inputs.fwhm = 4\nsmoothing.inputs.out_file = &quot;/output/T1w_nipype_smooth.nii.gz&quot;\nsmoothing.run()\n# plotting the output\nplot_anat(&#39;/output/T1w_nipype_smooth.nii.gz&#39;, \n      display_mode=&#39;ortho&#39;, dim=-1, draw_cross=False, annotate=False);\n\n\nNodes and Workflows接口是Nipype的核心，在使用不同包的接口或者同一个包的不同接口时，需要把接口放在一个Node中，并且多个Node构成一个workflow。\n在Nipype中，一个节点是执行某个函数的物体，这个函数可以是Nipype中的任意接口函数或者是user自己创建的函数，又或者是外部的一个脚本中的。每个节点由名称，接口和最少一个输入和输出构成。\n一旦使用了多个节点，就可以使用workflow连接每一个节点，并且生成一个有向连接图。\n首先创建去头骨节点\n# Create Node\nbet_node = Node(BET(), name=&#39;bet&#39;)\n# Specify node inputs\nbet_node.inputs.in_file = input_file\nbet_node.inputs.mask = True\n\n# bet node can be also defined this way:\n#bet_node = Node(BET(in_file=input_file, mask=True), name=&#39;bet_node&#39;)\n\nmask为True表示生成一个去头骨的掩膜图像。\n接下来创建一个光滑节点，使用IsotropicSmooth函数\nsmooth_node = Node(IsotropicSmooth(in_file=input_file, fwhm=4), name=&quot;smooth&quot;)\n\n接下来使用掩膜函数把光滑后的图像掩膜。\nmask_node = Node(ApplyMask(), name=&quot;mask&quot;)\n\n使用help指令后可以看到，ApplyMask（）函数有两个必须传入的参数。\n\nmask_file :掩膜图像位置\n\nin_file ：被掩膜的图像\n\n\n所有节点都创建完毕，接下来创建一个workflow把他们连接起来。首先连接bet_node的输出和mask_node的输入\n# Initiation of a workflow\nwf = Workflow(name=&quot;smoothflow&quot;, base_dir=&quot;/output/working_dir&quot;)\n\nwf.connect(bet_node, &quot;mask_file&quot;, mask_node, &quot;mask_file&quot;)\n\n接着连接smooth_node的out_file和mask_node的in_file把这个workflow可视化出来\nwf.connect(smooth_node,&quot;out_file&quot;,mask_node, &quot;in_file&quot;)\n\n\nwf.write_graph(&quot;workflow_graph.dot&quot;)\nImage(filename=&quot;/output/working_dir/smoothflow/workflow_graph.png&quot;)\n\n\n或者画出细节图\nwf.write_graph(graph2use=&#39;flat&#39;)\n\nImage(filename=&quot;/output/working_dir/smoothflow/graph_detailed.png&quot;)\n\n\n接下来开始运行workflow\nres = wf.run()\n\n列出结果\nlist(res.nodes)[0].result.outputs\n\n\n查看生成的文件夹\n! tree -L 3 /output/working_dir/smoothflow/\n\n也可以将生成图片画出\nimport numpy as np\nimport nibabel as nb\n#import matplotlib.pyplot as plt\n\n# Let&#39;s create a short helper function to plot 3D NIfTI images\ndef plot_slice(fname):\n\n    # 加载图像\n    img = nb.load(fname)    \n    data = img.get_data()\n\n    # 因为是3D图像，所以选择Z轴中间切开\n    cut = int(data.shape[-1]/2) + 10   \n\n    # Plot the data\n    plt.imshow(np.rot90(data[..., cut]), cmap=&quot;gray&quot;)\n    plt.gca().set_axis_off()  # 关闭坐标轴\n\nf = plt.figure(figsize=(12, 4))\nfor i, img in enumerate([&quot;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&quot;,\n                        &quot;/output/working_dir/smoothflow/smooth/sub-01_ses-test_T1w_smooth.nii.gz&quot;,\n                        &quot;/output/working_dir/smoothflow/bet/sub-01_ses-test_T1w_brain_mask.nii.gz&quot;,\n                        &quot;/output/working_dir/smoothflow/mask/sub-01_ses-test_T1w_smooth_masked.nii.gz&quot;]):\n    f.add_subplot(1, 4, i + 1)\n    plot_slice(img)\n\n\nIterables在做数据处理的时候，经常一个预处理跑多个受试或者做一些组差异比较。避免重复写脚本，Nipype有一个处理插件，叫做iterables\n假如我们有一个workflow上面有两个node，node（A）是去头颅函数，node(B)是光滑函数，现在我们很好奇不同大小的高斯核对结果的影响。因此，我们设置FWHM的值为4mm,8mm和16mm。\n\nsmooth_node_it = Node(IsotropicSmooth(in_file=input_file), name=&quot;smooth&quot;)\nsmooth_node_it.iterables = (&quot;fwhm&quot;, [4, 8, 16])\n\n重新定义bet和mask node\nbet_node_it = Node(BET(in_file=input_file, mask=True), name=&#39;bet_node&#39;)\nmask_node_it = Node(ApplyMask(), name=&quot;mask&quot;)\n\n新建一个新的workflow\nwf_it = Workflow(name=&quot;smoothflow_it&quot;, base_dir=&quot;/output/working_dir&quot;)\nwf_it.connect(bet_node_it, &quot;mask_file&quot;, mask_node_it, &quot;mask_file&quot;)\nwf_it.connect(smooth_node_it, &quot;out_file&quot;, mask_node_it, &quot;in_file&quot;)\n\n运行workflow\nres_it = wf_it.run()\n\n看生成的文件    ! tree -L 3 &#x2F;output&#x2F;working_dir&#x2F;smoothflow_it&#x2F;\n/output/working_dir/smoothflow_it/\n├── bet_node\n│   ├── _0x059f982d380f7943757debfb10a5502d.json\n│   ├── command.txt\n│   ├── _inputs.pklz\n│   ├── _node.pklz\n│   ├── _report\n│   │   └── report.rst\n│   ├── result_bet_node.pklz\n│   └── sub-01_ses-test_T1w_brain_mask.nii.gz\n├── d3.js\n├── _fwhm_16\n│   ├── mask\n│   │   ├── _0xd72ea2e7b364b1159092a12f3d3ca28c.json\n│   │   ├── command.txt\n│   │   ├── _inputs.pklz\n│   │   ├── _node.pklz\n│   │   ├── _report\n│   │   ├── result_mask.pklz\n│   │   └── sub-01_ses-test_T1w_smooth_masked.nii.gz\n│   └── smooth\n│       ├── _0xc478d2c0a35763bb8cc0ba0be7c7c4a3.json\n│       ├── command.txt\n│       ├── _inputs.pklz\n│       ├── _node.pklz\n│       ├── _report\n│       ├── result_smooth.pklz\n│       └── sub-01_ses-test_T1w_smooth.nii.gz\n├── _fwhm_4\n│   ├── mask\n│   │   ├── _0x020ff51c3dd2cc1c441bbc71b6bb82fd.json\n│   │   ├── command.txt\n│   │   ├── _inputs.pklz\n│   │   ├── _node.pklz\n│   │   ├── _report\n│   │   ├── result_mask.pklz\n│   │   └── sub-01_ses-test_T1w_smooth_masked.nii.gz\n│   └── smooth\n│       ├── _0x7284dba78093a51ae87024eac1bec00f.json\n│       ├── command.txt\n│       ├── _inputs.pklz\n│       ├── _node.pklz\n│       ├── _report\n│       ├── result_smooth.pklz\n│       └── sub-01_ses-test_T1w_smooth.nii.gz\n├── _fwhm_8\n│   ├── mask\n│   │   ├── _0x3ac21b3bbb4f9177e3221ac52b59a349.json\n│   │   ├── command.txt\n│   │   ├── _inputs.pklz\n│   │   ├── _node.pklz\n│   │   ├── _report\n│   │   ├── result_mask.pklz\n│   │   └── sub-01_ses-test_T1w_smooth_masked.nii.gz\n│   └── smooth\n│       ├── _0x8a60534f7916842abe5b185fdf7996d9.json\n│       ├── command.txt\n│       ├── _inputs.pklz\n│       ├── _node.pklz\n│       ├── _report\n│       ├── result_smooth.pklz\n│       └── sub-01_ses-test_T1w_smooth.nii.gz\n├── graph1.json\n├── graph.json\n└── index.html\n\n17 directories, 47 files\n\nMapnode如果想使输入为多个输入参数的节点的输出都为下一个节点的输入，那么就需要使用MapNode。MapNode与普通的Node很像，它的输入可以是一个列表，最终也生成一个输出列表。\n比如你有许多文件，他们都会经过相同的node处理和不同的Node，这时MapNode可以发挥作用。\n比如上图，A节点处理后得到一个列表的输出，而这些输出都会经过B节点处理，最后把B得到的结果送入C节点。\n简单例子：\ndef square_func(x):\nreturn x ** 2\n\n# 这里使用nipype的Function接口，把用户自己创建的函数作为一个接口\nsquare = Function(input_names=[&quot;x&quot;], output_names=[&quot;f_x&quot;], function=square_func)\n\n如果把输入的值设置为一个列表\nsquare_node = Node(square, name=&quot;square&quot;)\nsquare_node.inputs.x = [2, 4]\nres = square_node.run()\nres.outputs\n\n输出会报错，因为square_func不能接收一个列表。\n这时我们使用MapNode即可解决！\nsquare_mapnode = MapNode(square, name=&quot;square&quot;, iterfield=[&quot;x&quot;])\nsquare_mapnode.inputs.x = [2, 4]\nres = square_mapnode.run()\nres.outputs\n\n\n参考nipype官方教程 Nipype Quickstart\n","categories":["python"],"tags":["神经影像"]},{"title":"Nipype（二）：showcase","url":"/2023/07/24/Nipype%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ashowcase/","content":"Nipype Showcase使用简单的fMRI预处理流程来展示Workflow：\n\nslice time correction\nmotion correction\nsmoothing\n\n准备预处理workflow首先导入Nipype包中的Node和Workflow\nfrom nipype import Node, Workflow\n\n接着导入预处理需要的interfaces\nfrom nipype.interfaces.fsl import SliceTimer, MCFLIRT, Smooth\n\n接着把这三个接口接入Node并且定义输入\n# 初始化slicetime节点\nslicetimer = Node(SliceTimer(index_dir=False,\n                            interleaved=True,\n                            time_repetition=2.5),\n                  name=&quot;slicetimer&quot;)\n\n# 初始化运动矫正节点\nmcflirt = Node(MCFLIRT(mean_vol=True,\n                      save_plots=True),\n              name=&quot;mcflirt&quot;)\n# 初始化光滑节点\nsmooth = Node(Smooth(fwhm=4), name=&quot;smooth&quot;)\n\n接下来就可以创建一个workflow，把这三个节点连接起来\n# 创建预处理workflow\npreproc01 = Workflow(name=&#39;preproc01&#39;, base_dir=&#39;.&#39;)\n\n# 连接节点到workflow中\npreproc01.connect([(slicetimer, mcflirt, [(&#39;slice_time_corrected_file&#39;, &#39;in_file&#39;)]),\n               (mcflirt, smooth, [(&#39;out_file&#39;, &#39;in_file&#39;)])])\n\n可以把workflow可视化\n# 生成可视化图片\npreproc01.write_graph(graph2use=&#39;orig&#39;)\n\n# 导入Ipython的图像包\nfrom IPython.display import Image\nImage(filename=&quot;preproc01/graph_detailed.png&quot;)\n\n            \n        \n    \n            \n    结果\n    \n\n \n在一个功能图像上运行workflow创建过一个workflow后，开始在功能像上运行。首先要确定数据文件的路径。\nslicetimer.inputs.in_file = &#39;/data/ds000114/sub-01/ses-test/func/sub-01_ses-test_task-fingerfootlips_bold.nii.gz&#39;\n\ndata文件夹下有所需要的数据。\n使用Nipype的并行处理功能，观察处理时间\n%time preproc01.run(&#39;MultiProc&#39;, plugin_args=&#123;&#39;n_procs&#39;: 5&#125;)\n\n            \n        \n    \n            \n    \n    \n\n\n            \n        \n    \n            \n    结果\n    \n\n\n上图 输出了整个Workflow的工作流程，最后可以看到整个处理花费大概2min。\n结果检查一下输出文件夹有什么。\n!tree preproc01 -I &#39;*js|*json|*pklz|_report|*.dot|*html&#39;\n\n            \n        \n    \n            \n    \n    \n\n\n\n修改参数重新运行smooth.inputs.fwhm = 2\n%time preproc01.run(&#39;MultiProc&#39;, plugin_args=&#123;&#39;n_procs&#39;: 5&#125;)\n\n  \n可看到时间仅用14秒，因为整个workflow不会重新运行一遍，只把更改参数的Node运行，在这里就是把smooth重新运行。\n并行处理preproc1预处理workflow使用了大概两分钟，如果我要处理5张功能像图片，他会花费10分钟。\n首先我们复制5个workflow\n# First, let&#39;s copy/clone &#39;preproc01&#39;\npreproc02 = preproc01.clone(&#39;preproc02&#39;)\npreproc03 = preproc01.clone(&#39;preproc03&#39;)\npreproc04 = preproc01.clone(&#39;preproc04&#39;)\npreproc05 = preproc01.clone(&#39;preproc05&#39;)\n\n我们想要并行处理，需要把他们整合在一个workflow中。\nmetaflow = Workflow(name=&#39;metaflow&#39;, base_dir=&#39;.&#39;)\n# Now we can add the five preproc workflows to the bigger metaflow\nmetaflow.add_nodes([preproc01, preproc02, preproc03,\n                preproc04, preproc05])\n\n可视化看一下整个workflow\n# As before, let&#39;s write the graph of the workflow\nmetaflow.write_graph(graph2use=&#39;flat&#39;)\n\nImage(filename=&quot;metaflow/graph_detailed.png&quot;)\n\n\n使用并行处理\n%time metaflow.run(&#39;MultiProc&#39;, plugin_args=&#123;&#39;n_procs&#39;: 5&#125;)\n\nlog信息此处省略\n可以看到总共用时2min，这就是使用Nipype的原因。\nmetaflow的结果!tree metaflow -I &#39;*js|*json|*pklz|_report|*.dot|*html&#39;\n\n\n参考nipype官方教程 Nipype Showcase\n","categories":["python"],"tags":["神经影像"]},{"title":"Hello World","url":"/2025/02/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Nipype（四）：Interfaces","url":"/2023/08/03/Nipype%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AInterfaces/","content":"Interfaces在之前已经学习过Interfaces的基本概念和操作，这里简单介绍一下。Interfaces就是其他软件包的python函数接口，想要使用其他软件的（例如FSL,SPM或者FreeSurfer）函数，就需要此函数的python接口和安装相应的软件包。\nBET函数原始使用方法先看一下我们需要去头骨的原始图像。\nfrom nilearn.plotting import plot_anat\n%matplotlib inline\nplot_anat(&#39;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&#39;, title=&#39;original&#39;,\n      display_mode=&#39;ortho&#39;, dim=-1, draw_cross=False, annotate=False);\n\n\n使用BET函数命令行形式（即在FSL中原始使用方法）\nbet &lt;input&gt; &lt;output&gt;\n\n在ipython中则需要在前面加%%bash\n%%bash\n\nFILENAME=/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w\n\nbet $&#123;FILENAME&#125;.nii.gz /output/sub-01_ses-test_T1w_bet.nii.gz\n\n使用查看帮助信息\n!bet -h\n\nUsage:    bet &lt;input&gt; &lt;output&gt; [options]\n\nMain bet2 options:\n-o          generate brain surface outline overlaid onto original image\n-m          generate binary brain mask\n-s          generate approximate skull image\n-n          don&#39;t generate segmented brain image output\n-f &lt;f&gt;      fractional intensity threshold (0-&gt;1); default=0.5; smaller values give larger brain outline estimates\n-g &lt;g&gt;      vertical gradient in fractional intensity threshold (-1-&gt;1); default=0; positive values give larger brain outline at bottom, smaller at top\n-r &lt;r&gt;      head radius (mm not voxels); initial surface sphere is set to half of this\n-c &lt;x y z&gt;  centre-of-gravity (voxels not mm) of initial mesh surface.\n-t          apply thresholding to segmented brain image and mask\n-e          generates brain surface as mesh in .vtk format\n\nVariations on default bet2 functionality (mutually exclusive options):\n(default)   just run bet2\n-R          robust brain centre estimation (iterates BET several times)\n-S          eye &amp; optic nerve cleanup (can be useful in SIENA)\n-B          bias field &amp; neck cleanup (can be useful in SIENA)\n-Z          improve BET if FOV is very small in Z (by temporarily padding end slices)\n-F          apply to 4D FMRI data (uses -f 0.3 and dilates brain mask slightly)\n-A          run bet2 and then betsurf to get additional skull and scalp surfaces (includes registrations)\n-A2 &lt;T2&gt;    as with -A, when also feeding in non-brain-extracted T2 (includes registrations)\n\nMiscellaneous options:\n-v          verbose (switch on diagnostic messages)\n-h          display this help, then exits\n-d          debug (don&#39;t delete temporary intermediate images)\n\n使用命令行生成二进制掩膜文件。\n%%bash\n\nFILENAME=/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w\n\nbet $&#123;FILENAME&#125;.nii.gz /output/sub-01_ses-test_T1w_bet.nii.gz -m\n\n由此我们可知道python接口的函数实际上也是在命令行中输入需要的操作，不过使用的是python脚本形式。\nBET函数接口使用在之前有，这里简要介绍。\n# import BET函数\nfrom nipype.interfaces.fsl import BET\nskullstrip = BET() # 对象实例化\nskullstrip.inputs.in_file = &quot;/data/ds000114/sub-01/ses-test/anat/ sub-01_ses-test_T1w.nii.gz&quot; # 输入文件路径\nskullstrip.inputs.out_file = &quot;/output/T1w_nipype_bet.nii.gz&quot; # 输出文件路径\nres = skullstrip.run() # 运行\n\n\n我们来看一下输出的命令行\nprint(skullstrip.cmdline)\n\nbet /data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz /output/T1w_nipype_bet.nii.gz\n\n与我们正常使用时的一样。\nInterface errors使用run方法运行接口时，对于FSL、Freesurfer和其他程序，会使系统输入上述命令行命令。对于MATLAB的程序如SPM，它会生成一个.m文件，然后在matlab环境下运行这个.m文件。\n如果我们不给函数接口一个必要的输入参数它就会报错\nskullstrip2 = BET()\ntry:\n    skullstrip2.run()\nexcept(ValueError) as err:\n    print(&quot;ValueError:&quot;, err)\nelse:\n    raise\n\nValueError: BET requires a value for input &#39;in_file&#39;. For a list of required inputs, see BET.help()\n\nBET函数没有输入文件的路径\n又或者输入类型搞错，比如BET（）函数想要生成掩膜文件，你却把淹没文件的名字输入上去了 XD。\ntry:\nskullstrip.inputs.mask = &quot;mask_file.nii&quot;\nexcept(Exception) as err:\n    if &quot;TraitError&quot; in str(err.__class__):\n        print(&quot;TraitError:&quot;, err)\n    else:\n        raise\nelse:\n    raise\nTraitError: The &#39;mask&#39; trait of a BETInputSpec instance must be a boolean, but a value of &#39;mask_file.nii&#39; &lt;class &#39;str&#39;&gt; was specified.\n\n在报错的时候根据报错信息修改程序\n参考nipype_tutorial Interface\n","categories":["python"],"tags":["神经影像"]},{"title":"告别","url":"/2022/05/06/%E5%91%8A%E5%88%AB/","content":"毕业大学四年过去了，回顾一下这四年还挺美好的，虽然没社交没参加活动啥的，感觉那都是虚的，真正要提高的还是自己的做工程的能力和精神。最害怕的是转专业后也沦为做题机器了，幸好没有，做了几个还算一般的项目吧。最后一年我也不知道为啥摆烂了，因为疫情？肯定不是，都他妈的借口，归根到底还是自己这个人就这比样，稍微放松一下就回归自我了。电赛复盘一下，确实是自己能力不足。还是自己太菜了，还得过段时间再继续吧。M-watch项目暂停了，以及EAGLE、3D结构方面、模电、电子电路反正一堆要学的都得暂停了，真他妈的烦。\n\n之后打算还是考研吧，本来想着先工作两年攒一下经验，现在看来当时有点天真以为有项目经验就好找工作，哈哈哈，在学历面前确实全都是屁不值一提。总而言之吧，决定考就认真考了，今天正好也给毕设肝完了，没理由碰代码了，不知道半年不碰会变菜不会哈哈哈哈。\n咱也不需要啥动力，顶不住的时候想想18年就好了。\n就这样吧，希望下次归来时，我可以追梦。\n","categories":["杂谈"]},{"title":"核磁共振原理（一）","url":"/2023/05/05/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/","content":"核磁共振仪的硬件组成  核磁共振仪主要由主磁体、梯度系统、射频系统、计算机系统和其他辅助设备。  \n \n主磁体  主磁体分为永磁型和电磁型，永磁性产生的磁场强度通常比电磁型小，电磁型可以产生很大的磁场强度。  \n\n\n主要参数\n磁场强度：磁场强度的单位为T（特斯拉），G（高斯），定义1G为，距离通过5A电流的线圈5cm处的磁场强度。1T&#x3D;10000G。一般把0.5T以下的MRI仪称为低场机，0.51.0T为中场机，1.02.0T为高场机，大于2.0T的称为超高场机（3.0T）。高磁场强度的优点：1.提高质子的磁化率，增加图像的信噪比；2.缩短MRI成像的时间；3.增加血氧饱和度依赖效应（BOLD），使脑功能成像的信号变化更为明显。\n\n\n\n\n主磁场均匀度：磁场均匀性是指在一定的容积范围内磁场强度的均一性，也即单位面积内通过的磁力线数目的一致性。\n\n\n\n\n主磁场的稳定性：实际上是指主磁场强度及其均匀性的变化，也成为磁场漂移。\n\n\n\n梯度系统  梯度系统是MRI仪最重要的硬件之一，由梯度线圈、梯度放大器、数模转换器、梯度控制器、梯度冷却装置构成，梯度线圈安装于主磁体内。梯度系统的主要作用：1、进行MRI信号的空间定位编码。2、产生梯度回波信号。\n \n磁共振坐标系  坐标系主要由x、y、z构成，Z轴是人体长轴方向正方向为头部，X轴正方向为人体左侧，Y轴正方向是人体解剖位置前侧。\n\n            \n        \n    \n            \n    磁共振系统的坐标系    \n    \n\n  \n\n梯度磁场的产生  以Z轴为例，梯度线圈是特殊绕制的线圈，在头部和脚部。线圈通电后，电流流过头部线圈产生与主磁场方向相同的磁场，两个磁场强度叠加，头部磁场强度增高。脚步磁场方向相反，磁场减弱。从而形成沿着Z轴分布，头侧高足侧低的梯度磁场，梯度线圈中心位置的磁场强度保持不变。\n\n            \n        \n    \n            \n    梯度磁场    \n    \n\n  \n\n射频系统   射频系统由射频发生器、射频放大器和射频线圈构成。射频线圈有发射线圈和接收线圈。发射线圈发出射频脉冲（无线电波）激发人体内的质子发生共振（后面补充），接收线圈接收人体发出的MR信号。\n \n计算机系统\n  计算机系统控制着MRI仪的射频脉冲激发、信号采集、数据运算和图像显示等功能。\n\n\n            \n        \n    \n            \n    核磁共振控制系统结构    \n    \n\n  \n\n\nSCP(scan control processor) 扫描控制系统：产生序列脉冲的全部硬件开关信号，控制全部硬件（射频，梯度，采样，重构）开始和结束时间点。\nTRF（trigger and rotational function board）：定位引起的坐标旋转变换，对应梯度的控制，以及对SRF的触发控制。\nSRF（sequence related function board）:负责序列中梯度系统涡流校正补偿对梯度的触发控制。\nIRF（interface relate function board）射频控制器：负责主时钟的同步，控制发射射频控制器。\nDRF（digital receiver filter）数字滤波器：对IRF发送来的采集数据，进行频率解调，去除掉载波频率，同时进行一定的降噪处理。\nAPS（acquisition processing subsystem）:根据主机序列所对应的扫描参数，负责对采集的数据按K空间顺序、层面关系及平均次数排序组合，并把排列好的K空间发送给重建处理器。\nReflex AP 重建处理器：专门负责对原始数据进行傅里叶变换。\n\n\n这一部分简单介绍核磁共振仪器的硬件组成，之后笔记记录学习核磁共振物理学原理。\n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（三）","url":"/2023/05/09/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/","content":"磁共振加权成像加权是“突出重点”的意思，组织的多方面特性均可能对其磁共振信号的强弱有影响，我们可以通过成像脉冲序列的选择及成像参数的调整，使MR图像主要反映组织某方面特性，而尽量抑制组织的其他特性对MR信号强度的影响。\nTI加权成像（T1-weighted imaging,T1WI）是指图像中组织信号强度的高低主要反映的是组织的纵向弛豫差别。\nT2加权成像（T2-weighted imaging,T2WI）重点突出的是不同组织之间的横向弛豫差别。\n质子密度加权成像（PDWI）则主要反映单位体积的不同组织之间的质子含量差别。\n质子密度加权成像质子密度加权成像主要反映单位体积不同组织间质子含量的差别。以甲乙两种组织为例，甲组织质子含量高于乙质子，90°射频脉冲激发后甲组织产生的旋转宏观横向磁化矢量就大于乙组织，这时马上检测MR信号，甲组织产生的MR信号将高于乙组织。\n            \n        \n    \n            \n    质子密度加权成像    \n    \n\n  \n\nT2加权成像与T2*加权成像T2WI主要反映不同组织间横向弛豫的差别，必须用聚焦脉冲采集自旋回波方可得到组织真正的T2弛豫信息。\n同样以甲乙组织为例，假如质子密度一样，甲乙两种组织产生的宏观纵向磁化矢量大小相同，一个射频脉冲如90°脉冲激发后，两种组织产生的旋转宏观横向磁化矢量大小也相同，这时不马上检测MR信号；90°脉冲关闭后，甲组织横向弛豫比乙组织慢，到一定时刻，甲组织衰减掉的宏观横向磁化矢量少于乙组织，其残留的宏观横向磁化矢量将大于乙组织，这时再检测MR信号，甲组织的MR信号强度将高于乙组织，这样就实现了T2WI。\n            \n        \n    \n            \n    T2WI加权成像原理    \n    \n\n  \n\n前面所述的 T2WI的回波信号必须采用聚焦脉冲来获得，如果不采用聚焦脉冲而仅采用读出梯度场的切换获取梯度回波信号，则磁共振信号反映的不是真正的 T2 弛豫信息而是T2*弛豫信息，因此得到的不是T2WI而是T2*WI。\nT1加权成像T1WI主要反映组织纵向弛豫的差别我们还是以甲、乙两种组织为例，假设这两种组织质子密度相同,但甲组织的纵向弛豫比乙组织快(即甲组织的 T1值短于乙组织)。进入主磁场后由于质子密度一样,甲乙两种组织产生的纵向磁化矢量大小相同，一个射频脉冲如 90°脉冲后产生的宏观横向磁化矢量的大小也相同,我们先不去理会这种宏观横向磁化矢量,也不马上检测 MR 信号。射频脉冲关闭后,甲乙两种组织将发生纵向驰豫，由于甲组织的纵向弛豫比乙组织快,过一定时间甲组织纵向磁化矢量比乙组织大。这时再产生一个90°脉冲，第二个 90°脉冲后,甲、乙两组织的宏观纵向磁化矢量将发生偏转，产生宏观横向磁化矢量，因为这时甲组织的纵向磁化矢量大于乙组织,其产生的宏观横向磁化矢量将大于乙组织,这时马上检测 MR信号,甲组织产生的 MR 信号将高于乙组织。\n\n            \n        \n    \n            \n    T1WI加权成像原理    \n    \n\n  \n在T1WI上,组织的T1值越小,其MR信号强度越大.\n\n\n参考《磁共振成像技术指南》—— 杨正汉\n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（二）","url":"/2023/05/06/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"核磁共振物理学原理\n原子结构\n原子由原子核和围绕原子核的电子构成，原子核中有中子和质子，中子不带电，质子带正电。\n自旋和核磁\n原子核具有一定大小和质量，可以视作一个球体，所有磁性原子核都有一个特性，就是总以一定的频率绕着自己的轴进行高速旋转，原子核这一特性称为自旋（spin）。由于原子核表面带有正电荷，所以磁性原子核的自旋就形成电流环路，从而产生具有一定大小和方向的磁化矢量。\n            \n        \n    \n            \n    原子核的自旋    \n    \n\n  \n\n不是所有的原子核均能自旋产生核磁，原子核内中子和质子的数目决定了原子核是否为磁性原子核。磁性原子核需保证：中子数和质子数至少要有一个是奇数。\n \n人体中的磁性原子人体中常见的磁性原子核如下图\n\n            \n        \n    \n            \n    人体中常见的磁性原子核    \n    \n\n  \n\n一般用于人体磁共振成像的原子核为氢原子核。但是并不是所有的H质子都能产生MRI信号，常规MRI的信号主要来源于水分子中的氢质子，部分组织的信号也可来源于脂肪中的氢质子。\n\n人体组织的水分子可分为自由水和结合水。结合水是指蛋白质大分子周围水化层中的水分子。自由水是指未与蛋白质结合在一起，活动充分自由的水分子。蛋白质和结合水的T2值都很短，采集不到这些信号。因此对于不含脂肪的组织，其MRI信号的直接来源是自由水。\n\n进入主磁场后人体氢质子核磁状态发生变化\n人体中氢质子自旋将产生无数个小核磁，但是由于方向杂乱无章，因此在自然状态下无明显磁性。MRI仪器无法检测每个氢质子产生的小核磁，仅能探测宏观磁化矢量的变化。当人体进入主磁场后，质子自旋产生的小磁场与主磁场平行排列，平行同向者略多于平行反向者，相互抵消后组织中最后产生一个与主磁场方向一致的磁化矢量，称作宏观葱香磁化矢量。\n\n            \n        \n    \n            \n    进入人体后氢质子核磁状态改变    \n    \n\n  \n\n之所以会有一些核磁与主磁场同向平行还有一些核磁与主磁场反向平行，涉及量子力学，简单解释：两种核磁代表的质子能量差别，平行同向的质子处于低能级，因此受主磁场的束缚，其磁化矢量的方向与主磁场的方向一致；平行反向的质子处于高能级，能够对抗主磁场的作用，处于低能级的质子多于高能级，整体产生一个宏观纵向磁矢量。\n\n            \n        \n    \n            \n    处于不同能级的氢质子核磁状态不同    \n    \n\n  \n\n随着温度、主磁场强度的改变，低能级多于高能级的氢质子数也将改变。一般在MRI系统中，温度是相对稳定的，因此只考虑主磁场强度的影响，主磁场越强，低能级多于高能级的氢质子数越高。\n\n            \n        \n    \n            \n    温度和磁场强度对宏观磁化矢量的影响    \n    \n\n  \n\n进动进入主磁场后，无论处于高能级还是处于低能级的质子，其磁化矢量并非完全与主磁场方向平行，而总是与主磁场有一定的角度。除了自旋运动外，其小核磁还绕着主磁场轴进行旋转摆动，这种运动叫做进动（precession）。\n\n            \n        \n    \n            \n    进动    \n    \n\n  \n\n进动频率  \n进动频率又称Larmor频率，其计算公式为:\n\n\n\n其中为磁旋比，B为主磁场的场强，单位T。可以看出进动频率与磁场强度成正比。\n\n\n由于进动的存在，质子自旋产生的小磁场又可以分解成两个部分，即纵向磁化分矢量和横向磁化分矢量。纵向分磁化矢量由低能级和高能级质子共同决定，低能级质子数多于高能级，因此纵向分磁化矢量与主磁场方向相同。由于质子在进动，其横向磁化分矢量会以主磁场方向为轴，在XY平面内做旋转运动，因此其方向处于不断的动态变化中。而各个氢质子的横向磁化分量在圆周的不同位置中，横向磁化分量相互抵消，所以没有宏观横向磁化矢量。\n\n            \n        \n    \n            \n    纵向与横向磁化矢量    \n    \n\n  \n\n宏观横向磁化矢量的检测 \n检测原理是初中所学过的电磁感应现象，闭合线圈在磁场中做切割磁感线运动会产生感应电流。\n如上所说，质子进动产生了纵向宏观磁矢量而不产生横向磁矢量，而纵向宏观磁矢量不切割磁感线，无法产生感应电流。（之后解释）\n\n            \n        \n    \n            \n    宏观横向磁矢量切割磁感线产生感应电流    \n    \n\n  \n\n\n磁共振现象  \n物理学上，共振被定义为能量从一个震动着的物体传递到另一物体，而后者以前者相同的频率振动，共振的条件是频率相同。\n如果我们给处于主磁场人体组织一个射频脉冲，这个射频脉冲的频率与质子的进动频率相同，射频脉冲的能量将传递给处于低能级的质子，处于低能级的质子获得能量后将跃迁到高能级，这种现象为磁共振现象。\n\n            \n        \n    \n            \n    磁共振现象    \n    \n\n  \n\n\n从宏观上看，磁共振现象使宏观纵向磁化矢量发生偏转，偏转角度与射频脉冲的能量有关，能量越大偏转角度越大。射频脉冲能量由脉冲强度和持续时间有关。\n\n            \n        \n    \n            \n    施加偏转角度不同的脉冲    \n    \n\n  \n\n90°脉冲 \n90°脉冲即使纵向宏观磁矢量偏转90°产生横向宏观磁化矢量，这时横向宏观磁化矢量最大。\n90°脉冲作用：\n\n90°使低能级质子跃迁进入高能级，使得低能级质子数与高能级质子数相同，因此纵向磁化矢量抵消。\n\n使质子的横向磁化分矢量处于同一相位。\n\n\n\n\n90°脉冲激发后组织中所产生的横向宏观磁化矢量的大小与脉冲激发前的宏观纵向磁化矢量的大小有关，而宏观纵向磁化矢量的大小与组织中的质子含量成正比。组织质子密度越高，其宏观纵向磁化矢量越大，90°脉冲激发后产生的宏观横向磁化矢量越大，切割接收线圈产生的电信号越强，MR信号就越高。\n\n核磁弛豫90°射频脉冲激发后的瞬间，组织中没有宏观纵向磁化矢量，而产生了最大的宏观横向磁化矢量；当90°脉冲关闭，我们可以注意到组织中的宏观横向磁化矢量从最大逐渐缩小到完全衰减，而宏观纵向磁化矢量从零逐渐恢复直至最大。这个过程即为核磁弛豫。\n\n            \n        \n    \n            \n    \n    核磁弛豫    \n    \n\n  \n\n横向弛豫90°脉冲使原来相位不一致的质子群处于同相位进动，质子小磁场的横向磁化分矢量相互叠加，从而产生旋转的宏观横向磁化矢量。90°脉冲关闭后，宏观横向磁化矢量衰减的是由于同相位进动额质子群逐渐失去了相位的一致，其横向磁化分矢量的叠加作用逐渐减弱。\n导致质子群失相位的原因主要有两个：\n\n质子周围磁环境随机波动。\n\n主磁场的不均匀。\n\n\n这种衰减称为自由感应衰减（free induction decay,FID）,也称T2*弛豫。\n180°脉冲可以消除主磁场不均匀造成的影响（之后解释），产生真正的T2弛豫，T2弛豫的能量传递发生于质子群内部，即质子与质子之间，因此T2弛豫也称自旋-自旋弛豫。\n\n            \n        \n    \n            \n    FID横向弛豫    \n    \n\n  \n\n一般用T2值来描述组织横向弛豫的快慢。从横向磁化矢量达到最大值为起点，以T2弛豫造成的横向磁化矢量衰减到最大值的37%为终点，起点与终点之间的时间间隔即为该组织的T2值。不同组织的T2值也不同，因此可以用T2加权成像（T2-weighted imaging,T2WI）方能区分不同的解剖结构，并能区分正常组织与病变组织。\n\n            \n        \n    \n            \n    组织T2    \n    \n\n  \n\n纵向弛豫\n当射频脉冲关闭后，在主磁场的作用下组织中的宏观纵向磁化矢量将逐渐恢复到激发前的状态即平衡状态，这一过程称为纵向弛豫，即T1弛豫。\n以90°脉冲为例，当脉冲关闭后，纵向磁化矢量将从零开始逐渐恢复至平衡状态。一般用T1值来描述组织的纵向弛豫的快慢。以90°脉冲关闭后，宏观纵向磁化矢量为零，以此为起点至宏观纵向磁化矢量恢复至最大值的63%为终点，这之间的时间间隔为T1值。\n纵向弛豫正好是与横向弛豫相反的过程，处于高能级状态的质子释放出能量回到低能级状态的过程。T1弛豫也可用来区分不同组织。T1弛豫能量释放快慢和质子周围的分子热运动频率有关，如果质子周围的分子热运动频率与质子的进动频率相等，那么质子能量释放的越快，纵向弛豫过程越短，T1越短，如果与周围分子的热运动频率相差较大，那么T1越长。\n\n            \n        \n    \n            \n    组织T1值    \n    \n\n \n\n磁共振信号磁共振线圈只能采集到旋转的宏观横向磁化矢量，而宏观横向磁化矢量切割接收线圈而产生的电信号实际上就是原始的磁共振信号。只要在接受时宏观横向磁化矢量越大，则采集到的电信号越大。\n自由感应衰减信号组织接受90°射频脉冲的激发，组织中将产生宏观横向磁化矢量，射频脉冲关闭后组织中的宏观横向磁化矢量由于受T2弛豫和主磁场不均匀的影响，而指数形式较快衰减，即自由感应衰减。\n            \n        \n    \n            \n    自由感应衰减信号    \n    \n\n \n\n自旋回波信号把主磁场不均匀造成的影响剔除，采集到的信息才能真正反映组织的T2弛豫。所采用的办法是180°聚焦脉冲。\n \n从Z轴方向看XY平面，假设质子逆时针进动，且进动方向保持不变。90°脉冲激发后质子的横向磁化分矢量相位一致。随着时间的推移，由于主磁场不均匀，质子的横向磁化矢量逐渐失相，到了180°脉冲施加前的即刻，质子1进动最快相位走在最前，质子4进动最慢，其相位落在最后；施加180°聚焦脉冲后，所有质子的相位反转了180°，即进动最慢的质子4的相位到了最前面，进动最快的质子1相位落到后面。\n\n\n            \n        \n    \n            \n    180°聚焦脉冲机制    \n    \n\n \n\n质子1依然进动最快，质子4进动最慢，所以随着质子群的推移，质子群相位逐渐重聚，将形成一个逐渐增大的宏观横向磁化矢量。经过与Ti相同的时间即2倍Ti时刻，进动最快的质子1赶上进动最慢的质子4。将形成最大的横向宏观磁化矢量。从此刻开始由于磁场强度分布不均匀，又将开始自由感应衰减。产生的这种回波信号称为自旋回波（SE）。\n\n            \n        \n    \n            \n    180°聚焦脉冲机制    \n    \n\n \n\n\n梯度回波信号梯度回波的产生过程是:如果人为的再添加一个磁场梯度，使磁场的不均匀程度更大，那么就会进一步加速T2*衰减，经过一段时间，将磁场梯度翻转。之前磁场强度较低的地方反过来具有较高的磁场强度，之前旋转得慢的原子核就旋转得更快了。相应地，之前磁场强度较高的地方反过来具有较低的磁场强度，之前旋转得快的原子核就旋转得更慢了。经过一定时间，之前的失相位就会被抵消，不同位置处的原子核相位重新同步，它们的磁化向量的方向分布更集中，这些向量之和的幅值就逐渐增大了。此时测得的信号就是一个梯度回波信号\n值得注意的是，只有施加磁场梯度产生的失相位才在添加反向磁场梯度后被抵消，由于其他原因产生的磁场不均匀 (例如BO的不均匀)是不会被抵消的，因此梯度回波的幅值是由T2*决定。\n\n            \n        \n         \n            \n    \n    梯度回波信号    \n    \n\n \n\n参考《磁共振成像技术指南》—— 杨正汉\n懿氏百科全书\n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（五）：K空间","url":"/2023/06/01/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AK%E7%A9%BA%E9%97%B4/","content":"K空间和傅里叶变换在之前的学习中一直参考的是《磁共振成像技术指南》这本书，但是看书还是无法理解K空间和相位编码部分的知识。在网上找了一些资料看了一下，决定看看这部分数学推导，这样应该可以帮助理解。\nK空间数学原理在主磁场的+z方向上的梯度磁场激发下，假设某一个平面h(x,y)的进动频率为f0，那么理论证明，该切面产生的FID信号可以表示为\n\n上述公式推导过程非常复杂，我并没有看太懂 贴个连接 MRI原理-信号 有解释\n现在要通过S(t)把h(x,y)表示出来，h(x,y)表示二维的灰度值图像，那么该图像的频域表达式可以写为\n\n我们如果能求出H（u,v），那么就能通过傅里叶变换求出h(x,y)。\n于是，为了求解H(x,y)，人们引出了x和y方向上的梯度场，以此来标明连续空间中，不同位置的点在位置特定的场强（B0 + zGz和该点的Gx和Gy的矢量和）下对FID信号做出的贡献。\n则在原先f0的场强变为（xGx,yGy,B0+zGz）的一个矢量，f0就变成与x和y相关的函数\n\n上式对比二维傅里叶变换可得\n\n其中 , \n所以得到的S（t）经过解调制后，就能得到H（u,v），然后再进行傅里叶变换就可以得到原始图像信号。由有限个H（u,v）填满的矩阵，就叫做K-space。而为了填满K-space，不断的改变梯度场时间t， 和梯度场大小的操作， 就叫做频率编码和相位编码。\n\n            \n        \n    \n            \n    GX与GY在K空间的效应    \n    \n\n \n\n频率编码通过上图可以发现，当Gy为零时，Gx所持续的是填Tx共同决定了K空间的Kx轴，相反，Gy和Ty共同决定了Ky轴\n习惯上我们先沿着X轴方向采集信号，其中采集信号的方式就是采用脉冲时间序列。\n            \n        \n    \n            \n    在X方向上采样    \n    \n\n \n“slice refocusing gradient\" 这里的作用是当RF脉冲序列的频宽过大，与之发生共振的组织也会更多，共振频带过大，这导致切片出来的信号会出现小幅度的相位差，从而使得采集图像模糊。因此这里会加上一个slice refocusing gradient，使得RF频带中的组织都在一个比较小范围差的频率下发生共振。\n\n\n\n我的理解是由于进动频率由磁场强度决定，所以原来的激发范围很大，加上相反的磁场强度后，位于前面的质子频率增大，位于后面的质子频率减小，最后得到了一个相对小的激发频率带宽。\n            \n        \n    \n            \n    大概理解    \n    \n\n \n\n这里Gx不变，在Tx采样表示，在X轴上朝右移动。\n每次采样中，同一个x位置下的组织产生的是相同的共振频率。这也就是说，Kspace中，垂直于x轴线的每一条采样轨迹(trajectory), 都具有相同频率分布。换句话说，在kspace这一二维坐标系下，同一个横轴坐标表示具有同一个频率。这种采样方法形成的轨迹被叫做笛卡尔采样轨迹(Cartisan Trajectory)。而这种在x轴方向上固定梯度磁场大小，只改变磁场时间的采样方式，就叫做频率编码。\n为了能够既采样负x轴方向，又采集x的正轴方向，人们选择先从x轴的负方向出发一直到最左端，然后再掉头往x的正方向去。因此需要先加上一个负梯度，然后才是正梯度。\n\n            \n        \n    \n            \n    梯度先负再正    \n    \n    K空间内填充顺序\n    \n\n\n\n负梯度施加一个周期后，施加正梯度两个周期正好把X轴的一行采集完毕。这种梯度场产生的回波信号叫做梯度回波信号（Gradient Echo, GE）\n相位编码相对的在y轴上实行相位编码。而实际中X轴做频率编码还是相位编码并不是固定的，这两个轴采样方法可以反过来。\n\n            \n        \n    \n            \n    相位编码    \n    \n\n \n如果固定x轴的梯度Gx和磁场时间tx，即使得信号只沿着K-space的y轴发生平移，然后不停的改变Gy的大小，这造成了y方向上的每一个组织点都有不同的磁场大小，由此会导致不同的拉莫尔频率，而不同的拉莫尔频率又会导致组织点们out of phase，与之前学习的相位编码相同。在这里不同的Gy代表了不同Ty时刻Y轴的等间隔采样。这种采样方式称为相位编码。\n\n            \n        \n    \n            \n    填充K空间和傅里叶反变换后成像    \n    \n\n \n\n\n参考《磁共振成像技术指南》—— 杨正汉\n知乎：MRI—从产生信号到生成图像（二)   作者：嘭噗啪嚓吧\nMRI原理-信号   \n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（四）","url":"/2023/05/24/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"磁共振的空间定位地球上的纬度的定位依靠地磁梯度，实际上磁共振信号的三维空间定位也是利用三套梯度线圈产生的梯度磁场来实现的。MR信号的空间定位包括层面层厚的选择、频率编码、相位编码。\n层面和层厚的选择在1.5T场强下，质子进动频率约为64MHZ。在Z轴施加一个梯度场，在Z轴中心质子进动频率依然为64MHZ，靠近头部磁场逐渐减小进动频率变慢，靠近脚部磁场逐渐增大进动频率变大。假设梯度磁场造成进动频率差为1MHZ/cm，则使用63.5~64.5MHZ的射频脉冲，被激发层面的中心位置就在Z轴中心，厚度为1cm。\n            \n        \n    \n            \n    层面和层厚选择    \n    \n\n  \n\n在检查部位与层面选择梯度线圈的相对位置保持不变的情况下，层面和层厚受梯度场强度和射频脉冲影响的规律如下:\n\n梯度场不变,射频脉冲的频率增加,则层面的位置向梯度场高的一侧移动。\n梯度场不变，射频脉冲的带宽加宽，层厚增厚。\n射频脉冲的带宽不变,梯度场的场强增加,层厚变薄。\n\n频率编码经过选层得到的信号是一个二维层面所有的信息，需要进行频率编码和相位编码来区分方向。以头颅的横断面为例，在前后方向施加前高后低的梯度场，这样前部的质子进动频率高，后面的质子进动频率低。采集到的MR信号中就包含有不同频率空间的信息，经过傅里叶变换后可以区分出不同频率，分配到前后方向各自的位置上。\n            \n        \n    \n            \n    频率编码    \n    \n\n  \n\n\n相位编码频率编码只实现了区分前后位置，并没有左右位置的信息，因此需要相位编码来区分左右。在左右方向施加一个左高右低的相位编码梯度场，这样左右质子的进动频率就不同。进动频率不同会导致一段时间后质子的相位改变，这时关闭梯度场，这样相位的差别就会被保留下来。这时采集MR信号带有不同的相位信息，通过傅里叶变换可以区分不同相位的信号，实现了左右方向的空间定位。\n            \n        \n    \n    \n            \n    相位编码    \n    \n\n  \n\n由于傅里叶变换的特性，只能区分180°相位的信号。（此处不理解，在网上看到有说这里说法是错误的）因此如果矩阵是256×256的图像需要进行256次相位编码。\n            \n        \n    \n            \n    相位编码实际施加    \n    \n\n  \n相位编码的知识还是有点难理解，下一篇从数学角度进行解释\n\n参考《磁共振成像技术指南》—— 杨正汉\n","categories":["影像基础"],"tags":["MRI"]},{"title":"远程保存hexo博客仓库","url":"/2024/03/13/%E8%BF%9C%E7%A8%8B%E4%BF%9D%E5%AD%98hexo%E5%8D%9A%E5%AE%A2%E4%BB%93%E5%BA%93/","content":"问题来源博主之前用的是笔记本，最早的博客都存在笔记本上，读研之后电脑设备增多，工位一个，宿舍一个。如果用之前的方法，每个电脑上都保存一个博客数据，更新起来很不方便。于是我想到这个问题正好可以用Github解决（Github使用不熟练），所以在网上找了一个方法，本篇博客为记录并且复刻方法。\n参考: hexo个人博客：换了电脑怎么办\n解决方案首先需要知道，hexo生成的静态文件会放在public&#x2F;文件夹中，部署就是把public文件夹中的内容上传到git仓库中。\n\n方案一：在github仓库上新建一个仓库，然后把blog文件夹上传进行备份。\n\n方案二: 在博客仓库创建一个新的分支，使用分支来管理。\n\n\n步骤本文采用方案二\n1.拷贝远程仓库进入D盘，右键点击Git bash here\ngit clone git@github.com:maxiro-samurai/maxiro-samurai.github.io.git\n把项目文件夹拷贝到本地\n2.删除文件夹内容进入maxiro-samurai.github.io.git项目文件夹中，删除其中的内容，把blog文件夹（即备份的blog）下全部复制到其中\n3. .gitignore文件打开.gitignore文件，这个文件的作用是指定哪些文件上传的时候可以忽略，因为blog&#x2F;的文件并不全部都需要\n.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/\n意思就是上传的时候忽略以上内容\n4.创建一个hexo（任意名字）的分支并切换到这个分支git checkout -b hexo \n\n把所有文件添加到暂存区\ngit add --all\n\n提交到本地版本库\ngit commit -m &quot;&quot;\n\n推送hexo分支的文件到github仓库\ngit push --set-upstream origin hexo\n\n5. 结束\n效果\n\n这个就是最后需要备份的文件夹\n6.更新博客\n生成草稿\nhexo new draft 远程保存hexo博客仓库\n\n\n发布博客\n  hexo publish 远程保存hexo博客仓库\n  hexo g \n  hexo d\n\n\n更新备份\n  git add.\n\n  git commit -m&quot;注释&quot;\n\n  git push origin hexo\n\n\n\n至此大功告成，在新电脑上只需要从远程仓库clone到本地，然后按照上述步骤进行更新博客即可\n","tags":["杂记"]},{"title":"重新开始的模电生活（一）","url":"/2022/03/25/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前言重学模电，不光理论，必须实践，实物搭建可能没有，用仿真软件Micro-cap，发现比Multisim强大，一起学了以后肯定用到。  \n教材资源参考《新概念模拟电路》下载地址：https://www.analog.com/cn/landing-pages/002/yang-e-book.html\nJFET 结型场效应管——晶体管内部载流子十分复杂，实际应用中只关注特定的几个参数，不展开\n\n晶体管分为NPN与PNP管\n            \n      \n  \n          \n  晶体管类型    \n  \n\n\n\n具体参数分析  \n以2N3415为例看数据手册 pdf连接：https://html.alldatasheet.com/html-pdf/50004/FAIRCHILD/2N3415/405/1/2N3415.html\n\n\n\n            \n        \n    \n            \n    2N3415 datasheet    \n    \n\n\n\nVCEO ：集电极到发射极最大电压\n\nVCBO ：集电极到基极的最大电压\n\nVEBO ：发射极到基极的最大反向电压\n\nIC ：集电极电流（正常工作下最大电流）\n\nPD : 功耗  \n\n耗散功率，也称集电极最大允许耗散功率PCM，是指晶体管参数变化不超过规定允许值时的最大集电极耗散功率。耗散功率与晶体管的最高允许结温和集电极最大电流有密切关系。硅管的结温允许值大约为150°C，锗管的结温允许值为85°C左右。要保证管子结温不超过允许值,就必须将产生的热散发出去。\n\nBJT的总耗散功率为Pc=IeVbe+IcVcb+Icrcs≈IcVcb），并且Pc关系到输出的最大交流功率Po：Po=(供给晶体管的直流功率Pd)–(晶体管耗散的功率Pc)=[η/(1–η)]Pc∝Pc，即输出交流功率与晶体管的耗散功率成正比（η=Po/Pd是转换效率）。晶体管功率的耗散(消耗)即发热，如果此热量不能及时散发掉,则将使集电结的结温Tj升高,这就限制了输出功率的提高；最高结温Tjm（一般定为175oC）时所对应的耗散功率即为最大耗散功率Pcm。为了提高Po，就要求提高Pc,但Pc的提高又受到结温的限制，为使结温不超过Tjm，就需要减小晶体管的热阻Rt；最大耗散功率Pcm∝1/Rt。最高结温Tjm时所对应的最大耗散功率为(Pcms≥Pcm)：稳态时，Pcm=(Tjm–Ta)/Rt；瞬态时，Pcms=(Tjm–Ta)/Rts。\n\n\n\nR : 热阻jc，芯片的热源结到封装外壳间的热阻，乘以发热量即获得结与壳的温差。\n\n一般热阻公式  = （散热良好）\n否侧  =（）\n如果为小功率器件，那么公式应为  =\n\n\nICBO : 集电极漏电流。\n\nIEBO ：发射极漏电流。\n\nhFE : 直流电流增益即β\n\n\n输入伏安特性\n晶体管的输入伏安特性，是指基极电流 iB与发射结电压UBE之间的关系——可能受到UCE的影响。\n\n\n\n\n仿真电路图\n\n\n            \n        \n    \n            \n    2N3415电路    \n    \n\n\n\n\n输入伏安特性曲线            \n      \n  \n          \n  输入伏安特性曲线    \n  \n\n\n\n输入伏安特性曲线与二极管类似\n输出伏安特性\n晶体管输出伏安特性，是指一个确定的基极电流iB下,集电极电流iC与 UCE之间的关系。\n\n\n电路图同上修改仿真软件的参数即可\n            \n      \n  \n          \n  参数具体修改    \n  \n\n\n\n输出伏安特性曲线\n  \n              \n          \n      \n              \n      输出伏安特性曲线    \n      \n  \n  \n\n\n放大区 ：满足 \n饱和区 ：一般分界电压为0.3V，压降很小而iC很大\n截止区 ：有漏电流，所以截止区也有电流，不过很小\n\n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（三）","url":"/2022/03/31/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%89%EF%BC%89/","content":"动态响应求解输入为动态，输出也为动态的求解步骤  \n\n  \n\n输入信号只保留变化量，输出也指标是变化量（不关心频率） \n电路中的电压不变点接地，电路中电流不变支路开路 （详细解释看书）\n电路中某个元件再某个范围内，可以用直线表示其伏安特性，且输入变化过程中，该元件始终在直线上，则该元件可以用其动态电阻代替\n\n\n按照上述规则可以画出新的等效电路  \n  \n双极性晶体管的动态模型——微变等效模型低频等效当输入变化量 非常小时，可以把输入特性曲线在Q1看成一小段直线。对于输入伏安特性中的任意静态工作点有：  \nrbe即为动态电阻，在放大状态情况下，Q1点处的动态电阻可以近似表示为：  \n其中rbb’为体电阻，一般为几到几百，UT常温下为26mV。 \n当峰峰值为,就会产生峰峰值为的电流波形，两者的比例关系，近似为rbe。\n  \n\n            \n        \n    \n            \n    晶体管低频等效    \n    \n\n    \n\n高频等效不做解释（看模电书）\n\n            \n        \n    \n            \n    晶体管高频等效    \n    \n\n  \n\n动态分析三个重要指标\n\n电压放大倍数也叫电压增益，用Au表示，也可以用G表示，无单位。当输入正弦波峰峰值为ui，输出正弦波峰峰值为uo，电压增益为：\n\n\n  \n\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;也可以用分贝表示:\n\n\n\n输入电阻ri：\n\n\n它属于动态电阻，多数情况下希望放大电路的输入电阻越大越好。\n\n\n输出电阻ro：\n\n\n指输出端带负载的能力。输出电阻越大带负载能力越弱。\n\n动态分析的步骤\n以晶体管微变等效模型为核心，针对原始电路画出动态等效电路  \n  1.对电路中的电压不变点，实施接地。  2.对电路中的大电容，实施短接。对电路中的小电容，实施开路。  3.将晶体管，用晶体管的微变等效模型进行替代。  4.稍作整理\n\n\n\n            \n        \n    \n            \n    简化电路图    \n    \n\n  \n\n\n依次求解Au、ri根据动态等效电路，可以很轻松得到如下结论：\n\n\n输入电阻为:  \n\n求解Ro  ：\n  按照下图  \n              \n          \n      \n              \n      放大电路框图    \n      \n  \n    \n\n\n先扔掉负载电阻。任何放大电路的输出电阻，都与负载电阻无关。  \n让输入激励源=0，对电压输入短接即可，此时受控源一定变为0。  \n在输出端加一个虚拟电压源Uv，在电路中计算由此引起的iv  \n\n                                                    求解输出电阻              \n  \n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（二）","url":"/2022/03/29/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"晶体管的工作状态\n截止状态：晶体管基极没有产生明显的电流，即IBQ非常小，导致ICQ也很小，晶体管没有导通。\n\n\n\n\n放大状态：指IBQ合适，且满足\n\n\n\n\n饱和状态：UCEQ小于UCES晶体管就处于饱和状态\n\n倒置状态：C和E管脚接反，此时晶体管 下降严重\n\n\n\n状态判断\n            \n        \n    \n            \n    判断法则    \n    \n\n\n\n\n静态估算步骤\n  1.根据UBEQ=0.7V，利用戴维南等效，KCL，KVL求解出IBQ  2.假设晶体管处于放大状态，列出集电极回路方程解出UCEQ  3.如果UCEQ&gt;=0.3V,则假设成立，反之不成立，晶体管处于饱和状态，UCEQ=0.3V\n\n\n  \n\n图解法求解静态工作点\n            \n        \n    \n            \n    电路图    \n    \n\n  \n\n输入伏安特性的图解法根据电路列出方程  \n\n该直线与输入伏安特性曲线的交点为Q（UBEQ,IBQ）\n\n            \n        \n    \n            \n    输入伏安特性图解    \n    \n\n  \n\n改变RB的值会改变直线跟曲线的交点\n\n输出伏安特性的图解法可列出方程该支线与输出伏安特性曲线的交点为Q（UCEQ,ICQ）\n\n            \n        \n    \n            \n    输出伏安特性图解    \n    \n\n  \n\n\n\n可发现改变RB的大小会改变输入曲线的交点，进而影响输出曲线上的点的位置，同理改变RC和EC都能达到同样效果\n  \n两部件串联分析法\n分别画出两个部件的伏安特性曲线\n以部件B的伏安特性曲线为基础，在图中找到横轴等于Ui的位置\n以此为中心点，部件A的伏安特性曲线实施横向镜像，绘制再原图中，此时，两根曲线会有一个交点，交点横轴即为输出电压，纵轴就是输出电流。\n\n\n            \n        \n    \n            \n    输出伏安特性图解    \n    \n\n  \n\n三极管同理  \n \n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（五）","url":"/2025/02/20/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%BA%94%EF%BC%89/","content":"大信号下情况的失真分析基本上分为超范围失真和非线性失真\n饱和失真和截至失真当晶体管进入截止区产生的输出波形失真，称为截止失真；进入饱和区产生的失真为饱和失真。\n使用仿真电路图如下：\n输入信号为1mV 5Khz\n经过之前的静态计算，可知VF1= 5V，在此静态下，放大电路可正常工作。\n输出端电压波形如下\n\n当把Rc增加为1.5K时，静态工作点VF1 = 2.5V左右\n输入信号10mv，即降低静态工作点，增大输入信号，输出将发生饱和失真。\n\n这是因为静态工作点VF1很小，在基极电流Ib变化过程中，UCEQ&lt;0.3V，进入饱和区导致输出截止。\n如果减小Rc到200Ω，并且增加输入信号幅值为100mv，输出将发生截止失真。\n\n因为Uc点的电压最高不能超过电源电压，晶体管截止就出现了截止失真。\n如下图所示 \n失真电压裕度失真电压裕度：在一个晶体管放大电路中，输入为正弦波电压信号，输出所能达到的最大的不失真正弦信号的幅度，用表示。\n因此\n如果当前静态工作点为Q（UCEQ,ICQ）则饱和失真电压裕度为：截止失真电压裕度为：\n\n\n\n静态负载线和动态负载线静态负载线，描述了EC和电阻RC不变的情况下，静态工作点改变收到的约束。而动态负载线，描述了电路开始工作之后——uce和iC在变化中收到的约束\n静态负载线，即分析静态下电路输出回路。  \n动态负载线，即分析动态下电路输出的回路。\n  \n\n对饱和失真电压裕度：\n\n对截止失真电压裕度：\n\n\n实际电路的失真——非线性失真   \n实际情况需要考虑输入伏安特性的非线性，在还未达到超范围失真时，ib就已经失真了。\n\n放大电路如下，输入信号有效值为1mV时，可以看到无明显失真。\n\n输入信号有效值为20mV时，可以看到明显的馒头状失真。\n\n改良4电阻放大电路两电阻放大电路由于静态工作点由IB和β决定，所以会受β影响。这就会导致温漂，静态工作点在不同温度下不一样。所以引出4电阻放大电路，电路图如下所示\n\n基极电压由RB1和RB2分压所得，相比一个电阻确定更加稳定，在发射极引入一个电阻引入了负反馈。静态工作点与β关系很小，静态工作点相对稳定。公式具体看书上。\n单管放大电路的静态工作点选择静态工作点由(ICQ,UCEQ)决定\n\nUCEQ一般情况下应选择动态负载线的中心位置，以保证较大的失真电压裕度。\n\nICQ在低功耗设计中，尽量让ICQ小。这样会导致输入电阻增大，电阻噪声增大。使用大电流，会给输入电流变化带来足够的空间，有利于抗干扰。\n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（六）","url":"/2025/02/21/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E5%85%AD%EF%BC%89/","content":"多级放大电路之前分析过了，共射极、共基极、共集电极放大电路各有优缺点。多级放大电路就是将三种组态的放大电路通过合适的方式级联起来，以增大放大倍数、增加输入电阻、减少输出电阻、增大功率、扩展频带。\n直接耦合两级放大电路直接用导线、电阻连接。\n优点：\n\n直流电压或者低频信号放大\n\n缺点：\n\n前级静态工作点会影响后级静态导致计算麻烦，并且后级静态工作点很难稳定。\n\n阻容耦合使用隔直电容将两级放大电路连接起来，利用后级输入电阻和此电容组成阻容耦合。\n优点：\n\n静态互不影响，各级静态工作点比较好选择且容易稳定。\n\n缺点：\n\n无法放大直流信号，对低频信号有较强的衰减作用。\n\n方框图求解多级放大电路任何一个电压放大器都包含输入电阻ri，空载放大倍数Au，以及输出电阻ro，在动态分析中把每一级放大电路都画成方框图，然后再级联起来就很方便获得最终结果。\n\n\n其中常数K1,2,3是电阻分压比\n其中需要注意，在上述方框图，共射极电路和共基极电路完全适合，但对共集电极电路不适用，因为共集电极电路（射极跟随器）的输入电阻与后级的输入阻抗有关。具体操作就是，第一级的输入阻抗包含第二级的输入阻抗，而共集电极电路的输出阻抗看做0。\n如下图\n可以等效为\n输出电压表达式： \n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（四）","url":"/2022/04/03/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"共基极、共集电极放大电路和PNP管电路晶体管放大核心“UBE变化，引起iB变化，映射出iC、iE变化”。所以，只有b，e两个极能够作为输入端。而输出信号一定在c或者e端。  \n  \n\n基极b输入，集电极c输出，叫共射极放大电路，全称为共发射极放大电路。  \n\n基极b输入，发射极e输出，这叫共集电极放大电路，也成射极跟随器。  \n\n发射极e输入，集电极c输出，这叫共基极放大电路。\n\n\n  \n晶体管有三个极，一个作为输入，一个作为输出，剩下什么极，就叫共什么极放大电路。\n  \n共基极放大电路  \n\n            \n        \n    \n            \n    共基极电路    \n    \n\n    \n\n\n静态分析 \n  1.戴维宁等效：   \n  \n  输入回路方程可解得：  \n    \n      \n  晶体管UCEQ&gt;0.3V,处于放大状态  \n  \n              \n          \n      \n              \n      静态分析结果    \n      \n  \n      \n\n  仿真结果稍有误差  \n     \n\n动态分析  \n  \n              \n          \n      \n              \n      动态等效电路    \n      \n  \n      \n\n\n列出节点电压方程：\n\n  Missing or unrecognized delimiter for \\left\\left{\\begin{array}{c}{u_e\\over R_E}={u_s-u_e\\over R_S}+(1+\\beta){0-u_e\\over r_{be}} \\\\beta{0-u_e\\over r_{be}}={0-u_o\\over R_L’} \\   \\end{array}}   \\right.\n  可以得到  \n  如果信号源内阻为0，可简化为\n  从以上可以看出，共基极放大电路与共射放大电路又相同的电压增益，只是极性为同相放大，共射为反相放大，输入电阻小。  \n\n输入电阻：  \n\n                                                    动态仿真结果                  \n  可以看出与理论计算差别不大   \n\n\n共集电极放大电路此电路又称射极跟随器，它与共射级、共基极电路唯一的区别在于，Rc可以为0。另外两个电路Rc的作用是把IB的变化转化为电压的变化，而此电路的输出端在发射极，所以RC不是必须。                                                            共集电极放大电路                    \n\n静态分析，与前面两个类似不分析  \n\n动态分析 ：  \n              \n          \n      \n              \n      动态等效电路    \n      \n  \n      \n\n\n电压增益：  \n\n    \n  多数情况下，Aui近似为1  \n\n输入电阻：  \n\n  很显然输入电阻远大于共射放大电路（rbe），更大于共基极放大电路的输入电阻（），这是设计跟随器的显著优点。  \n\n输出电阻：  \n\n  输出电阻很小\n    \n  设计跟随器，虽然不具备电压放大能力，但是第一具有电流放大能力，第二具有输入电阻大、输出电阻小的特点，使其在扩流、阻抗匹配中获得了广泛应用。  \n  应注意，共射、共基极电路输入电阻与负载无关，输出电阻与信号源内阻无关。但共集电极电路却不是如此。他的输入电阻与负载大小有关，而输出电阻与信号源内阻有关。\n\n\n\nPNP管放大电路动态分析与NPN完全一样  \n\n方法一：对PNP管的全部伏安特性，都实施反向定义  \n\n对所有电流方向，均与NPN管相反。\n所有点位差定义，也相反。\n\n\n方法二：遵循NPN的全部定义，所有求解的值是反的，所有的图，都从第一象限镜像到第三象限。\n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（七）","url":"/2025/03/03/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%83%EF%BC%89/","content":"场效应管分类和管脚定义场效应管分为结型场效应管（Junction FET）和金属氧化物场效应管（MOSFET），其中MOSFET又分为增强型与耗尽型两种，但在日常工作中市面上较多使用的是增强型MOS。\n\n注意，在JEFT中，源极和漏极是对称的可以互换位置，在MOSFET中衬底和源极在内部已经连通，很多MOS管D、S之间并联了一个二极管，因此D和S不能互换。\n结型场效应管转移特性曲线在TINA中仿真一个N型JFET，其中设置GS电压为控制对象，在栅极和源极分别串联一个电流表，如下图所示：\n\n因为场效应管GS之间的电阻非常大，几乎可以看做断开，所以流入的电流也很非常小。转移特性曲线仅关注VGS与VDS之间的关系。在直流分析中选择直流传输特性，V1输入电压范围为-5~5V。得到下图所示转移特性曲线。\n\n\n当VGS小于某一电压时，管子关断，此时这个电压叫做夹断电压UGSOFF。\n\n当VGS大于UGSOFF但小于0.7V时，管子处于导通状态，电流随VGS增大。\n\n还可以观察到当VGS大于某一值时，电流反而随着VGS增大而减少。这是由于电压过大，管子被击穿。从图中可以看出，VGS大于0，ID还有增长的趋势，但此时G、S之间就不再是高阻，即GS之间电流也增加。\n\n当VGS=0时，漏极电流称为零偏漏极电流，这是N-JFET能提供的最大电流。\n\n\n数学表达式：\n分界点电压：\n输出伏安特性曲线选择V2在020V变换，选择V1为控制对象，使V1在-20V之间变化，就可以画出在VGS不同电压下的输出伏安特性。\n\n\n可以看出这个曲线跟晶体管输出伏安特性曲线十分相似，在VGSOFF&lt;VGS&lt;=0时，VDS在小于某一电压时，IDS随着VDS增大而增大，这一段类似晶体管的饱和区。\n\nVDS在大于于某一电压时，IDS几乎不再增加，看起来像恒流源一样，称作恒流区类似晶体管的放大区。\n\n\nMOSFETMOSFET中包含耗尽型和增强型，耗尽型的伏安特性曲线与JFET非常相似，区别在于：它允许UGS大于0。\n增强型NMOS伏安特性曲线\n\n开启电压UGSTH：当UGS小于开启电压时，无论多大UDS电流iDS均为0，只有当大于开启电压时，晶体管才可能存在电流。\n\n转移特性曲线的数学表达式：\n\n可变电阻区与恒流区分界线：\n\n\n\n三电阻MOSFET电路的静态分析结合之前的电路分析方法与FET的特点对静态分析，电路如下图所示\n\n分析要点：\n\n与晶体管电路相似，使用戴维南定理分析G极回路，得到栅极电压。\n\n跟晶体管特性不同，我们要先假设MOS工作在恒流区，然后根据假设计算出UDSQ是否达到开启电压，通过转移特性曲线公式进行计算。\n\nUDSQ＞UDS_dv，满足假设，管子处于恒流区。\n\n\n四电阻MOSFET电路静态分析\n四电阻共源极放大电路与上面三电阻的区别就是S极在静态添加了一个电阻，而这个电阻的作用与之前在4电阻晶体管作用类似，可以增加电路的稳定性，原理为引入负反馈。\n\n戴维南定理分析\n\n利用转移特性公式与UGS = UGQ-iDR5，解出UGS和iD（2次方程有两个解需要舍弃一个不满足开启电压条件的解）\n\n最后根据静态判断MOS管是否在恒流区\n\n\nJFET电路的静态分析\n由于JFET的UGS小于0才能开启，上述电路图关键点在于仅使用一个正电源和R2便能使得JFET开启（自给偏压电路）。\n\n分析类似，UGQ一定是0V因为G极没有电流，JFET转移特性曲线方程与UGSQ = -IDQ*R2联立可以解出IDQ和UGSQ\n\n得到两个解要满足直线与平方曲线小于UGSOFF的交点\n\n\nFET微变等效模型对GS两端施加微变电压信号，无法产生电流变化（无伏安特性曲线），使用转移特性来研究。\n\n定义跨导为gm，单位为西门子 S:\nQ点上升，其切线斜率上升，跨导变大。对于JFET和MOSFET，无论增强型还是耗尽型，其微变等效模型都如下图所示\n\n\nJFET对转移特性曲线曲线求导可得：\n说明，某个Q点的跨导，与晶体管本身影响曲线斜率的参数UGSOFF、IDSS、IDQ有关。\n\nMOSFET对转移特性曲线曲线求导可得:\n\n\n\nJFET放大电路的动态分析上面已经解过JFET放大电路的静态，下面直接进行动态分析，动态分析需要得到静态参数。\n动态等效电路图画法与晶体管类似。\n\n求解Au时，把Uo和Ui都写成Ugs的函数可得： \n\n输入输出电阻求法与晶体管一致。  \n\n\nMOSFET共漏极放大电路的动态分析与晶体管共集放大电路相似，属于MOSFET中的“射极跟随器”。\n\n静态：\n\n戴维宁以及环路方程与MOSFET转移曲线方程联立可得IDQ，UGSQ\n\n动态等效图\n 放大倍数\n 输入电阻很简单就是RG1与RG2并联\n\n输出电阻\n 信号源短接，从输出口接入一个信号源，从输出口中看进去的电阻\n \n 需要注意电流方向与电压方向\n \n \n\n\n","categories":["硬件","模电"]},{"title":"晶体管提升","url":"/2025/03/17/%E6%99%B6%E4%BD%93%E7%AE%A1%E6%8F%90%E5%8D%87/","content":"晶体管提高篇目前单独使用晶体管做放大电路情况很少，一般都用运放。这节介绍晶体管典型应用。\n恒流源实现高增益放大\n电路放大倍数为，当我们要求时，电压放大倍数无法被改变。\n因为改以上参数任何一个，静态电路会受到影响，另外两个也会受到影响，最终结果就是AU几乎不变。理论分析如下：\n\n\n可以看到AU仅与静态URc有关。\n我们把RC替换成一个恒流源，原理图如下：\n\n控制Q2的基极电流不变，Q2就成了一个恒流源，图中用一个固定电阻连接基极。\n那为什么接一个恒流源就可以增大电压放大倍数呢？\n这两个管子是串联在一起的，运用之前的两部件串联分析方法（图解）可以画出伏安特性曲线：\n\n红色线代表Q1输出福安特性曲线，绿色线代表Q2，黑色实线代表Rc。\n当固定电阻RB1和RB2，红色和绿色线就固定了。RB2选择十分困难，两个输出伏安特性曲线都非常平坦，稍微不合适，就会有一个管子进入饱和区。\n决定输出放大倍数的输出福安特性曲线的斜率，因为变化相同ic的情况下，斜率越大的曲线Uc变化越大。\n从上图可以看出绿色管子的动态电阻大于黑色实线，所以电压放大倍数增大。\n\n恒流源负载总结\n\n在UCE很大的变化范围内，ic基本保持不变（晶体管放大区）。针对变化量，c、e之间呈现一个很大的动态电阻。\n在Q2静态工作点处，呈现一个较小的静态电阻。\n将这样一个静态电阻小，动态电阻大的电路，接入到其他电路中，称为恒流源负载。\n\n\n\n","categories":["硬件","模电"]},{"title":"差分放大","url":"/2025/03/17/%E5%B7%AE%E5%88%86%E6%94%BE%E5%A4%A7/","content":"差分放大我们日常使用的信号源一般是两根线传输，一个地线，一根是信号线，这种信号叫做单端信号。单端信号在远距离传输过程中，不可避免的要受到外界电场的干扰，而差分信号抗干扰性很强。\n定义1：差分信号中两个信号线之间的差值信号，用uD表示：\n定义2：差分信号中两个信号线共有的信号，称为共模信号，用uC表示：（）\n在远距离传输过程中，因为两根线两根线距离很近，两根线都收到了相同的外界干扰。此时，差模信号是待测的有用信号，而共模信号是干扰。如果有一个差动放大器，他有两个输入端和两个输出端，而真正有意义的输出是两个输出端的差值。\n差动放大器先在仿真软件中模拟出差模和共模信号，电路图如下所示：\n\n信号源通过两个压控电压源（放大倍数均为0.5）正极输出和负极输出模拟差分信号，共模信号接在两个压控电压源之间。则\n$$\\begin{align*}\\left{\\right.\\end{align*}$$\n当关闭共模信号输入时可以用示波器看到，输入与差分信号的关系：\n每一路信号都是输入信号的0.5倍，VF2是VF3的反相信号，正好是原信号\n当接入共模信号时，可以看到每一路差分信号都是在共模信号的基础上叠加的。\n假设我们可以造出一个放大器，它能够实现分别放大两路差分信号，最后再把两个输出信号相减得到放大的有用信号。\n差动放大电路如下图所示：\n我们用示波器看Vin+和Vout+的结果，看信号是否被放大\n\nVout+信号是Vin+放大后的结果，但是又有点奇怪，因为我们还没有对Vout+和Vout-相减，它的输出就已经没有共模信号了，这是为什么？这正与我们期望的一样，我们希望差动放大电路可以放大差模信号，抑制共模信号。下面是理论分析：\n因为电路是线性电路，符合叠加原理，我们只看共模信号输入。首先按照分析步骤，先进行静态分析确定IBQ1，假设两边电路对称，只分析Q1管子：\n解出，\n动态分析我们直接不画动态等效图了，开始脑内脑补，基极电阻就只有RB1和rbe，需要注意发射极是两个管子射极电流并入到一个RE中，所以：\n\n\n得到单端共模放大倍数：单\n即共模信号被抑制。\n差模信号，假设Vin+有一个微小的电压增量，引起基极电流ib1变化，而电路对称所以另一个管子也有一个变化量，在发射极两个管子引起的变化正好大小相等方向相反，在动态分析中可以把两个管子的发射极看做接地（电压不变点）。\n单\n两个输出信号反向，如果我们差分输出可得：\n双\n带负载静态分析中，两个输出端电位相等，所以接入Rload不会对原静态电路造成影响。\n动态分析中。共模信号同理不会对原结果造成影响，不包含Rload。\n对于差模信号，仅在输出端改变。原动态等效图：\n动态分析中要熟练运用电压不变点看做接地，这一技巧，当仅有Vin+输入时，在Vout+引起电压变化+u，Vout-电压不变看做接地，即在Rload左端有电压变化，同理Vin-输入时，在右端有电压变化-u。而在Rload中间点处正负变化抵消，时电压不变点。因此等效电路图：\n\n解得：\n单\n双\n与不带负载时的区别是，在分子上并联了一个0.5Rload。\n单端带载首先静态会影响，输出端多了一个Rload分流。\n\n\n单单\n\n输入电阻：\n\n差模输入电阻：    差模回路的总电阻\n\n共模输入电阻：    左右两侧输入看进去的电阻并联\n\n\n\n输出电阻：\n\n单端：  \n双端：  \n\n\n\n共模抑制比定义：差模增益除以共模增益。差模信号放大越大越好，共模信号越小越好。\n\n用dB表示：  \n输出若为差分形式，如果电路完全对称，CMRR为无穷大。\n输出为单端形式，则将前述分析结果带入：\n\n提高CMRR在前面的例子中CMRR为几十倍，我们在实际生活中往往噪声信号大小比有用信号高了不止几十倍，我们需要更大的CMRR。看CMRR的表达式，只有提高β或者RE的值才能提高CMRR，往往β的提高是有限的，而我们如果提高RE的值，那么静态工作点也将改变。有没有一种方法，不改变静态IEQ，在动态时候可以让RE增的十分大。（静态不变，动态电阻增大）\n答案是上一节：恒流源电路！\n\n这个电路是书本上另一个示例修改的（P150），经过计算和仿真，源电路静态：\n\n\n\n动态：\n单\n单\n\n使用恒流源替代RE，并把恒流源静态电流调至与原电路相同。\n\n仿真结果中两个电路静态相差不大，主要看动态结果。\n单\n单\n\n加入恒流源对电路的主要影响是对共模信号抑制能力的增加，因为只看差模信号动态分析，不管在加不加恒流源，RE1和RE2中间为电压不变点，所以不会对差模放大倍数产生影响。\n在共模信号动态分析时就产生影响，恒流源表现出极大的动态电阻，图中这个管子在仿真软件中接近于理想三极管，所以VF2电压严格等于共模信号，因为几乎没有电流流过恒流源，最终共模放大倍数得到极大衰减。\nMOSFET恒流源在差动放大电路中管子全部使用MOSFET，电路如下所示\n因为书中MOS管参数使用multisim仿真，TINA中没有这个参数的管子，这里仿真数值与计算不同，只看分析方法。\n\n静态：\n  电路对称所以IQ1与IQ2相同，并且流入恒流源中，所以静态几乎是由恒流源的电流决定的。\n  求解IQ3静态电流：  \n  \n  \n  联立求解静态参数\n\n动态：\n  恒流源在动态分析中看做开路（看上面分析），并且Q1和Q2管子栅极无电流流入。动态等效如下：\n  \n  \n  \n  \n5个MOSFET  我们继续改进，在上面的基础上是否还能继续增加差模放大增益，注意观察表达式，增大Rc1和Rc2就可以再增加增益。  类比恒流源，下图为改进后电路\n  \n  上面的两个PMOS管电路叫做恒流源电流镜，保证了两个管子的静态电流相等。\n  我们用电流表量这两个管子上的静态电流，他们是相等的。\n  \n  使用示波器观察放大波形，如果输出波形失真就调节R3，来限制电流，使输出波形正常。\n  \n  交流电压档可以看出，这个电路单端输出电压增益为4150倍\n\n\n","categories":["硬件","模电"]},{"title":"电流镜","url":"/2025/03/21/%E7%94%B5%E6%B5%81%E9%95%9C/","content":"电流镜电流镜一般指1:1电流镜，由输入电流支路、输出电流支路组成，输出电流等于输出电流。\nBJT电流镜核心是两个晶体管的基极和发射极连在一起，以迫使两者具有相同的uBE，使其ib相等，进而保证iC。\n输出电流支路，当负载一端可以接地时，称为地型，否则为浮型。当输出电流为流出电流镜时，称为吐型，当输出电流流入电流镜时，称为纳型。\n\n\n厄利电压理想与现实总是差距很大，我们上面的分析都是在理想晶体管的前提下进行的，理想晶体管严格遵从，输出伏安特性曲线是一条直线，我们知道实际晶体管的伏安特性曲线是倾斜的，随着Uce增加，Ic也会增大。\n仿真中画出以下电路图：\n我们把R1看做控制对象，改变电阻的大小观察输出端的电流大小，理想情况，晶体管工作在放大区情况下输出端电流不会发生改变\n\n这个是仿真软件里面的理想晶体管\n下图是一个实际的管子：\n可以看到尽管在放大区，电流依然在减小。\n厄利电压——early voltage，描述的就是晶体管输出福安特性曲线的倾斜程度，美国工程师James M.Early发现每根输出福安特性曲线向左的延长线都会在横轴上一个负电压相交。\n这个电压取绝对值记作VAF\n\n\n其中rCE代表晶体管输出伏安特性中某根曲线的倾斜程度，越小越倾斜。其中定义，Ic0是饱和区与放大区边界的电流。\n当我们知道iB，就可以确定一根伏安特性线，也就确定了iC0，最后确定rCE:\n\nMOSFET组成的电流镜MOSFET门极没有电流，如果两个管子相同则，并且增强型MOSFET的开启电压一般比BJT的UCES=0.3V大，所以门极电位要高一点。\n\nMOSFET也有厄利效应，即UDS变化会影像输出电流。输出电流表达式为：\n\n其中表征输出伏安特性的倾斜程度。\n比例电流镜比例电流镜是电流镜的一种变体，它依靠R1和R2之间的比例关系，决定输出电流iout与输入电流i1的比值。\n\n工作原理：\n恒流源IS1迫使T1经过5mA电流，所以电阻VF2电压必然等于5V，恒流源会主动改变T1管子的G极电压，迫使ID1 = 5mA，此时T1、T2管子的G极电压相同，如果两个管子的福安特性曲线相同且R2=R3，那么输出电流Iout = Iin，改变R2、R3的比例则输出电流比例也会改变。\n分析：\n\n使用仿真软件得到MOSFET的转移特性曲线，将数据导出excel中，对其实施多项式拟合，得到曲线方程表达式。即得到管子的K、UGSTH等参数。\n\nR1上的电压必然是5V，根据算出的转移特性曲线可以得到Ugs、Ug1。\n\n管子T2满足转移特性曲线和实现方程：可求得iD2\n\n\n图解法分析：\n\n深蓝色曲线是MOSFET的专业特性曲线，红色直线是斜率倒数为R1 = 1000Ω，这是T1管满足的直线方程，与横轴交点为UG，两个管子门极电压相同因此，固定此点不变，改变斜率倒数为R3 = 500Ω，图中为绿色直线，是T2满足的直线方程。\n可以看出，R3越来越小，P2点会越来越高，电流越来越大。这种比例是近似的，因为伏安特性曲线毕竟是一个曲线不是直线。\nWidlar 电流源主要用在运放输入级中，一般输入级需要设置很小的集电极电流或者发射极电流，前述设计的电流镜需要使用较大的电阻。集成电路中制作大电阻比较困难。\nWidlar 电流源，也叫微电流源。他在上述电路基础上给输出晶体管增加了一个小电阻形成的。\n\n分析：\n\n根据晶体管福安特性曲线可得：\n带入两个管子：\n最后我们往往需求是已知iout，要计算RE的值。\n解得：\n举例——多路并联Widlar电流源要求：设计一个BJT组成的多路并联Widlar微电流源，供电电压为10V，电路中最大的电阻不能超过3KΩ，实现3路输出，电流分别为50μA，100μA，200μA。\n\n确定Rc并求解输入级电流iIN。\n 我们就把输入级电流越小越容易实现小电流。通过输入级回路可列出方程： \n\n输出级发射极电阻由上面公式确定：\n \n   仿真结果： \n\n\n威尔逊电流镜——Wilson Current Mirror上面讲的最基础的电流镜有两个缺点：\n\n输出电流是输入电流的β/（β+2）倍，与β相关。对MOSFET组成的电流镜没有这个缺点。\n\n输出级无法保持恒流，输出电流与晶体管的C、E压降密切相关，压降越大，输出电流越大。输出级一般有一个电压源，当负载电阻变化时，晶体管CE压降也会改变，从而导致实际输出不是恒流。\n\n\n\n改进核心是增加了第三个晶体管Q3，通过Q3的作用可以保证Q1和Q2两个晶体管的UCEQ非常接近，Q1是1.4V，Q2是0.7V，它们不再随负载电阻大小变化而变化，输出电流就会相对稳定。\n假设三个管子都相同，iB三个管子都一样。通过分析可得：\n\n\n输出电流会略小于输入电流，且两者误差约为，前述基础版电流镜输出电流误差远大于威尔逊电流镜。\n仿真如下：第一个图是基础版电流镜，控制负载电阻大小改变观察输出电流变化\n第二个图是威尔逊电流镜\n可以看到，改变负载电阻大小，只要管子工作在放大区，输出电流改变很小。\n四晶体管威尔逊电流镜在三晶体管的基础上增加第四个晶体管形成了4晶体管威尔逊电流镜\n注意这个分析过程，从Q3开始往下分析，其中Q1、Q2、Q3的UCQ是确定的不会随负载变化，不需要考虑厄利效应。对于Q4因为他与负载相连集电极电压随负载改变，所以要考虑厄利效应，它的ic=βib不成立。\n\nMOSFET威尔逊电流镜使用MOSFET管代替BJT管也可以形成威尔逊电流镜。注意：MOSFET没有门极电流，输入电流源的最低电位要很高，一般大于2倍的MOSFET开启电压UGSTH。\n\n把输入电流源换做一个电阻，T3管子有转移特性曲线和直线方程成立：\n\n\n解得：\n电流源的顺从电压和输出阻抗电流源一端为OUT另一端为COM，与负载连接的端子一定是OUT端，COM端则一般接固定电压源或者GND。\n顺从电压：电流源在保持输出电流在能够接受的范围内时，COM端和OUT端之间的需要的最小电位差，用绝对值表示。\n顺从电压越小越好，在相同的外部供电电压下，顺从电压越小，留给负载电阻的电压变化范围就越大。\n示例计算：P195\n恒流源 (Constant Current Source)一个电路或者器件的某个端子，在一定范围内的外电势作用下，能够流出或者流进恒定的电流，称为恒流源。一般来说有三类：1. 简易晶体管恒流源 2. 压流转换电路 3.  专用的恒流源\n下图是由PNP管组成的简易晶体管电流源。\n!\n可列出表达式：\n\n输出电流的设置主要靠RSET。这个电流源的顺从电压大约是1.4V（小有疑问？？？？）\n一般实际应用中，二极管三极管、电阻R1生产厂家已经产好，RSET靠用户设定。影响输出电流的还有外部供电电压VCC，负载电阻RL，以及温度。\n这个电流源对外部条件改变很敏感：\n\nVCC固定，温度确定管子IB确定，影响输出电流的只剩UCE，即输出电流的稳定性主要取决于晶体管的厄利效应。\n\n当负载电阻稳定，温度固定，VCC的增大将直接引起二极管工作状态的变化：电流变大，UDZ变大，导致晶体管IE变大，输出电流也就增大。UDZ的稳定性直接决定输出电流的稳定性。\n\n温度稳定性不高\n\n\n","categories":["硬件","模电"]},{"title":"模拟开关","url":"/2025/03/25/%E6%A8%A1%E6%8B%9F%E5%BC%80%E5%85%B3/","content":"模拟开关模拟开关是一个电子开关，用外部数字逻辑信号控制两个端子之间的电阻：导通时电阻极小、断开时电阻极大。\n模拟开关类型包括单刀单掷、单刀双掷、双刀单掷、双刀双掷型。\n刀：指一个信号控制的一个开关实体掷：电极杆可以投掷的位置，单掷就是开关只有断开或闭合，双掷是开关有两个方向断开或闭合。\n\n单刀单掷：Single Pole Single Throw——SPST\n单刀双掷：Single Pole Double Throw——SPDT\nBJT模拟开关电路图如下，电源需要正负电源供电，这两个晶体管一个是NPN管另一个是PNP管，它们并联在一起。两个开关就看做一个GPIO口的控制信号，两个开关同时打开或者关断。\n\n模拟开关导通时，T1管和T1管均是饱和导通状态，输入信号通过两个晶体管并联（更小的导通电阻），连接到负载。\n模拟开关截止时，T1、T2处于截止状态。\nMOSFET模拟开关按照模拟开关的特性，我们使用一个MOSFET或者晶体管就可完成，它们本来就是一个“开关”。\n\n当开关导通时：\n\n当RL与RDS相近时，输出电压会有衰减。\n\n导通时的RDS与UGS有关，而UGS会随着输入信号改变而变化，输出电压也会随之变化。\n\n\n我们往往想让模拟开关输出电压稳定，也就是让它的RDS稳定。这用一对互补MOSFET（CMOS）即可。\n\n此时的导通电阻RDS：\n\n可以看到RDS比较固定，所以输出电压也会相对稳定。\n负载开关负载开关是一个可控制的开关，它能决定是否给某个指定负载供电。例如：手机中GPS功耗较大，实现低功耗要让GPS在需要时工作，不需要时关闭。\n单晶体管负载开关当被控制的VIN与LOGIC IN 高电平属于一个电压系列时，比如都是3.3V，使用一个PMOS就可以实现负载开关。\n双晶体管开关在更多情况下，被控制的电压VIN远大于微控制器的逻辑电压，比如VIN = 20V，逻辑电平为3V，如果还是用单晶体管开关，能实现导通无法实现截止。\n\nQ1管导通与否取决于R1上面的压降，R1上压降大于PMOS管的UGSTH绝对值时他就会导通，只要流过一定电流，Q2管子正好控制流过R1管子的电流，只需我们控制Q2的栅极即可。\n","categories":["硬件","模电"]},{"title":"晶体管产品","url":"/2025/03/27/%E6%99%B6%E4%BD%93%E7%AE%A1%E4%BA%A7%E5%93%81/","content":"晶体管产品常见公司生产晶体管：\n安森美 ON Semiconductor [http://www.onsemi.cn/PowerSolutions/home.do?lctn=header]\n飞兆半导体（仙童） FAIRCHILD [https://www.fairchildsemi.com/]\n意法半导体 STMicroelectronics [http://www.st.com/web/cn/home.html]\n达尔科技 DIODES [http://www.diodes.com/index.php]\nIR  [http://www.irf.com.cn/irfsite/tac/tac.asp]\n英飞凌 INFINEON [http://www.infineon.com/cms/cn/?ic=0003001]\n具体幸好和参考单价，可以访问e络盟官网：[http://hk.element14.com/]\n数据手册查询网站 ：[https://www.alldatasheet.com/]\n虽然一般我都是在淘宝买翻新、盗版（做产品千万不要图便宜买这些！！！！！），淘宝的优信电子还可以。\n达林顿晶体管（Darlinton Transistor）达林顿管是由两个晶体管在内部实现连接，对外是3个脚的晶体管组和形式。他也有两种NPN和PNP型。\n\n由图可看出第一个管子的发射极电流充当了第二个晶体管的基极电流，因此第二个晶体管的发射极电流将是第一个晶体管积极电流的倍。因此达林顿管具有极高的电流增益。同时按照这种连接可以形成极高的输入阻抗。\n主要应用：\n\n输入电阻较大的第一级放大电路\n驱动大电流负载执行低速开关动作（数字电路提供的输出电流一般有限，使用这个管子放大输出电流可以驱动大电流负载）\n\n匹配对晶体管 （Matched Pairs）匹配对晶体管集成在一个单片内的两个晶体管，具有相似的特性。一般可做到相差10%以下，甚至1%以下。\n\n偏置电阻晶体管减少设计中使用原件数量，降低占用面积，将外部的电阻和晶体管集成到一个管子中，如图，称为偏置电阻晶体管，也叫数字晶体管。\n\n负载开关负载开关在前面的笔记中有原理详解，这里介绍的是负载开关模块。\n\n两个晶体管一个作为主管，实现负载开关功能，另一个管子是辅助管，负责主管的通断控制。\n稳流晶体管也被称为横流调节器（Constant Current Regulator），或者LED驱动器。\n\nR1约为4.7KΩ，R2约为47KΩ，外部电阻RC可以选为100KΩ附近。这个器件的工作原理是：当Rs顶部连接至7管脚时，7管脚也连接至Q2的基极，所以Rs两端的电压也是Ube两端的电压。所以可得\n只要我们知道Ube，即可算出ILED。\n这里是一个负反馈电路，由MOS管的转移特性曲线可知，电流大小ILED与UGS有关，而电流大小通过RS和UBE与RC上的电流联系在一起，进一步影响UGS，最终使得输出电流稳定。\n还有一种产品，他只有两个管脚，A和K，串联在电路中，就能保证留过他的电流是器件指定电流。用户只用保证电源电压减去LED组消耗的电压满足器件电压规定即可。\n\n","categories":["硬件","模电"]},{"title":"晶体管产品","url":"/2025/03/27/%E6%94%BE%E5%A4%A7%E7%94%B5%E8%B7%AF%E7%9A%84%E9%A2%91%E7%8E%87%E5%93%8D%E5%BA%94/","content":"晶体管放大电路的频率响应容抗和感抗在电路中学过电容的容抗和电感的感抗，回顾表达式：\n\n它们不消耗功率，在电路中同电阻一样，起到了阻碍电流的作用。低频段，电容容抗大，电感感抗小。\n在实际中，任何一个实体元件都存在寄生杂散（杂散电容或者杂散电感），它们在信号频率很高时呈现出来，是由于器件本身固有形状、尺寸、介质等产生的。\n任何一根导线，都存在电感，任何两个导体之间都存在电容。因此，寄生电感串联于宿主，寄生电容并联于宿主。\n对于晶体管来说，三个管脚之间存在寄生电容，晶体管PN结也存在寄生电容，一般情况下，外部寄生电容远小于内部寄生电容。\n\n在频率较低时，一般不会影响放大电路性能。但在频率较高时，对放大电路影响明显。\n放大电路的频率响应放大电路对不同频率的交流输入信号表现出不同的性能：1.幅频特性 2.相频特性\n频率特性图幅频特性与相频特性\n\n中频区：不考虑电容、电感存在时的，增益相对较为平坦的频率范围，增益用Am表示。(低频段、高频段都不是一个确定的范围，都只是相对而言)\n上限截止频率fH：从中频区开始向右，增益随着频率上升下降到中频区Am的0.707倍时，此时的频率用fH表示。\n下限截止频率fL：从中频区开始向左，增益随着频率上升下降到中频区Am的0.707倍时，此时的频率用fL表示。\n用dB表示时，截止频率在Am下降3dB处：\n阻容基本单元的频率响应低通基本单元\n输入输出关系如下：\n\n其中增益是一个复数，其中时增益的模，是幅角，表示输入输出相位差。\n设，为特征角频率，则有：\n\n仿真曲线如下：\n\n根据上述定义我们可以知道，当时，衰减0.707，所以就是上限截止频率。\n高通基本单元\n同理我们分析可得：\n就是下限截止频率\n\n两极判断法第一极：0Hz时，求此时电路增益用A0表示。第二极：频率为∞时，求解此时电路增益用A∞。\n判断规则：\n\n如果A0为有限值，A∞为0，则一定是一个低通滤波器\n\n如果A∞为有限值，A0为0，则一定是高通滤波器\n\n除此之外什么都不是，既不是低通也不是高通\n\n\n低通变形第一种：\n这种电路可以把两个电阻串联起来，就与低通基本单元一样，因为决定上限截止频率是表达式的分子和分母的结构，这两种电路的分母分子结构一样。截止频率不变。\n\n第二种：\n分析类似第一种，增益模值不同，但是上线截止频率相等。\n结论： 在一个电压源阻容串联回路中，如果从任何一个电容两端电压为输出，他一定是一个低通电路，上限截止频率为1/2πRC，R为串联电阻之和，C为电路中电容串联。\n第三种：\n可以利用戴维宁定理或者电路分析里面电流源等效电压源转换成上述电路。\n高通变形与低通分析类似，略。\n基本单元串联将多个低通模块串联，最终仍是低通效果。将多个高通模块串联，最终仍是高通效果。中频段增益。\n截止频率就复杂一点，简化处理：\n\n低通串联中  \n\n高通串联中  \n  \n  细致分析：  \n    \n\n\n\n串联级数\nK最小值\nK最大值\n\n\n\n2\n1\n1.099\n\n\n3\n1\n1.133\n\n\n4\n1\n1.148\n\n\n5\n1\n1.159\n\n\n\n低通串高通  fH&gt;fL，最后表现为一个带通环节。\n  \n\n\n晶体管放大电路非杂散频率响应看回最简单的NPN单管共射极放大电路\n\n图中这三个电容会影响放大电路频率响应，C1和C2作用是阻低频通高频，这是下限截止频率fL，CL通高频导致输出端高频信号减小，这是上限截止频率fH。\n这是非杂散电容对电路的影响，我们还没有考虑晶体管内部和管脚上的杂散电容，在晶体管高频等效模型中，存在3个结电容，会降低放大电路增益。再加上考虑到管脚上的寄生电容，信号频率升高增益会成倍数降低。这里暂时先不考虑。\n下限截止频率\n可以看出等效电路分成三个模块，三个模块级联关系如下图：\n\n其中\n\n因此，求解电路整体的下限截止频率，需要知道每个模块的下限截止频率，这样就可以利用上面的结论。\n单独分析每个模块\n\n模块1：\n  这个电路是基本高通单元的变形，可以写出表达式  \n\n模块2：  就是一个电流放大器，它不受频率影响，因此下限截止频率为0。  \n\n模块3：  使用电压源串联电阻代替电流源并联电阻（戴维宁等效），上面的高通电路变形。\n\n\n上限截止频率分析上限截止频率时，C1和C2看做短路，电路如图所示。\n\n类比低通电路变体，可得：\n","categories":["硬件","模电"]},{"title":"ESP32中Cmake学习","url":"/2025/04/07/ESP32%E4%B8%ADCmake%E5%AD%A6%E4%B9%A0/","content":"Cmake用途在学STM32的时候用的是Keil软件，keil已经把编译链接集成在软件里了，所以操作起来非常简单。ESP32构建项目是一个复杂的过程，需要编译-连接-烧录，每一步都是用一个工具实现。\n\nCMake : 配置待构建的项目，告诉编译器.c&#x2F;.cpp文件和.h文件的位置。\nNinja : 用于构建项目\nesptool.py ：烧录.bin文件到芯片上\n\n在比较复杂的项目中，文件目录很多，不同的源文件之间的依赖关系也很复杂。Cmake工具可以帮我们很好管理各文件之间的依赖关系。ESP中的Cmake与原Cmake语法大致一样，我这里没有系统学习过Cmake，仅在做项目的过程中进行记录。\nESP项目结构\n\n顶层项目 CMakeLists.txt 文件：顶层项目 CMakeLists.txt 文件会导入 &#x2F;tools&#x2F;cmake&#x2F;project.cmake 文件，由它负责实现构建系统的其余部分。该文件最后会设置项目的名称，并定义该项目。\n\nsdkconfig配置文件：顶层项目 CMakeLists.txt 文件会导入 &#x2F;tools&#x2F;cmake&#x2F;project.cmake 文件，由它负责实现构建系统的其余部分。该文件最后会设置项目的名称，并定义该项目。\n\ncomponents目录：包含了项目的部分自定义组件，并不是每个项目都需要这种自定义组件，但它有助于构建可复用的代码或者导入第三方（不属于 ESP-IDF）的组件。（移植别人的项目时很重要）\n\n“main” 目录：它包含项目本身的源代码。”main” 是默认名称，CMake 变量 COMPONENT_DIRS 默认包含此组件，但你可以修改此变量。\n\n“build” 目录：存放构建输出的地方，如果没有此目录，idf.py 会自动创建。CMake 会配置项目，并在此目录下生成临时的构建文件。随后，在主构建进程的运行期间，该目录还会保存临时目标文件、库文件以及最终输出的二进制文件。此目录通常不会添加到项目的源码管理系统中，也不会随项目源码一同发布。\n\n\n这里只列出了M-heat项目中目前需要的文件，还有一些文件没有用到，等到以后用到再学。\n项目 CMakeLists 文件每个项目都有一个顶层 CMakeLists.txt 文件，包含整个项目的构建设置。\ncmake_minimum_required(VERSION 3.16)\ninclude($ENV&#123;IDF_PATH&#125;/tools/cmake/project.cmake)\nproject(myProject)\n\n\ncmake_minimum_required(VERSION 3.16)必须放在文件的第一行，它会告诉 CMake 构建该项目所需要的最小版本号。\n\ninclude($ENV{IDF_PATH}&#x2F;tools&#x2F;cmake&#x2F;project.cmake) 会导入 CMake 的其余功能来完成配置项目、检索组件等任务。\n\nproject(myProject) 会创建项目本身，并指定项目名称。该名称会作为最终输出的二进制文件的名字，即 myProject.elf 和 myProject.bin。每个 CMakeLists 文件只能定义一个项目。\n\n\n可选项目变量\nCOMPONENT_DIRS：组件的搜索目录，默认为 IDF_PATH&#x2F;components、 PROJECT_DIR&#x2F;components、和 EXTRA_COMPONENT_DIRS。\n\nEXTRA_COMPONENT_DIRS：用于搜索组件的其它可选目录列表。路径可以是相对于项目目录的相对路径，也可以是绝对路径。\n\nCOMPONENTS：用于指定要构建到项目中的组件名称列表，默认为 COMPONENT_DIRS 目录下检索到的所有组件。使用此变量可以“精简”项目，从而缩短构建时间。请注意，如果一个组件通过 COMPONENT_REQUIRES 指定了它依赖的另一个组件，则会自动将其添加到 COMPONENTS 中，所以 COMPONENTS 列表可能会非常短。\n\n\n使用 cmake 中的 set 命令 来设置这些变量，如 set(VARIABLE “VALUE”)。请注意，set() 命令需放在 include(…) 之前，cmake_minimum(…) 之后。\n组件 CMakeLists 文件每个项目都包含一个或多个组件，这些组件可以是 ESP-IDF 的一部分，可以是项目自身组件目录的一部分，也可以从自定义组件目录添加。\n组件是 COMPONENT_DIRS 列表中包含 CMakeLists.txt 文件的任何目录。\n最小组件 CMakeLists 文件最小组件 CMakeLists.txt 文件通过使用 idf_component_register 将组件添加到构建系统中。\nidf_component_register(SRCS &quot;foo.c&quot; &quot;bar.c&quot;\nINCLUDE_DIRS &quot;include&quot; REQUIRES mbedtls)\n\n\nSRCS 是源文件列表（*.c、*.cpp、*.cc、*.S），里面所有的源文件都将会编译进组件库中。 \n\nINCLUDE_DIRS 是目录列表，里面的路径会被添加到所有需要该组件的组件（包括 main 组件）全局 include 搜索路径中。\n\nREQUIRES 实际上并不是必需的，但通常需要它来声明该组件需要使用哪些其它组件\n\n\n上述命令会构建生成与组件同名的库，并最终被链接到应用程序中。\n上述目录通常设置为相对于 CMakeLists.txt 文件的相对路径，当然也可以设置为绝对路径。\n组建依赖\nREQUIRES 需要包含所有在当前组件的 公共 头文件里 #include 的头文件所在的组件。\n\nPRIV_REQUIRES 需要包含被当前组件的源文件 #include 的头文件所在的组件（除非已经被设置在了 REQUIRES 中）。以及是当前组件正常工作必须要链接的组件。\n\n如果当前组件除了 通用组件依赖项 中设置的通用组件（比如 RTOS、libc 等）外，并不依赖其它组件，那么对于上述两个 REQUIRES 变量，可以选择其中一个或是两个都不设置。\n\n\n添加组件下所有源文件\n使用file(GLOB) 通配符\n # 组件目录下的所有 .c 文件\n file(GLOB component_sources &quot;*.c&quot;)\n\n # 注册组件（包含源文件和头文件路径）\n idf_component_register(\n     SRCS $&#123;component_sources&#125;\n     INCLUDE_DIRS &quot;include&quot;\n )\n\n\n使用GLOB_RECURSE通配符\n\nGLOB：仅匹配当前目录。\n\nGLOB_RECURSE：递归匹配子目录。\ncmake_minimum_required(VERSION 3.5)\nproject(your_project)\n\n# 包含 src 目录及其子目录下的所有 .c 文件\nfile(GLOB_RECURSE SOURCES \n    &quot;src/*.c&quot;\n    &quot;src/utils/*.c&quot;\n)\n\n# 添加可执行目标\nadd_executable(your_project $&#123;SOURCES&#125;)\n\n# 链接必要库（如 ESP32 的驱动库）\ntarget_link_libraries(your_project PRIVATE esp32)\n\n\n\n\n\n至此已经可以成功编译所需项目组件。\n","categories":["软件","ESP"]},{"title":"防反接电路","url":"/2025/05/26/%E9%98%B2%E5%8F%8D%E6%8E%A5%E7%94%B5%E8%B7%AF/","content":"电源防反接电路最近打算做一个电源项目，在之前做项目时做过简单的防反接电路，今天来总结一下。\n二极管防反接电路利用二极管单向导通的特性，把二极管串联到电源输入上，因为正向导通反向截止，所以可以实现防反接。\nMOS管防反接电路MOS管的导通内阻较小，很多是mΩ级，这样对电路的压降，功耗造成的损失特别小，所以使用MOS管对电路进行保护是比较推荐的方式。\nNMOS防反接如下图所示，前面的开关代表电源正接与反接。当电源正接时，上电瞬间，MOS管寄生二极管导通（方向S-&gt;D），S极电压约为0.6V，Ugs = v1-0.6 = 19.4V，增强型NMOS导通，电流通过沟道导通，不再经过寄生二极管。\n\n如果电源反接，NMOS的导通电压为0，NMOS截止，寄生二极管反接，电路断开，形成保护。\nPMOS防反接如下图所示，当电源正接时，上电瞬间，MOS管寄生二极管导通（方向D-&gt;S），S极电压约为4.4V，Ugs  =0-4.4 = -4.4V，PMOS导通，短路寄生二极管形成回路。\n电源反接，同理PMOS截止，不再形成回路。\n一般MOS管D极和S极的接入：通常使用N沟道的MOS管时，一般电流是由D极进入而S极流出，PMOS是S进D出，在这里的应用正好相反，通过寄生二极管的导通来满足MOS管导通的电压条件。值得注意，当MOS用作防反接开关时，会有漏电流，这个电流一般很小，在mA或者uA级，可以忽略不计。\n实际应用G极一般要串联一个电阻，为了防止MOS管被击穿，也可以加上稳压二极管。并且在G极可以并联一个电容，从而实现电路的软启动功能，即上电瞬间电压缓慢增加，对后级电路不会有较大的电流冲击，如果没有软启动，后级电路在上电瞬间可能由于较大电流而损坏。\n","categories":["硬件","模电"]},{"title":"运算放大器","url":"/2025/06/03/%E8%BF%90%E7%AE%97%E6%94%BE%E5%A4%A7%E5%99%A8/","content":"理想运算放大器理想运放如图所示，有两个差分的输入端U+和U-，一个单端输出端Uo，具有下列关系：\n\n理想运放有以下特点：\n\nAuo足够大，一般用∞表示。下限截止频率为0，上限截止频率为∞。\n两个输入端均具有无穷大的输入阻抗，即流进或者流出U+和U-电流始终为0。\n输出阻抗为0。\n始终遵循上面的等式。\n\n理想运放的负反馈电路我们一般不会用增益无穷大的运放去直接放大一个信号，科学家研究发现，仅需几个电阻就可实现放大电路增益可控——通过添加一个负反馈网络。\n\n\n\n当趋近∞时：\n反馈在电学系统中，将输出信号通过某种方式，回送到输入环节，和原输入信号合并形成净输入信号，或者单独作为输入信号，进而影响输入输出性能的举措，称为反馈。\n正反馈和负反馈当输出信号发生某个方向的变化，此称为变化根源。变化根源回送到输入端后，会再次引起输出信号变化，此称为二次变化。如果二次变化与变化根源具有相同的方向，则属于正反馈。如果二次变化与变化根源具有相反的方向，则属于负反馈。\n环路极性法判断正负反馈\n找到反馈环路\n\n在反馈环路中任意确定一个节点A\n\n在节点A处假设存在一个正的变化量，用+表示\n\n沿着反馈环路，让这个变化量依次行进，每过一个关键节点，对变化量方向进行判断并标注，用+表示正变化量，用-表示负变化量，用0表示没有变化量。\n\n等这个行进过程再次回到A点时，如果变化量仍是+，则表明反馈的作用是赞成初始的变化，起到了推波助澜的作用，属于正反馈。如果变化量为-，则表明反馈的作用是反对初始的变化，起到了唱反调的作用，属于负反馈。如果变化量为0，则表明反馈环路被打断，不存在反馈。\n\n\n下图为常见器件的传递\n注意：共射极电路的输入是基极，输出是集电极，两者反相，共集电极电流的输入是基极，输出是发射极，两者是同相的，共基极电路的输入是发射极，输出是集电极，两者是同相的。\n书中有许多例子，可以看看，这里不做解释了。\n负反馈放大电路的方框图分析法\n\n : 开环放大倍数\n\n : 反馈系数，一般来说由纯电阻分压组成，不随频率变化，在这里是通式。\n\n : 衰减系数，指输入信号多少倍，进入放大器的输入端。\n\n : 输入信号\n\n : 减法器\n\n\n由方框图可得：\n$$( x_{I} \\times \\dot{M} - \\dot{x}{O} \\times \\dot{F} ) \\dot{A}{uo} = \\dot{x}_{O}$$\n解得闭环增益为：\n$$\\dot{A}{uf} = \\frac{\\dot{x}o}{x_I} = \\frac{M \\times \\dot{A}{uo}}{1 + \\dot{F} \\times \\dot{A}{uo}}$$\n\n在电路中求解和:\n利用叠加原理，计算时仅考虑输入，计算仅考虑输出的影响。\n$$\\dot{M} = \\frac{\\dot{u}+|{x_0=0} - \\dot{u}-|{x_0=0}}{x_I} = \\frac{\\dot{g}1(x_I) - \\dot{g}2(x_I)}{x_I}它的含义是，在不考虑输出回送的情况下，单纯的输入信号，有多少加载到了运放的输入端上运放的正输入减去负输入。\\dot{F} = \\frac{\\dot{u}-|{x_I=0} - \\dot{u}+|{x_I=0}}{x_0} = \\frac{\\dot{g}_4(x_0) - \\dot{g}_3(x_0)}{x_0}$$它的含义是，在不考虑输入的情况下，单纯的输出信号，有多少加载到了运放的反相输入上——运放的负输入减去正输入。\n例题2：\n\n判断电压与电流反馈\n拔掉/短接RL\n输入UI随之变为0\n为电流/电压反馈\n\n负反馈对放大电路性能的影响\n对增益稳定性的影响：\n\n\n即闭环增益的相对变化量，是开环增益相对变化量的倍。\n\n大幅度提高上限截止频率\n\n大幅度降低下限截止频率\n\n对输入电阻的影响：如果核心放大器有两个输入端和一个输出端，且输入信号为单端输入。那么，对负反馈电路来说，当输入信号和反馈信号加载到相同的一个输入端，则称这种反馈为并联负反馈。当输入信号和反馈信号分别加载到两个不同的输入端，则称这种反馈为串联负反馈。\n 串联负反馈能大幅提高输入电阻。\n\n\n","categories":["硬件","模电"]}]