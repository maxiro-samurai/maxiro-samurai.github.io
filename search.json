[{"title":"K210学习（一）","url":"/2022/03/30/K210%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前言去年电赛就知道K210了，本来最优解决方案就是用K210，但是时间太短了没时间学（还是自己菜），最近刚好毕设要用到，买了一个开发板，正好学习下看看K210怎么跑神经网络的。\n\nK210芯片双核RISC-V处理器架构，算力1TOPS，功耗0.3W，而且国产芯片自带KPU神经网络加速器，一片不到50。（STM32H743也就这水平，效果怎么那么差，当时OPENMV还不支持神经网络，支持神经网络的必须要大SRAM）  \n  \n软件软件用MaixPy，编程跟OPENMV一样使用MicroPython\n  \n硬件开发板使用最小系统板  \n最爱的点灯环节代码  \nfrom fpioa_manager import fm #导入FPIOA库，这个库可以使任意外设映射在任意引脚上\nfrom Maix import GPIO # GPIO外设库\n\nio_led_red = 13    #LED红灯引脚\nfm.register(io_led_red, fm.fpioa.GPIO0)     #映射13引脚为GPIO0\n\nled_r=GPIO(GPIO.GPIO0, GPIO.OUT)    # 设置为输出模式\nwhile True :\n    led_r.value(0)  # 值为0\n    time.delay(1000)\n    led_r.value(1)  # 值为0\n    time.delay(1000)\n\n上传开发板\n","categories":["硬件","K210"]},{"title":"M-watch踩坑记录","url":"/2022/04/06/M-watch%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","content":"M-watch项目记录\n无线电源部分  \n  BQ51013b  \n  替换参考设计的时候要思考，不能用简化器件替代\n  \n              \n          \n      \n              \n      参考设计    \n      \n  \n    \n\n  仅用一个PMOS管代替肯定不行，因为此电路电源双向导通的，OUT端电压先产生，会直接影响AD端电压，使无线充电关闭。\n\n\n"},{"title":"神经影像（一）：Nipype库学习","url":"/2023/07/21/Nipype%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ANipype%E5%BA%93%E5%AD%A6%E4%B9%A0/","content":"Nipype简介Nipype是一个开源神经影像处理软件包，使用python编写。整合了传统神经影像处理软件包的接口（SPM,FSL,FreeSurfer,AFNI以及其他），可以使研究人员通过不同的软件处理图像，将其整合在一起。\n比如你想使用SPM做头动矫正，FreeSurfer做配准，ANTS用来标准化，然后FSL做平滑。使用传统流程会非常麻烦，需要你对各种软件的掌握。使用Nipype可以轻松完成。\n什么是NipypeNipype由多个组件构成，主要的组件有Interfaces,the WorkflowEngine 和Execution Plugins:\n\n            \n        \n    \n            \n    Nipype构成    \n    \n\n \n\n\nInterface: 相关软件的接口，可以是一个函数\n\nNode&#x2F;MapNode: 把一个接口打包成节点，在Workflow中使用。\n\nWorkflow: 一个表示工作流程的图，一个Workflow下面有很多节点。\n\nPlugin: 用来展示Workflow是如何工作的\n\n\nDockerDocker是一个开源项目，用来在容器中自动部署应用。（Docker的使用和学习令写，在这只简单介绍）这个容器可以打包运行Nipype所需的软件和完整的文件系统：代码，系统工具，软件库，比如 Python, FSL, AFNI, SPM, FreeSurfer, ANTs。这保证了可移植性，在不同环境中都可以运行。\nNipype官方教程所使用的  miykael&#x2F;nipype_tutorial镜像，建立了一个Linux环境和一系列所需软件包。同样的我们可以创建自己的docker镜像处理自己的数据。（之后再学用 Neurodocker创建）\nDocker for windows我是用的是Windows 10去docker官网下载 Docker for windows\n下载完成后使用终端测试是否安装正确：\ndocker --version\n\n            \n\n            \n\n\n\ndocker run hello-world\n\n            \n        \n    \n            \n        \n    \n\n\n\n这里提醒一下，Docker默认下载到C盘无法修改，Docker拉取的镜像也是在C盘，所以需要C盘空间很大，我试了修改镜像的位置，行不通，所以只能扩充C盘的大小了。\n拉取镜像确认Docker安装没有问题后，就可以开始拉取镜像了。\ndocker pull miykael/nipype_tutorial:latest\n\n由于是从国外的镜像网站拉取镜像，速度很慢。解决方法是使用国内镜像加速。\n找到C:\\Program Files\\Docker\\Docker\\resources文件夹下的windows-daemon-options.json文件\n&quot;registry-mirrors&quot;: [&quot;https://m3e4jmm0.mirror.aliyuncs.com&quot;],\n\n把镜像地址改为阿里云镜像。\n运行镜像简单运行miykael&#x2F;nipype_tutorial，使用命令：\ndocker run -it --rm -p 8888:8888 miykael/nipype_tutorial jupyter notebook\n\n如果想要使用本地的dataset，使用命令：\ndocker run -it --rm -v /path/to/nipype_tutorial/:/home/neuro/nipype_tutorial -v /path/to/data/:/data -v /path/to/output/:/output -p 8888:8888 miykael/nipype_tutorial jupyter notebook\n\n\n-it 表示打开一个可以交互的容器\n\n–rm 在关闭Docker后容器自动移除\n\n-p 表示使用哪个端口\n\n-v 表示把本地的文件加载到容器中去 &#x2F;path&#x2F;to&#x2F;nipype_tutorial&#x2F; 表示本地nipype_tutorial路径，：表示加载到容器中的路径。\n\nmiykael&#x2F;nipype_tutorial 表示运行哪个镜像\n\njupyter notebook 在容器中打开jupyter\n\n\n关闭容器在终端使用ctrl-c可以关闭容器\n列出所有imagedocker images\n\n删除镜像docker rmi -f 7d9495d03763\n\n后面的数字为镜像ID\n提取和加载镜像如果想使用U盘保存镜像，使用命令：\n# Export docker image miykael/nipype_tutorial\ndocker save -o nipype_tutorial.tar miykael/nipype_tutorial\n\n# Import docker image on another PC\ndocker load --input nipype_tutorial.tar\n\n数据保存格式这个教程的数据保存结构是根据 Brain Imaging Data Structure (BIDS).\n这个格式结构清晰，并且易于共享。\n            \n        \n    \n            \n        \n    \n\n \n\n\n参考nipype官方教程 Nipype tutorial\n","categories":["python"],"tags":["神经影像"]},{"title":"Nipype（三）:Quickstart","url":"/2023/07/24/Nipype%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AQuickstart/","content":"Nipype Quickstart首先需要Import所需要的函数和包\nimport os \nfrom os.path import abspath\n\nfrom nipype import Workflow, Node, MapNode, Function\nfrom nipype.interfaces.fsl import BET, IsotropicSmooth, ApplyMask #fsl的接口函数\n\nfrom nilearn.plotting import plot_anat #画图\n%matplotlib inline #在Jupyter Notebook中画图时直接嵌入Notebook单元格中\nimport matplotlib.pyplot as plt\n\nInterfaces接口是Nipype的核心。这些接口是python接口可以通过这些接口访问外部软件包，这些软件包大多不是用python写的。（比如FSL,SPM和FreeSurfer）\n使用FSL中的bet()函数\n# will use a T1w from ds000114 dataset\n\n# input_file是BET()函数的输入参数，为数据集的路径\ninput_file =  abspath(&quot;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&quot;)\n# BET()实例化\nbet = BET()\n\nbet.inputs.in_file = input_file\n# 输出为输出路径\nbet.inputs.out_file = &quot;/output/T1w_nipype_bet.nii.gz&quot;\nres = bet.run()\n\n画出输出图像\nplot_anat(&#39;/output/T1w_nipype_bet.nii.gz&#39;, \n      display_mode=&#39;ortho&#39;, dim=-1, draw_cross=False, annotate=False);\n\n\n使用help指令可以看接口函数的使用方法\nBET.help()\n\nWraps the executable command ``bet``.\n\nFSL BET wrapper for skull stripping\n\nFor complete details, see the `BET Documentation.\n&lt;https://fsl.fmrib.ox.ac.uk/fsl/fslwiki/BET/UserGuide&gt;`_\n\nExamples\n--------\n&gt;&gt;&gt; from nipype.interfaces import fsl\n&gt;&gt;&gt; btr = fsl.BET()\n&gt;&gt;&gt; btr.inputs.in_file = &#39;structural.nii&#39;\n&gt;&gt;&gt; btr.inputs.frac = 0.7\n&gt;&gt;&gt; btr.inputs.out_file = &#39;brain_anat.nii&#39;\n&gt;&gt;&gt; btr.cmdline\n&#39;bet structural.nii brain_anat.nii -f 0.70&#39;\n&gt;&gt;&gt; res = btr.run() # doctest: +SKIP\n\nInputs::\n\n        [Mandatory]\n        in_file: (a pathlike object or string representing an existing file)\n                input file to skull strip\n                argument: ``%s``, position: 0\n\n        [Optional]\n        out_file: (a pathlike object or string representing a file)\n                name of output skull stripped image\n                argument: ``%s``, position: 1\n        outline: (a boolean)\n                create surface outline image\n                argument: ``-o``\n        mask: (a boolean)\n                create binary mask image\n                argument: ``-m``\n        skull: (a boolean)\n                create skull image\n                argument: ``-s``\n        no_output: (a boolean)\n                Don&#39;t generate segmented output\n                argument: ``-n``\n        frac: (a float)\n                fractional intensity threshold\n                argument: ``-f %.2f``\n        vertical_gradient: (a float)\n                vertical gradient in fractional intensity threshold (-1, 1)\n                argument: ``-g %.2f``\n        radius: (an integer)\n                head radius\n                argument: ``-r %d``\n        center: (a list of at most 3 items which are an integer)\n                center of gravity in voxels\n                argument: ``-c %s``\n        threshold: (a boolean)\n                apply thresholding to segmented brain image and mask\n                argument: ``-t``\n        mesh: (a boolean)\n                generate a vtk mesh brain surface\n                argument: ``-e``\n        robust: (a boolean)\n                robust brain centre estimation (iterates BET several times)\n                argument: ``-R``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        padding: (a boolean)\n                improve BET if FOV is very small in Z (by temporarily padding end\n                slices)\n                argument: ``-Z``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        remove_eyes: (a boolean)\n                eye &amp; optic nerve cleanup (can be useful in SIENA)\n                argument: ``-S``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        surfaces: (a boolean)\n                run bet2 and then betsurf to get additional skull and scalp surfaces\n                (includes registrations)\n                argument: ``-A``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        t2_guided: (a pathlike object or string representing a file)\n                as with creating surfaces, when also feeding in non-brain-extracted\n                T2 (includes registrations)\n                argument: ``-A2 %s``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        functional: (a boolean)\n                apply to 4D fMRI data\n                argument: ``-F``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        reduce_bias: (a boolean)\n                bias field and neck cleanup\n                argument: ``-B``\n                mutually_exclusive: functional, reduce_bias, robust, padding,\n                remove_eyes, surfaces, t2_guided\n        output_type: (&#39;NIFTI&#39; or &#39;NIFTI_PAIR&#39; or &#39;NIFTI_GZ&#39; or\n                &#39;NIFTI_PAIR_GZ&#39;)\n                FSL output type\n        args: (a string)\n                Additional parameters to the command\n                argument: ``%s``\n        environ: (a dictionary with keys which are a bytes or None or a value\n                of class &#39;str&#39; and with values which are a bytes or None or a\n                value of class &#39;str&#39;, nipype default value: &#123;&#125;)\n                Environment variables\n\nOutputs::\n\n        out_file: (a pathlike object or string representing a file)\n                path/name of skullstripped file (if generated)\n        mask_file: (a pathlike object or string representing a file)\n                path/name of binary brain mask (if generated)\n        outline_file: (a pathlike object or string representing a file)\n                path/name of outline file (if generated)\n        meshfile: (a pathlike object or string representing a file)\n                path/name of vtk mesh file (if generated)\n        inskull_mask_file: (a pathlike object or string representing a file)\n                path/name of inskull mask (if generated)\n        inskull_mesh_file: (a pathlike object or string representing a file)\n                path/name of inskull mesh outline (if generated)\n        outskull_mask_file: (a pathlike object or string representing a file)\n                path/name of outskull mask (if generated)\n        outskull_mesh_file: (a pathlike object or string representing a file)\n                path/name of outskull mesh outline (if generated)\n        outskin_mask_file: (a pathlike object or string representing a file)\n                path/name of outskin mask (if generated)\n        outskin_mesh_file: (a pathlike object or string representing a file)\n                path/name of outskin mesh outline (if generated)\n        skull_mask_file: (a pathlike object or string representing a file)\n                path/name of skull mask (if generated)\n        skull_file: (a pathlike object or string representing a file)\n                path/name of skull file (if generated)\n\nReferences:\n-----------\nBibTeX(&#39;@article&#123;JenkinsonBeckmannBehrensWoolrichSmith2012,author=&#123;M. Jenkinson, C.F. Beckmann, T.E. Behrens, M.W. Woolrich, and S.M. Smith&#125;,title=&#123;FSL&#125;,journal=&#123;NeuroImage&#125;,volume=&#123;62&#125;,pages=&#123;782-790&#125;,year=&#123;2012&#125;,&#125;&#39;, key=&#39;JenkinsonBeckmannBehrensWoolrichSmith2012&#39;)\n\n​使用FSL中的光滑函数，高斯核为4mm\nsmoothing = IsotropicSmooth()\nsmoothing.inputs.in_file = &quot;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&quot;\nsmoothing.inputs.fwhm = 4\nsmoothing.inputs.out_file = &quot;/output/T1w_nipype_smooth.nii.gz&quot;\nsmoothing.run()\n# plotting the output\nplot_anat(&#39;/output/T1w_nipype_smooth.nii.gz&#39;, \n      display_mode=&#39;ortho&#39;, dim=-1, draw_cross=False, annotate=False);\n\n\nNodes and Workflows接口是Nipype的核心，在使用不同包的接口或者同一个包的不同接口时，需要把接口放在一个Node中，并且多个Node构成一个workflow。\n在Nipype中，一个节点是执行某个函数的物体，这个函数可以是Nipype中的任意接口函数或者是user自己创建的函数，又或者是外部的一个脚本中的。每个节点由名称，接口和最少一个输入和输出构成。\n一旦使用了多个节点，就可以使用workflow连接每一个节点，并且生成一个有向连接图。\n首先创建去头骨节点\n# Create Node\nbet_node = Node(BET(), name=&#39;bet&#39;)\n# Specify node inputs\nbet_node.inputs.in_file = input_file\nbet_node.inputs.mask = True\n\n# bet node can be also defined this way:\n#bet_node = Node(BET(in_file=input_file, mask=True), name=&#39;bet_node&#39;)\n\nmask为True表示生成一个去头骨的掩膜图像。\n接下来创建一个光滑节点，使用IsotropicSmooth函数\nsmooth_node = Node(IsotropicSmooth(in_file=input_file, fwhm=4), name=&quot;smooth&quot;)\n\n接下来使用掩膜函数把光滑后的图像掩膜。\nmask_node = Node(ApplyMask(), name=&quot;mask&quot;)\n\n使用help指令后可以看到，ApplyMask（）函数有两个必须传入的参数。\n\nmask_file :掩膜图像位置\n\nin_file ：被掩膜的图像\n\n\n所有节点都创建完毕，接下来创建一个workflow把他们连接起来。首先连接bet_node的输出和mask_node的输入\n# Initiation of a workflow\nwf = Workflow(name=&quot;smoothflow&quot;, base_dir=&quot;/output/working_dir&quot;)\n\nwf.connect(bet_node, &quot;mask_file&quot;, mask_node, &quot;mask_file&quot;)\n\n接着连接smooth_node的out_file和mask_node的in_file把这个workflow可视化出来\nwf.connect(smooth_node,&quot;out_file&quot;,mask_node, &quot;in_file&quot;)\n\n\nwf.write_graph(&quot;workflow_graph.dot&quot;)\nImage(filename=&quot;/output/working_dir/smoothflow/workflow_graph.png&quot;)\n\n\n或者画出细节图\nwf.write_graph(graph2use=&#39;flat&#39;)\n\nImage(filename=&quot;/output/working_dir/smoothflow/graph_detailed.png&quot;)\n\n\n接下来开始运行workflow\nres = wf.run()\n\n列出结果\nlist(res.nodes)[0].result.outputs\n\n\n查看生成的文件夹\n! tree -L 3 /output/working_dir/smoothflow/\n\n也可以将生成图片画出\nimport numpy as np\nimport nibabel as nb\n#import matplotlib.pyplot as plt\n\n# Let&#39;s create a short helper function to plot 3D NIfTI images\ndef plot_slice(fname):\n\n    # 加载图像\n    img = nb.load(fname)    \n    data = img.get_data()\n\n    # 因为是3D图像，所以选择Z轴中间切开\n    cut = int(data.shape[-1]/2) + 10   \n\n    # Plot the data\n    plt.imshow(np.rot90(data[..., cut]), cmap=&quot;gray&quot;)\n    plt.gca().set_axis_off()  # 关闭坐标轴\n\nf = plt.figure(figsize=(12, 4))\nfor i, img in enumerate([&quot;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&quot;,\n                        &quot;/output/working_dir/smoothflow/smooth/sub-01_ses-test_T1w_smooth.nii.gz&quot;,\n                        &quot;/output/working_dir/smoothflow/bet/sub-01_ses-test_T1w_brain_mask.nii.gz&quot;,\n                        &quot;/output/working_dir/smoothflow/mask/sub-01_ses-test_T1w_smooth_masked.nii.gz&quot;]):\n    f.add_subplot(1, 4, i + 1)\n    plot_slice(img)\n\n\nIterables在做数据处理的时候，经常一个预处理跑多个受试或者做一些组差异比较。避免重复写脚本，Nipype有一个处理插件，叫做iterables\n假如我们有一个workflow上面有两个node，node（A）是去头颅函数，node(B)是光滑函数，现在我们很好奇不同大小的高斯核对结果的影响。因此，我们设置FWHM的值为4mm,8mm和16mm。\n\nsmooth_node_it = Node(IsotropicSmooth(in_file=input_file), name=&quot;smooth&quot;)\nsmooth_node_it.iterables = (&quot;fwhm&quot;, [4, 8, 16])\n\n重新定义bet和mask node\nbet_node_it = Node(BET(in_file=input_file, mask=True), name=&#39;bet_node&#39;)\nmask_node_it = Node(ApplyMask(), name=&quot;mask&quot;)\n\n新建一个新的workflow\nwf_it = Workflow(name=&quot;smoothflow_it&quot;, base_dir=&quot;/output/working_dir&quot;)\nwf_it.connect(bet_node_it, &quot;mask_file&quot;, mask_node_it, &quot;mask_file&quot;)\nwf_it.connect(smooth_node_it, &quot;out_file&quot;, mask_node_it, &quot;in_file&quot;)\n\n运行workflow\nres_it = wf_it.run()\n\n看生成的文件    ! tree -L 3 &#x2F;output&#x2F;working_dir&#x2F;smoothflow_it&#x2F;\n/output/working_dir/smoothflow_it/\n├── bet_node\n│   ├── _0x059f982d380f7943757debfb10a5502d.json\n│   ├── command.txt\n│   ├── _inputs.pklz\n│   ├── _node.pklz\n│   ├── _report\n│   │   └── report.rst\n│   ├── result_bet_node.pklz\n│   └── sub-01_ses-test_T1w_brain_mask.nii.gz\n├── d3.js\n├── _fwhm_16\n│   ├── mask\n│   │   ├── _0xd72ea2e7b364b1159092a12f3d3ca28c.json\n│   │   ├── command.txt\n│   │   ├── _inputs.pklz\n│   │   ├── _node.pklz\n│   │   ├── _report\n│   │   ├── result_mask.pklz\n│   │   └── sub-01_ses-test_T1w_smooth_masked.nii.gz\n│   └── smooth\n│       ├── _0xc478d2c0a35763bb8cc0ba0be7c7c4a3.json\n│       ├── command.txt\n│       ├── _inputs.pklz\n│       ├── _node.pklz\n│       ├── _report\n│       ├── result_smooth.pklz\n│       └── sub-01_ses-test_T1w_smooth.nii.gz\n├── _fwhm_4\n│   ├── mask\n│   │   ├── _0x020ff51c3dd2cc1c441bbc71b6bb82fd.json\n│   │   ├── command.txt\n│   │   ├── _inputs.pklz\n│   │   ├── _node.pklz\n│   │   ├── _report\n│   │   ├── result_mask.pklz\n│   │   └── sub-01_ses-test_T1w_smooth_masked.nii.gz\n│   └── smooth\n│       ├── _0x7284dba78093a51ae87024eac1bec00f.json\n│       ├── command.txt\n│       ├── _inputs.pklz\n│       ├── _node.pklz\n│       ├── _report\n│       ├── result_smooth.pklz\n│       └── sub-01_ses-test_T1w_smooth.nii.gz\n├── _fwhm_8\n│   ├── mask\n│   │   ├── _0x3ac21b3bbb4f9177e3221ac52b59a349.json\n│   │   ├── command.txt\n│   │   ├── _inputs.pklz\n│   │   ├── _node.pklz\n│   │   ├── _report\n│   │   ├── result_mask.pklz\n│   │   └── sub-01_ses-test_T1w_smooth_masked.nii.gz\n│   └── smooth\n│       ├── _0x8a60534f7916842abe5b185fdf7996d9.json\n│       ├── command.txt\n│       ├── _inputs.pklz\n│       ├── _node.pklz\n│       ├── _report\n│       ├── result_smooth.pklz\n│       └── sub-01_ses-test_T1w_smooth.nii.gz\n├── graph1.json\n├── graph.json\n└── index.html\n\n17 directories, 47 files\n\nMapnode如果想使输入为多个输入参数的节点的输出都为下一个节点的输入，那么就需要使用MapNode。MapNode与普通的Node很像，它的输入可以是一个列表，最终也生成一个输出列表。\n比如你有许多文件，他们都会经过相同的node处理和不同的Node，这时MapNode可以发挥作用。\n比如上图，A节点处理后得到一个列表的输出，而这些输出都会经过B节点处理，最后把B得到的结果送入C节点。\n简单例子：\ndef square_func(x):\nreturn x ** 2\n\n# 这里使用nipype的Function接口，把用户自己创建的函数作为一个接口\nsquare = Function(input_names=[&quot;x&quot;], output_names=[&quot;f_x&quot;], function=square_func)\n\n如果把输入的值设置为一个列表\nsquare_node = Node(square, name=&quot;square&quot;)\nsquare_node.inputs.x = [2, 4]\nres = square_node.run()\nres.outputs\n\n输出会报错，因为square_func不能接收一个列表。\n这时我们使用MapNode即可解决！\nsquare_mapnode = MapNode(square, name=&quot;square&quot;, iterfield=[&quot;x&quot;])\nsquare_mapnode.inputs.x = [2, 4]\nres = square_mapnode.run()\nres.outputs\n\n\n参考nipype官方教程 Nipype Quickstart\n","categories":["python"],"tags":["神经影像"]},{"title":"Nipype（二）：showcase","url":"/2023/07/24/Nipype%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Ashowcase/","content":"Nipype Showcase使用简单的fMRI预处理流程来展示Workflow：\n\nslice time correction\nmotion correction\nsmoothing\n\n准备预处理workflow首先导入Nipype包中的Node和Workflow\nfrom nipype import Node, Workflow\n\n接着导入预处理需要的interfaces\nfrom nipype.interfaces.fsl import SliceTimer, MCFLIRT, Smooth\n\n接着把这三个接口接入Node并且定义输入\n# 初始化slicetime节点\nslicetimer = Node(SliceTimer(index_dir=False,\n                            interleaved=True,\n                            time_repetition=2.5),\n                  name=&quot;slicetimer&quot;)\n\n# 初始化运动矫正节点\nmcflirt = Node(MCFLIRT(mean_vol=True,\n                      save_plots=True),\n              name=&quot;mcflirt&quot;)\n# 初始化光滑节点\nsmooth = Node(Smooth(fwhm=4), name=&quot;smooth&quot;)\n\n接下来就可以创建一个workflow，把这三个节点连接起来\n# 创建预处理workflow\npreproc01 = Workflow(name=&#39;preproc01&#39;, base_dir=&#39;.&#39;)\n\n# 连接节点到workflow中\npreproc01.connect([(slicetimer, mcflirt, [(&#39;slice_time_corrected_file&#39;, &#39;in_file&#39;)]),\n               (mcflirt, smooth, [(&#39;out_file&#39;, &#39;in_file&#39;)])])\n\n可以把workflow可视化\n# 生成可视化图片\npreproc01.write_graph(graph2use=&#39;orig&#39;)\n\n# 导入Ipython的图像包\nfrom IPython.display import Image\nImage(filename=&quot;preproc01/graph_detailed.png&quot;)\n\n            \n        \n    \n            \n    结果\n    \n\n \n在一个功能图像上运行workflow创建过一个workflow后，开始在功能像上运行。首先要确定数据文件的路径。\nslicetimer.inputs.in_file = &#39;/data/ds000114/sub-01/ses-test/func/sub-01_ses-test_task-fingerfootlips_bold.nii.gz&#39;\n\ndata文件夹下有所需要的数据。\n使用Nipype的并行处理功能，观察处理时间\n%time preproc01.run(&#39;MultiProc&#39;, plugin_args=&#123;&#39;n_procs&#39;: 5&#125;)\n\n            \n        \n    \n            \n    \n    \n\n\n            \n        \n    \n            \n    结果\n    \n\n\n上图 输出了整个Workflow的工作流程，最后可以看到整个处理花费大概2min。\n结果检查一下输出文件夹有什么。\n!tree preproc01 -I &#39;*js|*json|*pklz|_report|*.dot|*html&#39;\n\n            \n        \n    \n            \n    \n    \n\n\n\n修改参数重新运行smooth.inputs.fwhm = 2\n%time preproc01.run(&#39;MultiProc&#39;, plugin_args=&#123;&#39;n_procs&#39;: 5&#125;)\n\n  \n可看到时间仅用14秒，因为整个workflow不会重新运行一遍，只把更改参数的Node运行，在这里就是把smooth重新运行。\n并行处理preproc1预处理workflow使用了大概两分钟，如果我要处理5张功能像图片，他会花费10分钟。\n首先我们复制5个workflow\n# First, let&#39;s copy/clone &#39;preproc01&#39;\npreproc02 = preproc01.clone(&#39;preproc02&#39;)\npreproc03 = preproc01.clone(&#39;preproc03&#39;)\npreproc04 = preproc01.clone(&#39;preproc04&#39;)\npreproc05 = preproc01.clone(&#39;preproc05&#39;)\n\n我们想要并行处理，需要把他们整合在一个workflow中。\nmetaflow = Workflow(name=&#39;metaflow&#39;, base_dir=&#39;.&#39;)\n# Now we can add the five preproc workflows to the bigger metaflow\nmetaflow.add_nodes([preproc01, preproc02, preproc03,\n                preproc04, preproc05])\n\n可视化看一下整个workflow\n# As before, let&#39;s write the graph of the workflow\nmetaflow.write_graph(graph2use=&#39;flat&#39;)\n\nImage(filename=&quot;metaflow/graph_detailed.png&quot;)\n\n\n使用并行处理\n%time metaflow.run(&#39;MultiProc&#39;, plugin_args=&#123;&#39;n_procs&#39;: 5&#125;)\n\nlog信息此处省略\n可以看到总共用时2min，这就是使用Nipype的原因。\nmetaflow的结果!tree metaflow -I &#39;*js|*json|*pklz|_report|*.dot|*html&#39;\n\n\n参考nipype官方教程 Nipype Showcase\n","categories":["python"],"tags":["神经影像"]},{"title":"Hello World","url":"/2025/02/21/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Nipype（四）：Interfaces","url":"/2023/08/03/Nipype%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9AInterfaces/","content":"Interfaces在之前已经学习过Interfaces的基本概念和操作，这里简单介绍一下。Interfaces就是其他软件包的python函数接口，想要使用其他软件的（例如FSL,SPM或者FreeSurfer）函数，就需要此函数的python接口和安装相应的软件包。\nBET函数原始使用方法先看一下我们需要去头骨的原始图像。\nfrom nilearn.plotting import plot_anat\n%matplotlib inline\nplot_anat(&#39;/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz&#39;, title=&#39;original&#39;,\n      display_mode=&#39;ortho&#39;, dim=-1, draw_cross=False, annotate=False);\n\n\n使用BET函数命令行形式（即在FSL中原始使用方法）\nbet &lt;input&gt; &lt;output&gt;\n\n在ipython中则需要在前面加%%bash\n%%bash\n\nFILENAME=/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w\n\nbet $&#123;FILENAME&#125;.nii.gz /output/sub-01_ses-test_T1w_bet.nii.gz\n\n使用查看帮助信息\n!bet -h\n\nUsage:    bet &lt;input&gt; &lt;output&gt; [options]\n\nMain bet2 options:\n-o          generate brain surface outline overlaid onto original image\n-m          generate binary brain mask\n-s          generate approximate skull image\n-n          don&#39;t generate segmented brain image output\n-f &lt;f&gt;      fractional intensity threshold (0-&gt;1); default=0.5; smaller values give larger brain outline estimates\n-g &lt;g&gt;      vertical gradient in fractional intensity threshold (-1-&gt;1); default=0; positive values give larger brain outline at bottom, smaller at top\n-r &lt;r&gt;      head radius (mm not voxels); initial surface sphere is set to half of this\n-c &lt;x y z&gt;  centre-of-gravity (voxels not mm) of initial mesh surface.\n-t          apply thresholding to segmented brain image and mask\n-e          generates brain surface as mesh in .vtk format\n\nVariations on default bet2 functionality (mutually exclusive options):\n(default)   just run bet2\n-R          robust brain centre estimation (iterates BET several times)\n-S          eye &amp; optic nerve cleanup (can be useful in SIENA)\n-B          bias field &amp; neck cleanup (can be useful in SIENA)\n-Z          improve BET if FOV is very small in Z (by temporarily padding end slices)\n-F          apply to 4D FMRI data (uses -f 0.3 and dilates brain mask slightly)\n-A          run bet2 and then betsurf to get additional skull and scalp surfaces (includes registrations)\n-A2 &lt;T2&gt;    as with -A, when also feeding in non-brain-extracted T2 (includes registrations)\n\nMiscellaneous options:\n-v          verbose (switch on diagnostic messages)\n-h          display this help, then exits\n-d          debug (don&#39;t delete temporary intermediate images)\n\n使用命令行生成二进制掩膜文件。\n%%bash\n\nFILENAME=/data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w\n\nbet $&#123;FILENAME&#125;.nii.gz /output/sub-01_ses-test_T1w_bet.nii.gz -m\n\n由此我们可知道python接口的函数实际上也是在命令行中输入需要的操作，不过使用的是python脚本形式。\nBET函数接口使用在之前有，这里简要介绍。\n# import BET函数\nfrom nipype.interfaces.fsl import BET\nskullstrip = BET() # 对象实例化\nskullstrip.inputs.in_file = &quot;/data/ds000114/sub-01/ses-test/anat/ sub-01_ses-test_T1w.nii.gz&quot; # 输入文件路径\nskullstrip.inputs.out_file = &quot;/output/T1w_nipype_bet.nii.gz&quot; # 输出文件路径\nres = skullstrip.run() # 运行\n\n\n我们来看一下输出的命令行\nprint(skullstrip.cmdline)\n\nbet /data/ds000114/sub-01/ses-test/anat/sub-01_ses-test_T1w.nii.gz /output/T1w_nipype_bet.nii.gz\n\n与我们正常使用时的一样。\nInterface errors使用run方法运行接口时，对于FSL、Freesurfer和其他程序，会使系统输入上述命令行命令。对于MATLAB的程序如SPM，它会生成一个.m文件，然后在matlab环境下运行这个.m文件。\n如果我们不给函数接口一个必要的输入参数它就会报错\nskullstrip2 = BET()\ntry:\n    skullstrip2.run()\nexcept(ValueError) as err:\n    print(&quot;ValueError:&quot;, err)\nelse:\n    raise\n\nValueError: BET requires a value for input &#39;in_file&#39;. For a list of required inputs, see BET.help()\n\nBET函数没有输入文件的路径\n又或者输入类型搞错，比如BET（）函数想要生成掩膜文件，你却把淹没文件的名字输入上去了 XD。\ntry:\nskullstrip.inputs.mask = &quot;mask_file.nii&quot;\nexcept(Exception) as err:\n    if &quot;TraitError&quot; in str(err.__class__):\n        print(&quot;TraitError:&quot;, err)\n    else:\n        raise\nelse:\n    raise\nTraitError: The &#39;mask&#39; trait of a BETInputSpec instance must be a boolean, but a value of &#39;mask_file.nii&#39; &lt;class &#39;str&#39;&gt; was specified.\n\n在报错的时候根据报错信息修改程序\n参考nipype_tutorial Interface\n","categories":["python"],"tags":["神经影像"]},{"title":"告别","url":"/2022/05/06/%E5%91%8A%E5%88%AB/","content":"毕业大学四年过去了，回顾一下这四年还挺美好的，虽然没社交没参加活动啥的，感觉那都是虚的，真正要提高的还是自己的做工程的能力和精神。最害怕的是转专业后也沦为做题机器了，幸好没有，做了几个还算一般的项目吧。最后一年我也不知道为啥摆烂了，因为疫情？肯定不是，都他妈的借口，归根到底还是自己这个人就这比样，稍微放松一下就回归自我了。电赛复盘一下，确实是自己能力不足。还是自己太菜了，还得过段时间再继续吧。M-watch项目暂停了，以及EAGLE、3D结构方面、模电、电子电路反正一堆要学的都得暂停了，真他妈的烦。\n\n之后打算还是考研吧，本来想着先工作两年攒一下经验，现在看来当时有点天真以为有项目经验就好找工作，哈哈哈，在学历面前确实全都是屁不值一提。总而言之吧，决定考就认真考了，今天正好也给毕设肝完了，没理由碰代码了，不知道半年不碰会变菜不会哈哈哈哈。\n咱也不需要啥动力，顶不住的时候想想18年就好了。\n就这样吧，希望下次归来时，我可以追梦。\n","categories":["杂谈"]},{"title":"核磁共振原理（一）","url":"/2023/05/05/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/","content":"核磁共振仪的硬件组成  核磁共振仪主要由主磁体、梯度系统、射频系统、计算机系统和其他辅助设备。  \n \n主磁体  主磁体分为永磁型和电磁型，永磁性产生的磁场强度通常比电磁型小，电磁型可以产生很大的磁场强度。  \n\n\n主要参数\n磁场强度：磁场强度的单位为T（特斯拉），G（高斯），定义1G为，距离通过5A电流的线圈5cm处的磁场强度。1T&#x3D;10000G。一般把0.5T以下的MRI仪称为低场机，0.51.0T为中场机，1.02.0T为高场机，大于2.0T的称为超高场机（3.0T）。高磁场强度的优点：1.提高质子的磁化率，增加图像的信噪比；2.缩短MRI成像的时间；3.增加血氧饱和度依赖效应（BOLD），使脑功能成像的信号变化更为明显。\n\n\n\n\n主磁场均匀度：磁场均匀性是指在一定的容积范围内磁场强度的均一性，也即单位面积内通过的磁力线数目的一致性。\n\n\n\n\n主磁场的稳定性：实际上是指主磁场强度及其均匀性的变化，也成为磁场漂移。\n\n\n\n梯度系统  梯度系统是MRI仪最重要的硬件之一，由梯度线圈、梯度放大器、数模转换器、梯度控制器、梯度冷却装置构成，梯度线圈安装于主磁体内。梯度系统的主要作用：1、进行MRI信号的空间定位编码。2、产生梯度回波信号。\n \n磁共振坐标系  坐标系主要由x、y、z构成，Z轴是人体长轴方向正方向为头部，X轴正方向为人体左侧，Y轴正方向是人体解剖位置前侧。\n\n            \n        \n    \n            \n    磁共振系统的坐标系    \n    \n\n  \n\n梯度磁场的产生  以Z轴为例，梯度线圈是特殊绕制的线圈，在头部和脚部。线圈通电后，电流流过头部线圈产生与主磁场方向相同的磁场，两个磁场强度叠加，头部磁场强度增高。脚步磁场方向相反，磁场减弱。从而形成沿着Z轴分布，头侧高足侧低的梯度磁场，梯度线圈中心位置的磁场强度保持不变。\n\n            \n        \n    \n            \n    梯度磁场    \n    \n\n  \n\n射频系统   射频系统由射频发生器、射频放大器和射频线圈构成。射频线圈有发射线圈和接收线圈。发射线圈发出射频脉冲（无线电波）激发人体内的质子发生共振（后面补充），接收线圈接收人体发出的MR信号。\n \n计算机系统\n  计算机系统控制着MRI仪的射频脉冲激发、信号采集、数据运算和图像显示等功能。\n\n\n            \n        \n    \n            \n    核磁共振控制系统结构    \n    \n\n  \n\n\nSCP(scan control processor) 扫描控制系统：产生序列脉冲的全部硬件开关信号，控制全部硬件（射频，梯度，采样，重构）开始和结束时间点。\nTRF（trigger and rotational function board）：定位引起的坐标旋转变换，对应梯度的控制，以及对SRF的触发控制。\nSRF（sequence related function board）:负责序列中梯度系统涡流校正补偿对梯度的触发控制。\nIRF（interface relate function board）射频控制器：负责主时钟的同步，控制发射射频控制器。\nDRF（digital receiver filter）数字滤波器：对IRF发送来的采集数据，进行频率解调，去除掉载波频率，同时进行一定的降噪处理。\nAPS（acquisition processing subsystem）:根据主机序列所对应的扫描参数，负责对采集的数据按K空间顺序、层面关系及平均次数排序组合，并把排列好的K空间发送给重建处理器。\nReflex AP 重建处理器：专门负责对原始数据进行傅里叶变换。\n\n\n这一部分简单介绍核磁共振仪器的硬件组成，之后笔记记录学习核磁共振物理学原理。\n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（三）","url":"/2023/05/09/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89%EF%BC%89/","content":"磁共振加权成像加权是“突出重点”的意思，组织的多方面特性均可能对其磁共振信号的强弱有影响，我们可以通过成像脉冲序列的选择及成像参数的调整，使MR图像主要反映组织某方面特性，而尽量抑制组织的其他特性对MR信号强度的影响。\nTI加权成像（T1-weighted imaging,T1WI）是指图像中组织信号强度的高低主要反映的是组织的纵向弛豫差别。\nT2加权成像（T2-weighted imaging,T2WI）重点突出的是不同组织之间的横向弛豫差别。\n质子密度加权成像（PDWI）则主要反映单位体积的不同组织之间的质子含量差别。\n质子密度加权成像质子密度加权成像主要反映单位体积不同组织间质子含量的差别。以甲乙两种组织为例，甲组织质子含量高于乙质子，90°射频脉冲激发后甲组织产生的旋转宏观横向磁化矢量就大于乙组织，这时马上检测MR信号，甲组织产生的MR信号将高于乙组织。\n            \n        \n    \n            \n    质子密度加权成像    \n    \n\n  \n\nT2加权成像与T2*加权成像T2WI主要反映不同组织间横向弛豫的差别，必须用聚焦脉冲采集自旋回波方可得到组织真正的T2弛豫信息。\n同样以甲乙组织为例，假如质子密度一样，甲乙两种组织产生的宏观纵向磁化矢量大小相同，一个射频脉冲如90°脉冲激发后，两种组织产生的旋转宏观横向磁化矢量大小也相同，这时不马上检测MR信号；90°脉冲关闭后，甲组织横向弛豫比乙组织慢，到一定时刻，甲组织衰减掉的宏观横向磁化矢量少于乙组织，其残留的宏观横向磁化矢量将大于乙组织，这时再检测MR信号，甲组织的MR信号强度将高于乙组织，这样就实现了T2WI。\n            \n        \n    \n            \n    T2WI加权成像原理    \n    \n\n  \n\n前面所述的 T2WI的回波信号必须采用聚焦脉冲来获得，如果不采用聚焦脉冲而仅采用读出梯度场的切换获取梯度回波信号，则磁共振信号反映的不是真正的 T2 弛豫信息而是T2*弛豫信息，因此得到的不是T2WI而是T2*WI。\nT1加权成像T1WI主要反映组织纵向弛豫的差别我们还是以甲、乙两种组织为例，假设这两种组织质子密度相同,但甲组织的纵向弛豫比乙组织快(即甲组织的 T1值短于乙组织)。进入主磁场后由于质子密度一样,甲乙两种组织产生的纵向磁化矢量大小相同，一个射频脉冲如 90°脉冲后产生的宏观横向磁化矢量的大小也相同,我们先不去理会这种宏观横向磁化矢量,也不马上检测 MR 信号。射频脉冲关闭后,甲乙两种组织将发生纵向驰豫，由于甲组织的纵向弛豫比乙组织快,过一定时间甲组织纵向磁化矢量比乙组织大。这时再产生一个90°脉冲，第二个 90°脉冲后,甲、乙两组织的宏观纵向磁化矢量将发生偏转，产生宏观横向磁化矢量，因为这时甲组织的纵向磁化矢量大于乙组织,其产生的宏观横向磁化矢量将大于乙组织,这时马上检测 MR信号,甲组织产生的 MR 信号将高于乙组织。\n\n            \n        \n    \n            \n    T1WI加权成像原理    \n    \n\n  \n在T1WI上,组织的T1值越小,其MR信号强度越大.\n\n\n参考《磁共振成像技术指南》—— 杨正汉\n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（二）","url":"/2023/05/06/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"核磁共振物理学原理\n原子结构\n原子由原子核和围绕原子核的电子构成，原子核中有中子和质子，中子不带电，质子带正电。\n自旋和核磁\n原子核具有一定大小和质量，可以视作一个球体，所有磁性原子核都有一个特性，就是总以一定的频率绕着自己的轴进行高速旋转，原子核这一特性称为自旋（spin）。由于原子核表面带有正电荷，所以磁性原子核的自旋就形成电流环路，从而产生具有一定大小和方向的磁化矢量。\n            \n        \n    \n            \n    原子核的自旋    \n    \n\n  \n\n不是所有的原子核均能自旋产生核磁，原子核内中子和质子的数目决定了原子核是否为磁性原子核。磁性原子核需保证：中子数和质子数至少要有一个是奇数。\n \n人体中的磁性原子人体中常见的磁性原子核如下图\n\n            \n        \n    \n            \n    人体中常见的磁性原子核    \n    \n\n  \n\n一般用于人体磁共振成像的原子核为氢原子核。但是并不是所有的H质子都能产生MRI信号，常规MRI的信号主要来源于水分子中的氢质子，部分组织的信号也可来源于脂肪中的氢质子。\n\n人体组织的水分子可分为自由水和结合水。结合水是指蛋白质大分子周围水化层中的水分子。自由水是指未与蛋白质结合在一起，活动充分自由的水分子。蛋白质和结合水的T2值都很短，采集不到这些信号。因此对于不含脂肪的组织，其MRI信号的直接来源是自由水。\n\n进入主磁场后人体氢质子核磁状态发生变化\n人体中氢质子自旋将产生无数个小核磁，但是由于方向杂乱无章，因此在自然状态下无明显磁性。MRI仪器无法检测每个氢质子产生的小核磁，仅能探测宏观磁化矢量的变化。当人体进入主磁场后，质子自旋产生的小磁场与主磁场平行排列，平行同向者略多于平行反向者，相互抵消后组织中最后产生一个与主磁场方向一致的磁化矢量，称作宏观葱香磁化矢量。\n\n            \n        \n    \n            \n    进入人体后氢质子核磁状态改变    \n    \n\n  \n\n之所以会有一些核磁与主磁场同向平行还有一些核磁与主磁场反向平行，涉及量子力学，简单解释：两种核磁代表的质子能量差别，平行同向的质子处于低能级，因此受主磁场的束缚，其磁化矢量的方向与主磁场的方向一致；平行反向的质子处于高能级，能够对抗主磁场的作用，处于低能级的质子多于高能级，整体产生一个宏观纵向磁矢量。\n\n            \n        \n    \n            \n    处于不同能级的氢质子核磁状态不同    \n    \n\n  \n\n随着温度、主磁场强度的改变，低能级多于高能级的氢质子数也将改变。一般在MRI系统中，温度是相对稳定的，因此只考虑主磁场强度的影响，主磁场越强，低能级多于高能级的氢质子数越高。\n\n            \n        \n    \n            \n    温度和磁场强度对宏观磁化矢量的影响    \n    \n\n  \n\n进动进入主磁场后，无论处于高能级还是处于低能级的质子，其磁化矢量并非完全与主磁场方向平行，而总是与主磁场有一定的角度。除了自旋运动外，其小核磁还绕着主磁场轴进行旋转摆动，这种运动叫做进动（precession）。\n\n            \n        \n    \n            \n    进动    \n    \n\n  \n\n进动频率  \n进动频率又称Larmor频率，其计算公式为:\n\n\n\n其中为磁旋比，B为主磁场的场强，单位T。可以看出进动频率与磁场强度成正比。\n\n\n由于进动的存在，质子自旋产生的小磁场又可以分解成两个部分，即纵向磁化分矢量和横向磁化分矢量。纵向分磁化矢量由低能级和高能级质子共同决定，低能级质子数多于高能级，因此纵向分磁化矢量与主磁场方向相同。由于质子在进动，其横向磁化分矢量会以主磁场方向为轴，在XY平面内做旋转运动，因此其方向处于不断的动态变化中。而各个氢质子的横向磁化分量在圆周的不同位置中，横向磁化分量相互抵消，所以没有宏观横向磁化矢量。\n\n            \n        \n    \n            \n    纵向与横向磁化矢量    \n    \n\n  \n\n宏观横向磁化矢量的检测 \n检测原理是初中所学过的电磁感应现象，闭合线圈在磁场中做切割磁感线运动会产生感应电流。\n如上所说，质子进动产生了纵向宏观磁矢量而不产生横向磁矢量，而纵向宏观磁矢量不切割磁感线，无法产生感应电流。（之后解释）\n\n            \n        \n    \n            \n    宏观横向磁矢量切割磁感线产生感应电流    \n    \n\n  \n\n\n磁共振现象  \n物理学上，共振被定义为能量从一个震动着的物体传递到另一物体，而后者以前者相同的频率振动，共振的条件是频率相同。\n如果我们给处于主磁场人体组织一个射频脉冲，这个射频脉冲的频率与质子的进动频率相同，射频脉冲的能量将传递给处于低能级的质子，处于低能级的质子获得能量后将跃迁到高能级，这种现象为磁共振现象。\n\n            \n        \n    \n            \n    磁共振现象    \n    \n\n  \n\n\n从宏观上看，磁共振现象使宏观纵向磁化矢量发生偏转，偏转角度与射频脉冲的能量有关，能量越大偏转角度越大。射频脉冲能量由脉冲强度和持续时间有关。\n\n            \n        \n    \n            \n    施加偏转角度不同的脉冲    \n    \n\n  \n\n90°脉冲 \n90°脉冲即使纵向宏观磁矢量偏转90°产生横向宏观磁化矢量，这时横向宏观磁化矢量最大。\n90°脉冲作用：\n\n90°使低能级质子跃迁进入高能级，使得低能级质子数与高能级质子数相同，因此纵向磁化矢量抵消。\n\n使质子的横向磁化分矢量处于同一相位。\n\n\n\n\n90°脉冲激发后组织中所产生的横向宏观磁化矢量的大小与脉冲激发前的宏观纵向磁化矢量的大小有关，而宏观纵向磁化矢量的大小与组织中的质子含量成正比。组织质子密度越高，其宏观纵向磁化矢量越大，90°脉冲激发后产生的宏观横向磁化矢量越大，切割接收线圈产生的电信号越强，MR信号就越高。\n\n核磁弛豫90°射频脉冲激发后的瞬间，组织中没有宏观纵向磁化矢量，而产生了最大的宏观横向磁化矢量；当90°脉冲关闭，我们可以注意到组织中的宏观横向磁化矢量从最大逐渐缩小到完全衰减，而宏观纵向磁化矢量从零逐渐恢复直至最大。这个过程即为核磁弛豫。\n\n            \n        \n    \n            \n    \n    核磁弛豫    \n    \n\n  \n\n横向弛豫90°脉冲使原来相位不一致的质子群处于同相位进动，质子小磁场的横向磁化分矢量相互叠加，从而产生旋转的宏观横向磁化矢量。90°脉冲关闭后，宏观横向磁化矢量衰减的是由于同相位进动额质子群逐渐失去了相位的一致，其横向磁化分矢量的叠加作用逐渐减弱。\n导致质子群失相位的原因主要有两个：\n\n质子周围磁环境随机波动。\n\n主磁场的不均匀。\n\n\n这种衰减称为自由感应衰减（free induction decay,FID）,也称T2*弛豫。\n180°脉冲可以消除主磁场不均匀造成的影响（之后解释），产生真正的T2弛豫，T2弛豫的能量传递发生于质子群内部，即质子与质子之间，因此T2弛豫也称自旋-自旋弛豫。\n\n            \n        \n    \n            \n    FID横向弛豫    \n    \n\n  \n\n一般用T2值来描述组织横向弛豫的快慢。从横向磁化矢量达到最大值为起点，以T2弛豫造成的横向磁化矢量衰减到最大值的37%为终点，起点与终点之间的时间间隔即为该组织的T2值。不同组织的T2值也不同，因此可以用T2加权成像（T2-weighted imaging,T2WI）方能区分不同的解剖结构，并能区分正常组织与病变组织。\n\n            \n        \n    \n            \n    组织T2    \n    \n\n  \n\n纵向弛豫\n当射频脉冲关闭后，在主磁场的作用下组织中的宏观纵向磁化矢量将逐渐恢复到激发前的状态即平衡状态，这一过程称为纵向弛豫，即T1弛豫。\n以90°脉冲为例，当脉冲关闭后，纵向磁化矢量将从零开始逐渐恢复至平衡状态。一般用T1值来描述组织的纵向弛豫的快慢。以90°脉冲关闭后，宏观纵向磁化矢量为零，以此为起点至宏观纵向磁化矢量恢复至最大值的63%为终点，这之间的时间间隔为T1值。\n纵向弛豫正好是与横向弛豫相反的过程，处于高能级状态的质子释放出能量回到低能级状态的过程。T1弛豫也可用来区分不同组织。T1弛豫能量释放快慢和质子周围的分子热运动频率有关，如果质子周围的分子热运动频率与质子的进动频率相等，那么质子能量释放的越快，纵向弛豫过程越短，T1越短，如果与周围分子的热运动频率相差较大，那么T1越长。\n\n            \n        \n    \n            \n    组织T1值    \n    \n\n \n\n磁共振信号磁共振线圈只能采集到旋转的宏观横向磁化矢量，而宏观横向磁化矢量切割接收线圈而产生的电信号实际上就是原始的磁共振信号。只要在接受时宏观横向磁化矢量越大，则采集到的电信号越大。\n自由感应衰减信号组织接受90°射频脉冲的激发，组织中将产生宏观横向磁化矢量，射频脉冲关闭后组织中的宏观横向磁化矢量由于受T2弛豫和主磁场不均匀的影响，而指数形式较快衰减，即自由感应衰减。\n            \n        \n    \n            \n    自由感应衰减信号    \n    \n\n \n\n自旋回波信号把主磁场不均匀造成的影响剔除，采集到的信息才能真正反映组织的T2弛豫。所采用的办法是180°聚焦脉冲。\n \n从Z轴方向看XY平面，假设质子逆时针进动，且进动方向保持不变。90°脉冲激发后质子的横向磁化分矢量相位一致。随着时间的推移，由于主磁场不均匀，质子的横向磁化矢量逐渐失相，到了180°脉冲施加前的即刻，质子1进动最快相位走在最前，质子4进动最慢，其相位落在最后；施加180°聚焦脉冲后，所有质子的相位反转了180°，即进动最慢的质子4的相位到了最前面，进动最快的质子1相位落到后面。\n\n\n            \n        \n    \n            \n    180°聚焦脉冲机制    \n    \n\n \n\n质子1依然进动最快，质子4进动最慢，所以随着质子群的推移，质子群相位逐渐重聚，将形成一个逐渐增大的宏观横向磁化矢量。经过与Ti相同的时间即2倍Ti时刻，进动最快的质子1赶上进动最慢的质子4。将形成最大的横向宏观磁化矢量。从此刻开始由于磁场强度分布不均匀，又将开始自由感应衰减。产生的这种回波信号称为自旋回波（SE）。\n\n            \n        \n    \n            \n    180°聚焦脉冲机制    \n    \n\n \n\n\n梯度回波信号梯度回波的产生过程是:如果人为的再添加一个磁场梯度，使磁场的不均匀程度更大，那么就会进一步加速T2*衰减，经过一段时间，将磁场梯度翻转。之前磁场强度较低的地方反过来具有较高的磁场强度，之前旋转得慢的原子核就旋转得更快了。相应地，之前磁场强度较高的地方反过来具有较低的磁场强度，之前旋转得快的原子核就旋转得更慢了。经过一定时间，之前的失相位就会被抵消，不同位置处的原子核相位重新同步，它们的磁化向量的方向分布更集中，这些向量之和的幅值就逐渐增大了。此时测得的信号就是一个梯度回波信号\n值得注意的是，只有施加磁场梯度产生的失相位才在添加反向磁场梯度后被抵消，由于其他原因产生的磁场不均匀 (例如BO的不均匀)是不会被抵消的，因此梯度回波的幅值是由T2*决定。\n\n            \n        \n         \n            \n    \n    梯度回波信号    \n    \n\n \n\n参考《磁共振成像技术指南》—— 杨正汉\n懿氏百科全书\n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（五）：K空间","url":"/2023/06/01/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9AK%E7%A9%BA%E9%97%B4/","content":"K空间和傅里叶变换在之前的学习中一直参考的是《磁共振成像技术指南》这本书，但是看书还是无法理解K空间和相位编码部分的知识。在网上找了一些资料看了一下，决定看看这部分数学推导，这样应该可以帮助理解。\nK空间数学原理在主磁场的+z方向上的梯度磁场激发下，假设某一个平面h(x,y)的进动频率为f0，那么理论证明，该切面产生的FID信号可以表示为\n\n上述公式推导过程非常复杂，我并没有看太懂 贴个连接 MRI原理-信号 有解释\n现在要通过S(t)把h(x,y)表示出来，h(x,y)表示二维的灰度值图像，那么该图像的频域表达式可以写为\n\n我们如果能求出H（u,v），那么就能通过傅里叶变换求出h(x,y)。\n于是，为了求解H(x,y)，人们引出了x和y方向上的梯度场，以此来标明连续空间中，不同位置的点在位置特定的场强（B0 + zGz和该点的Gx和Gy的矢量和）下对FID信号做出的贡献。\n则在原先f0的场强变为（xGx,yGy,B0+zGz）的一个矢量，f0就变成与x和y相关的函数\n\n上式对比二维傅里叶变换可得\n\n其中 , \n所以得到的S（t）经过解调制后，就能得到H（u,v），然后再进行傅里叶变换就可以得到原始图像信号。由有限个H（u,v）填满的矩阵，就叫做K-space。而为了填满K-space，不断的改变梯度场时间t， 和梯度场大小的操作， 就叫做频率编码和相位编码。\n\n            \n        \n    \n            \n    GX与GY在K空间的效应    \n    \n\n \n\n频率编码通过上图可以发现，当Gy为零时，Gx所持续的是填Tx共同决定了K空间的Kx轴，相反，Gy和Ty共同决定了Ky轴\n习惯上我们先沿着X轴方向采集信号，其中采集信号的方式就是采用脉冲时间序列。\n            \n        \n    \n            \n    在X方向上采样    \n    \n\n \n“slice refocusing gradient\" 这里的作用是当RF脉冲序列的频宽过大，与之发生共振的组织也会更多，共振频带过大，这导致切片出来的信号会出现小幅度的相位差，从而使得采集图像模糊。因此这里会加上一个slice refocusing gradient，使得RF频带中的组织都在一个比较小范围差的频率下发生共振。\n\n\n\n我的理解是由于进动频率由磁场强度决定，所以原来的激发范围很大，加上相反的磁场强度后，位于前面的质子频率增大，位于后面的质子频率减小，最后得到了一个相对小的激发频率带宽。\n            \n        \n    \n            \n    大概理解    \n    \n\n \n\n这里Gx不变，在Tx采样表示，在X轴上朝右移动。\n每次采样中，同一个x位置下的组织产生的是相同的共振频率。这也就是说，Kspace中，垂直于x轴线的每一条采样轨迹(trajectory), 都具有相同频率分布。换句话说，在kspace这一二维坐标系下，同一个横轴坐标表示具有同一个频率。这种采样方法形成的轨迹被叫做笛卡尔采样轨迹(Cartisan Trajectory)。而这种在x轴方向上固定梯度磁场大小，只改变磁场时间的采样方式，就叫做频率编码。\n为了能够既采样负x轴方向，又采集x的正轴方向，人们选择先从x轴的负方向出发一直到最左端，然后再掉头往x的正方向去。因此需要先加上一个负梯度，然后才是正梯度。\n\n            \n        \n    \n            \n    梯度先负再正    \n    \n    K空间内填充顺序\n    \n\n\n\n负梯度施加一个周期后，施加正梯度两个周期正好把X轴的一行采集完毕。这种梯度场产生的回波信号叫做梯度回波信号（Gradient Echo, GE）\n相位编码相对的在y轴上实行相位编码。而实际中X轴做频率编码还是相位编码并不是固定的，这两个轴采样方法可以反过来。\n\n            \n        \n    \n            \n    相位编码    \n    \n\n \n如果固定x轴的梯度Gx和磁场时间tx，即使得信号只沿着K-space的y轴发生平移，然后不停的改变Gy的大小，这造成了y方向上的每一个组织点都有不同的磁场大小，由此会导致不同的拉莫尔频率，而不同的拉莫尔频率又会导致组织点们out of phase，与之前学习的相位编码相同。在这里不同的Gy代表了不同Ty时刻Y轴的等间隔采样。这种采样方式称为相位编码。\n\n            \n        \n    \n            \n    填充K空间和傅里叶反变换后成像    \n    \n\n \n\n\n参考《磁共振成像技术指南》—— 杨正汉\n知乎：MRI—从产生信号到生成图像（二)   作者：嘭噗啪嚓吧\nMRI原理-信号   \n","categories":["影像基础"],"tags":["MRI"]},{"title":"核磁共振原理（四）","url":"/2023/05/24/%E6%A0%B8%E7%A3%81%E5%85%B1%E6%8C%AF%E5%8E%9F%E7%90%86%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"磁共振的空间定位地球上的纬度的定位依靠地磁梯度，实际上磁共振信号的三维空间定位也是利用三套梯度线圈产生的梯度磁场来实现的。MR信号的空间定位包括层面层厚的选择、频率编码、相位编码。\n层面和层厚的选择在1.5T场强下，质子进动频率约为64MHZ。在Z轴施加一个梯度场，在Z轴中心质子进动频率依然为64MHZ，靠近头部磁场逐渐减小进动频率变慢，靠近脚部磁场逐渐增大进动频率变大。假设梯度磁场造成进动频率差为1MHZ/cm，则使用63.5~64.5MHZ的射频脉冲，被激发层面的中心位置就在Z轴中心，厚度为1cm。\n            \n        \n    \n            \n    层面和层厚选择    \n    \n\n  \n\n在检查部位与层面选择梯度线圈的相对位置保持不变的情况下，层面和层厚受梯度场强度和射频脉冲影响的规律如下:\n\n梯度场不变,射频脉冲的频率增加,则层面的位置向梯度场高的一侧移动。\n梯度场不变，射频脉冲的带宽加宽，层厚增厚。\n射频脉冲的带宽不变,梯度场的场强增加,层厚变薄。\n\n频率编码经过选层得到的信号是一个二维层面所有的信息，需要进行频率编码和相位编码来区分方向。以头颅的横断面为例，在前后方向施加前高后低的梯度场，这样前部的质子进动频率高，后面的质子进动频率低。采集到的MR信号中就包含有不同频率空间的信息，经过傅里叶变换后可以区分出不同频率，分配到前后方向各自的位置上。\n            \n        \n    \n            \n    频率编码    \n    \n\n  \n\n\n相位编码频率编码只实现了区分前后位置，并没有左右位置的信息，因此需要相位编码来区分左右。在左右方向施加一个左高右低的相位编码梯度场，这样左右质子的进动频率就不同。进动频率不同会导致一段时间后质子的相位改变，这时关闭梯度场，这样相位的差别就会被保留下来。这时采集MR信号带有不同的相位信息，通过傅里叶变换可以区分不同相位的信号，实现了左右方向的空间定位。\n            \n        \n    \n    \n            \n    相位编码    \n    \n\n  \n\n由于傅里叶变换的特性，只能区分180°相位的信号。（此处不理解，在网上看到有说这里说法是错误的）因此如果矩阵是256×256的图像需要进行256次相位编码。\n            \n        \n    \n            \n    相位编码实际施加    \n    \n\n  \n相位编码的知识还是有点难理解，下一篇从数学角度进行解释\n\n参考《磁共振成像技术指南》—— 杨正汉\n","categories":["影像基础"],"tags":["MRI"]},{"title":"远程保存hexo博客仓库","url":"/2024/03/13/%E8%BF%9C%E7%A8%8B%E4%BF%9D%E5%AD%98hexo%E5%8D%9A%E5%AE%A2%E4%BB%93%E5%BA%93/","content":"问题来源博主之前用的是笔记本，最早的博客都存在笔记本上，读研之后电脑设备增多，工位一个，宿舍一个。如果用之前的方法，每个电脑上都保存一个博客数据，更新起来很不方便。于是我想到这个问题正好可以用Github解决（Github使用不熟练），所以在网上找了一个方法，本篇博客为记录并且复刻方法。\n参考: hexo个人博客：换了电脑怎么办\n解决方案首先需要知道，hexo生成的静态文件会放在public&#x2F;文件夹中，部署就是把public文件夹中的内容上传到git仓库中。\n\n方案一：在github仓库上新建一个仓库，然后把blog文件夹上传进行备份。\n\n方案二: 在博客仓库创建一个新的分支，使用分支来管理。\n\n\n步骤本文采用方案二\n1.拷贝远程仓库进入D盘，右键点击Git bash here\ngit clone git@github.com:maxiro-samurai/maxiro-samurai.github.io.git\n把项目文件夹拷贝到本地\n2.删除文件夹内容进入maxiro-samurai.github.io.git项目文件夹中，删除其中的内容，把blog文件夹（即备份的blog）下全部复制到其中\n3. .gitignore文件打开.gitignore文件，这个文件的作用是指定哪些文件上传的时候可以忽略，因为blog&#x2F;的文件并不全部都需要\n.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/\n意思就是上传的时候忽略以上内容\n4.创建一个hexo（任意名字）的分支并切换到这个分支git checkout -b hexo \n\n把所有文件添加到暂存区\ngit add --all\n\n提交到本地版本库\ngit commit -m &quot;&quot;\n\n推送hexo分支的文件到github仓库\ngit push --set-upstream origin hexo\n\n5. 结束\n效果\n\n这个就是最后需要备份的文件夹\n6.更新博客\n生成草稿\nhexo new draft 远程保存hexo博客仓库\n\n\n发布博客\n  hexo publish 远程保存hexo博客仓库\n  hexo g \n  hexo d\n\n\n更新备份\n  git add.\n\n  git commit -m&quot;注释&quot;\n\n  git push origin hexo\n\n\n\n至此大功告成，在新电脑上只需要从远程仓库clone到本地，然后按照上述步骤进行更新博客即可\n","tags":["杂记"]},{"title":"重新开始的模电生活（一）","url":"/2022/03/25/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%80%EF%BC%89/","content":"前言重学模电，不光理论，必须实践，实物搭建可能没有，用仿真软件Micro-cap，发现比Multisim强大，一起学了以后肯定用到。  \n教材资源参考《新概念模拟电路》下载地址：https://www.analog.com/cn/landing-pages/002/yang-e-book.html\nJFET 结型场效应管——晶体管内部载流子十分复杂，实际应用中只关注特定的几个参数，不展开\n\n晶体管分为NPN与PNP管\n            \n      \n  \n          \n  晶体管类型    \n  \n\n\n\n具体参数分析  \n以2N3415为例看数据手册 pdf连接：https://html.alldatasheet.com/html-pdf/50004/FAIRCHILD/2N3415/405/1/2N3415.html\n\n\n\n            \n        \n    \n            \n    2N3415 datasheet    \n    \n\n\n\nVCEO ：集电极到发射极最大电压\n\nVCBO ：集电极到基极的最大电压\n\nVEBO ：发射极到基极的最大反向电压\n\nIC ：集电极电流（正常工作下最大电流）\n\nPD : 功耗  \n\n耗散功率，也称集电极最大允许耗散功率PCM，是指晶体管参数变化不超过规定允许值时的最大集电极耗散功率。耗散功率与晶体管的最高允许结温和集电极最大电流有密切关系。硅管的结温允许值大约为150°C，锗管的结温允许值为85°C左右。要保证管子结温不超过允许值,就必须将产生的热散发出去。\n\nBJT的总耗散功率为Pc=IeVbe+IcVcb+Icrcs≈IcVcb），并且Pc关系到输出的最大交流功率Po：Po=(供给晶体管的直流功率Pd)–(晶体管耗散的功率Pc)=[η/(1–η)]Pc∝Pc，即输出交流功率与晶体管的耗散功率成正比（η=Po/Pd是转换效率）。晶体管功率的耗散(消耗)即发热，如果此热量不能及时散发掉,则将使集电结的结温Tj升高,这就限制了输出功率的提高；最高结温Tjm（一般定为175oC）时所对应的耗散功率即为最大耗散功率Pcm。为了提高Po，就要求提高Pc,但Pc的提高又受到结温的限制，为使结温不超过Tjm，就需要减小晶体管的热阻Rt；最大耗散功率Pcm∝1/Rt。最高结温Tjm时所对应的最大耗散功率为(Pcms≥Pcm)：稳态时，Pcm=(Tjm–Ta)/Rt；瞬态时，Pcms=(Tjm–Ta)/Rts。\n\n\n\nR : 热阻jc，芯片的热源结到封装外壳间的热阻，乘以发热量即获得结与壳的温差。\n\n一般热阻公式  = （散热良好）\n否侧  =（）\n如果为小功率器件，那么公式应为  =\n\n\nICBO : 集电极漏电流。\n\nIEBO ：发射极漏电流。\n\nhFE : 直流电流增益即β\n\n\n输入伏安特性\n晶体管的输入伏安特性，是指基极电流 iB与发射结电压UBE之间的关系——可能受到UCE的影响。\n\n\n\n\n仿真电路图\n\n\n            \n        \n    \n            \n    2N3415电路    \n    \n\n\n\n\n输入伏安特性曲线            \n      \n  \n          \n  输入伏安特性曲线    \n  \n\n\n\n输入伏安特性曲线与二极管类似\n输出伏安特性\n晶体管输出伏安特性，是指一个确定的基极电流iB下,集电极电流iC与 UCE之间的关系。\n\n\n电路图同上修改仿真软件的参数即可\n            \n      \n  \n          \n  参数具体修改    \n  \n\n\n\n输出伏安特性曲线\n  \n              \n          \n      \n              \n      输出伏安特性曲线    \n      \n  \n  \n\n\n放大区 ：满足 \n饱和区 ：一般分界电压为0.3V，压降很小而iC很大\n截止区 ：有漏电流，所以截止区也有电流，不过很小\n\n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（三）","url":"/2022/03/31/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%B8%89%EF%BC%89/","content":"动态响应求解输入为动态，输出也为动态的求解步骤  \n\n  \n\n输入信号只保留变化量，输出也指标是变化量（不关心频率） \n电路中的电压不变点接地，电路中电流不变支路开路 （详细解释看书）\n电路中某个元件再某个范围内，可以用直线表示其伏安特性，且输入变化过程中，该元件始终在直线上，则该元件可以用其动态电阻代替\n\n\n按照上述规则可以画出新的等效电路  \n  \n双极性晶体管的动态模型——微变等效模型低频等效当输入变化量 非常小时，可以把输入特性曲线在Q1看成一小段直线。对于输入伏安特性中的任意静态工作点有：  \nrbe即为动态电阻，在放大状态情况下，Q1点处的动态电阻可以近似表示为：  \n其中rbb’为体电阻，一般为几到几百，UT常温下为26mV。 \n当峰峰值为,就会产生峰峰值为的电流波形，两者的比例关系，近似为rbe。\n  \n\n            \n        \n    \n            \n    晶体管低频等效    \n    \n\n    \n\n高频等效不做解释（看模电书）\n\n            \n        \n    \n            \n    晶体管高频等效    \n    \n\n  \n\n动态分析三个重要指标\n\n电压放大倍数也叫电压增益，用Au表示，也可以用G表示，无单位。当输入正弦波峰峰值为ui，输出正弦波峰峰值为uo，电压增益为：\n\n\n  \n\n&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;也可以用分贝表示:\n\n\n\n输入电阻ri：\n\n\n它属于动态电阻，多数情况下希望放大电路的输入电阻越大越好。\n\n\n输出电阻ro：\n\n\n指输出端带负载的能力。输出电阻越大带负载能力越弱。\n\n动态分析的步骤\n以晶体管微变等效模型为核心，针对原始电路画出动态等效电路  \n  1.对电路中的电压不变点，实施接地。  2.对电路中的大电容，实施短接。对电路中的小电容，实施开路。  3.将晶体管，用晶体管的微变等效模型进行替代。  4.稍作整理\n\n\n\n            \n        \n    \n            \n    简化电路图    \n    \n\n  \n\n\n依次求解Au、ri根据动态等效电路，可以很轻松得到如下结论：\n\n\n输入电阻为:  \n\n求解Ro  ：\n  按照下图  \n              \n          \n      \n              \n      放大电路框图    \n      \n  \n    \n\n\n先扔掉负载电阻。任何放大电路的输出电阻，都与负载电阻无关。  \n让输入激励源=0，对电压输入短接即可，此时受控源一定变为0。  \n在输出端加一个虚拟电压源Uv，在电路中计算由此引起的iv  \n\n                                                    求解输出电阻              \n  \n\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（二）","url":"/2022/03/29/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"晶体管的工作状态\n截止状态：晶体管基极没有产生明显的电流，即IBQ非常小，导致ICQ也很小，晶体管没有导通。\n\n\n\n\n放大状态：指IBQ合适，且满足\n\n\n\n\n饱和状态：UCEQ小于UCES晶体管就处于饱和状态\n\n倒置状态：C和E管脚接反，此时晶体管 下降严重\n\n\n\n状态判断\n            \n        \n    \n            \n    判断法则    \n    \n\n\n\n\n静态估算步骤\n  1.根据UBEQ=0.7V，利用戴维南等效，KCL，KVL求解出IBQ  2.假设晶体管处于放大状态，列出集电极回路方程解出UCEQ  3.如果UCEQ&gt;=0.3V,则假设成立，反之不成立，晶体管处于饱和状态，UCEQ=0.3V\n\n\n  \n\n图解法求解静态工作点\n            \n        \n    \n            \n    电路图    \n    \n\n  \n\n输入伏安特性的图解法根据电路列出方程  \n\n该直线与输入伏安特性曲线的交点为Q（UBEQ,IBQ）\n\n            \n        \n    \n            \n    输入伏安特性图解    \n    \n\n  \n\n改变RB的值会改变直线跟曲线的交点\n\n输出伏安特性的图解法可列出方程该支线与输出伏安特性曲线的交点为Q（UCEQ,ICQ）\n\n            \n        \n    \n            \n    输出伏安特性图解    \n    \n\n  \n\n\n\n可发现改变RB的大小会改变输入曲线的交点，进而影响输出曲线上的点的位置，同理改变RC和EC都能达到同样效果\n  \n两部件串联分析法\n分别画出两个部件的伏安特性曲线\n以部件B的伏安特性曲线为基础，在图中找到横轴等于Ui的位置\n以此为中心点，部件A的伏安特性曲线实施横向镜像，绘制再原图中，此时，两根曲线会有一个交点，交点横轴即为输出电压，纵轴就是输出电流。\n\n\n            \n        \n    \n            \n    输出伏安特性图解    \n    \n\n  \n\n三极管同理  \n \n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（五）","url":"/2025/02/20/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E4%BA%94%EF%BC%89/","content":"大信号下情况的失真分析基本上分为超范围失真和非线性失真\n饱和失真和截至失真当晶体管进入截止区产生的输出波形失真，称为截止失真；进入饱和区产生的失真为饱和失真。\n使用仿真电路图如下：\n输入信号为1mV 5Khz\n经过之前的静态计算，可知VF1= 5V，在此静态下，放大电路可正常工作。\n输出端电压波形如下\n\n当把Rc增加为1.5K时，静态工作点VF1 = 2.5V左右\n输入信号10mv，即降低静态工作点，增大输入信号，输出将发生饱和失真。\n\n这是因为静态工作点VF1很小，在基极电流Ib变化过程中，UCEQ&lt;0.3V，进入饱和区导致输出截止。\n如果减小Rc到200Ω，并且增加输入信号幅值为100mv，输出将发生截止失真。\n\n因为Uc点的电压最高不能超过电源电压，晶体管截止就出现了截止失真。\n如下图所示 \n失真电压裕度失真电压裕度：在一个晶体管放大电路中，输入为正弦波电压信号，输出所能达到的最大的不失真正弦信号的幅度，用表示。\n因此\n如果当前静态工作点为Q（UCEQ,ICQ）则饱和失真电压裕度为：截止失真电压裕度为：\n\n\n\n静态负载线和动态负载线静态负载线，描述了EC和电阻RC不变的情况下，静态工作点改变收到的约束。而动态负载线，描述了电路开始工作之后——uce和iC在变化中收到的约束\n静态负载线，即分析静态下电路输出回路。  \n动态负载线，即分析动态下电路输出的回路。\n  \n\n对饱和失真电压裕度：\n\n对截止失真电压裕度：\n\n\n实际电路的失真——非线性失真   \n实际情况需要考虑输入伏安特性的非线性，在还未达到超范围失真时，ib就已经失真了。\n\n","categories":["硬件","模电"]},{"title":"重新开始的模电生活（六）","url":"/2025/02/21/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E5%85%AD%EF%BC%89/","content":"多级放大电路","categories":["硬件","模电"]},{"title":"重新开始的模电生活（四）","url":"/2022/04/03/%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%A8%A1%E7%94%B5%E7%94%9F%E6%B4%BB%EF%BC%88%E5%9B%9B%EF%BC%89/","content":"共基极、共集电极放大电路和PNP管电路晶体管放大核心“UBE变化，引起iB变化，映射出iC、iE变化”。所以，只有b，e两个极能够作为输入端。而输出信号一定在c或者e端。  \n  \n\n基极b输入，集电极c输出，叫共射极放大电路，全称为共发射极放大电路。  \n\n基极b输入，发射极e输出，这叫共集电极放大电路，也成射极跟随器。  \n\n发射极e输入，集电极c输出，这叫共基极放大电路。\n\n\n  \n晶体管有三个极，一个作为输入，一个作为输出，剩下什么极，就叫共什么极放大电路。\n  \n共基极放大电路  \n\n            \n        \n    \n            \n    共基极电路    \n    \n\n    \n\n\n静态分析 \n  1.戴维宁等效：   \n  \n  输入回路方程可解得：  \n    \n      \n  晶体管UCEQ&gt;0.3V,处于放大状态  \n  \n              \n          \n      \n              \n      静态分析结果    \n      \n  \n      \n\n  仿真结果稍有误差  \n     \n\n动态分析  \n  \n              \n          \n      \n              \n      动态等效电路    \n      \n  \n      \n\n\n列出节点电压方程：\n\n  $$\\left{  \\right.$$\n  可以得到  \n  如果信号源内阻为0，可简化为\n  从以上可以看出，共基极放大电路与共射放大电路又相同的电压增益，只是极性为同相放大，共射为反相放大，输入电阻小。  \n\n输入电阻：  \n\n                                                    动态仿真结果                  \n  可以看出与理论计算差别不大   \n\n\n共集电极放大电路此电路又称射极跟随器，它与共射级、共基极电路唯一的区别在于，Rc可以为0。另外两个电路Rc的作用是把IB的变化转化为电压的变化，而此电路的输出端在发射极，所以RC不是必须。                                                            共集电极放大电路                    \n\n静态分析，与前面两个类似不分析  \n\n动态分析 ：  \n              \n          \n      \n              \n      动态等效电路    \n      \n  \n      \n\n\n电压增益：  \n\n    \n  多数情况下，Aui近似为1  \n\n输入电阻：  \n\n  很显然输入电阻远大于共射放大电路（rbe），更大于共基极放大电路的输入电阻（），这是设计跟随器的显著优点。  \n\n输出电阻：  \n\n  输出电阻很小\n    \n  设计跟随器，虽然不具备电压放大能力，但是第一具有电流放大能力，第二具有输入电阻大、输出电阻小的特点，使其在扩流、阻抗匹配中获得了广泛应用。  \n  应注意，共射、共基极电路输入电阻与负载无关，输出电阻与信号源内阻无关。但共集电极电路却不是如此。他的输入电阻与负载大小有关，而输出电阻与信号源内阻有关。\n\n\n\nPNP管放大电路动态分析与NPN完全一样  \n\n方法一：对PNP管的全部伏安特性，都实施反向定义  \n\n对所有电流方向，均与NPN管相反。\n所有点位差定义，也相反。\n\n\n方法二：遵循NPN的全部定义，所有求解的值是反的，所有的图，都从第一象限镜像到第三象限。\n\n\n","categories":["硬件","模电"]}]